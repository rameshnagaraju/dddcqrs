/******/ (function(modules) { // webpackBootstrap
/******/ 	// The module cache
/******/ 	var installedModules = {};

/******/ 	// The require function
/******/ 	function __webpack_require__(moduleId) {

/******/ 		// Check if module is in cache
/******/ 		if(installedModules[moduleId])
/******/ 			return installedModules[moduleId].exports;

/******/ 		// Create a new module (and put it into the cache)
/******/ 		var module = installedModules[moduleId] = {
/******/ 			exports: {},
/******/ 			id: moduleId,
/******/ 			loaded: false
/******/ 		};

/******/ 		// Execute the module function
/******/ 		modules[moduleId].call(module.exports, module, module.exports, __webpack_require__);

/******/ 		// Flag the module as loaded
/******/ 		module.loaded = true;

/******/ 		// Return the exports of the module
/******/ 		return module.exports;
/******/ 	}


/******/ 	// expose the modules object (__webpack_modules__)
/******/ 	__webpack_require__.m = modules;

/******/ 	// expose the module cache
/******/ 	__webpack_require__.c = installedModules;

/******/ 	// __webpack_public_path__
/******/ 	__webpack_require__.p = "";

/******/ 	// Load entry module and return exports
/******/ 	return __webpack_require__(0);
/******/ })
/************************************************************************/
/******/ ([
/* 0 */
/***/ function(module, exports, __webpack_require__) {

	__webpack_require__(1);
	module.exports = __webpack_require__(2);


/***/ },
/* 1 */
/***/ function(module, exports) {

	var SocketIORemoteServiceClient,
	  slice = [].slice;

	SocketIORemoteServiceClient = (function() {
	  function SocketIORemoteServiceClient() {}

	  SocketIORemoteServiceClient.prototype.initialize = function(options) {
	    if (options == null) {
	      options = {};
	    }
	    this._subscriberId = 0;
	    this._rpcId = 0;
	    this._subscribers = [];
	    this._promises = {};
	    return this._initializeSocketIo(options);
	  };

	  SocketIORemoteServiceClient.prototype._initializeSocketIo = function(arg) {
	    var ioClientInstance;
	    ioClientInstance = arg.ioClientInstance;
	    return new Promise((function(_this) {
	      return function(resolve) {
	        _this._io_socket = ioClientInstance;
	        _this._initializeRPCResponseListener();
	        return resolve();
	      };
	    })(this));
	  };

	  SocketIORemoteServiceClient.prototype._initializeRPCResponseListener = function() {
	    return this._io_socket.on('eventric:rpcResponse', (function(_this) {
	      return function(response) {
	        return setTimeout(function() {
	          return _this._handleRpcResponse(response);
	        });
	      };
	    })(this));
	  };

	  SocketIORemoteServiceClient.prototype.rpc = function(payload) {
	    return new Promise((function(_this) {
	      return function(resolve, reject) {
	        var rpcId;
	        rpcId = _this._getNextRpcId();
	        payload.rpcId = rpcId;
	        _this._promises[rpcId] = {
	          resolve: resolve,
	          reject: reject
	        };
	        return _this._io_socket.emit('eventric:rpcRequest', payload);
	      };
	    })(this));
	  };

	  SocketIORemoteServiceClient.prototype._getNextRpcId = function() {
	    return this._rpcId++;
	  };

	  SocketIORemoteServiceClient.prototype._handleRpcResponse = function(response) {
	    if (response.rpcId == null) {
	      throw new Error('Missing rpcId in RPC Response');
	    }
	    if (!(response.rpcId in this._promises)) {
	      throw new Error("No promise registered for id " + response.rpcId);
	    }
	    if (response.error) {
	      if (response.error.constructor !== Error) {
	        response.error = this._convertObjectToError(response.error);
	      }
	      this._promises[response.rpcId].reject(response.error);
	    } else {
	      this._promises[response.rpcId].resolve(response.data);
	    }
	    return delete this._promises[response.rpcId];
	  };

	  SocketIORemoteServiceClient.prototype._convertObjectToError = function(object) {
	    var error;
	    error = new Error(object.message);
	    Object.keys(object).forEach(function(key) {
	      return error[key] = object[key];
	    });
	    return error;
	  };

	  SocketIORemoteServiceClient.prototype.subscribe = function() {
	    var aggregateId, arg, context, domainEventName, i, subscriberFn;
	    context = arguments[0], arg = 3 <= arguments.length ? slice.call(arguments, 1, i = arguments.length - 1) : (i = 1, []), subscriberFn = arguments[i++];
	    domainEventName = arg[0], aggregateId = arg[1];
	    return new Promise((function(_this) {
	      return function(resolve, reject) {
	        var fullEventName, subscriber;
	        fullEventName = _this._getFullEventName(context, domainEventName, aggregateId);
	        subscriber = {
	          eventName: fullEventName,
	          subscriberFn: subscriberFn,
	          subscriberId: _this._getNextSubscriberId()
	        };
	        _this._io_socket.emit('eventric:joinRoom', fullEventName);
	        _this._io_socket.on(fullEventName, subscriberFn);
	        _this._subscribers.push(subscriber);
	        return resolve(subscriber.subscriberId);
	      };
	    })(this));
	  };

	  SocketIORemoteServiceClient.prototype.unsubscribe = function(subscriberId) {
	    return new Promise((function(_this) {
	      return function(resolve, reject) {
	        var matchingSubscriber, othersHaveSubscribedToThisEvent;
	        matchingSubscriber = _this._subscribers.filter(function(subscriber) {
	          return subscriber.subscriberId === subscriberId;
	        })[0];
	        _this._subscribers = _this._subscribers.filter(function(subscriber) {
	          return subscriber !== matchingSubscriber;
	        });
	        _this._io_socket.removeListener(matchingSubscriber.eventName, matchingSubscriber.subscriberFn);
	        othersHaveSubscribedToThisEvent = _this._subscribers.some(function(subscriber) {
	          return subscriber.eventName === matchingSubscriber.eventName;
	        });
	        if (!othersHaveSubscribedToThisEvent) {
	          _this._io_socket.emit('eventric:leaveRoom', matchingSubscriber.eventName);
	        }
	        return resolve();
	      };
	    })(this));
	  };

	  SocketIORemoteServiceClient.prototype._getNextSubscriberId = function() {
	    return this._subscriberId++;
	  };

	  SocketIORemoteServiceClient.prototype._getFullEventName = function(context, domainEventName, aggregateId) {
	    var fullEventName;
	    fullEventName = context;
	    if (domainEventName) {
	      fullEventName += "/" + domainEventName;
	    }
	    if (aggregateId) {
	      fullEventName += "/" + aggregateId;
	    }
	    return fullEventName;
	  };

	  SocketIORemoteServiceClient.prototype.disconnect = function() {
	    return this._io_socket.disconnect();
	  };

	  return SocketIORemoteServiceClient;

	})();

	module.exports = new SocketIORemoteServiceClient;


/***/ },
/* 2 */
/***/ function(module, exports, __webpack_require__) {

	/* WEBPACK VAR INJECTION */(function(global) {var chai, eventric, expect, sinon;

	__webpack_require__(3).polyfill();

	chai = __webpack_require__(9);

	expect = chai.expect;

	eventric = __webpack_require__(47);

	sinon = __webpack_require__(48);

	describe('Remote SocketIO Client', function() {
	  var sandbox, socketIOClientStub, socketIORemoteClient;
	  socketIORemoteClient = null;
	  sandbox = null;
	  socketIOClientStub = null;
	  beforeEach(function() {
	    sandbox = sinon.sandbox.create();
	    socketIOClientStub = sandbox.stub();
	    socketIOClientStub.on = sandbox.stub();
	    socketIOClientStub.emit = sandbox.stub();
	    socketIOClientStub.removeListener = sandbox.stub();
	    return socketIORemoteClient = __webpack_require__(1);
	  });
	  afterEach(function() {
	    return sandbox.restore();
	  });
	  describe('#initialize', function() {
	    return it('should register a callback for eventric:rpcResponse which makes use of setTimeout', function() {
	      socketIOClientStub.on.yields();
	      sandbox.stub(global, 'setTimeout');
	      socketIORemoteClient.initialize({
	        ioClientInstance: socketIOClientStub
	      });
	      expect(socketIOClientStub.on.calledWith('eventric:rpcResponse', sinon.match.func)).to.be["true"];
	      return expect(global.setTimeout.calledOnce).to.be["true"];
	    });
	  });
	  describe('#rpc', function() {
	    beforeEach(function() {
	      sandbox.stub(global, 'setTimeout').yields();
	      return socketIORemoteClient.initialize({
	        ioClientInstance: socketIOClientStub
	      });
	    });
	    it('should emit an eventric:rpcRequest event with the given payload', function() {
	      var rpcPayload;
	      rpcPayload = {
	        some: 'payload'
	      };
	      socketIORemoteClient.rpc(rpcPayload);
	      return expect(socketIOClientStub.emit.calledWith('eventric:rpcRequest', rpcPayload)).to.be["true"];
	    });
	    it('should resolve with the correct response data given a rpc response', function(done) {
	      var payload, responseStub, rpcResponseHandler;
	      payload = {};
	      socketIORemoteClient.rpc(payload).then(function(responseData) {
	        expect(responseData).to.equal(responseStub.data);
	        return done();
	      });
	      responseStub = {
	        rpcId: payload.rpcId,
	        data: {}
	      };
	      rpcResponseHandler = socketIOClientStub.on.firstCall.args[1];
	      return rpcResponseHandler(responseStub);
	    });
	    it('should reject with an error given a rpc response with an error', function() {
	      var payload, responseStub, rpcResponseHandler;
	      payload = {};
	      socketIORemoteClient.rpc(payload)["catch"](function(error) {
	        expect(error).to.be(responseStub.error);
	        return done();
	      });
	      responseStub = {
	        rpcId: payload.rpcId,
	        error: new Error('The error message')
	      };
	      rpcResponseHandler = socketIOClientStub.on.firstCall.args[1];
	      return rpcResponseHandler(responseStub);
	    });
	    it('should reject with an error given a rpc response with an error like object', function(done) {
	      var payload, responseStub, rpcResponseHandler;
	      payload = {};
	      socketIORemoteClient.rpc(payload)["catch"](function(error) {
	        expect(error instanceof Error).to.be["true"];
	        expect(error.name).to.equal('SomeError');
	        expect(error.message).to.equal('The error message');
	        return done();
	      });
	      responseStub = {
	        rpcId: payload.rpcId,
	        error: {
	          name: 'SomeError',
	          message: 'The error message'
	        }
	      };
	      rpcResponseHandler = socketIOClientStub.on.firstCall.args[1];
	      return rpcResponseHandler(responseStub);
	    });
	    return it('should preserve all custom properties given a rpc response with an error like object with custom properties', function(done) {
	      var payload, responseStub, rpcResponseHandler;
	      payload = {};
	      socketIORemoteClient.rpc(payload)["catch"](function(error) {
	        expect(error instanceof Error).to.be["true"];
	        expect(error.customProperty).to.equal('customValue');
	        return done();
	      });
	      responseStub = {
	        rpcId: payload.rpcId,
	        error: {
	          name: 'SomeError',
	          message: 'The error message',
	          customProperty: 'customValue'
	        }
	      };
	      rpcResponseHandler = socketIOClientStub.on.firstCall.args[1];
	      return rpcResponseHandler(responseStub);
	    });
	  });
	  describe('#subscribe', function() {
	    var handler;
	    handler = null;
	    beforeEach(function() {
	      handler = function() {};
	      return socketIORemoteClient.initialize({
	        ioClientInstance: socketIOClientStub
	      });
	    });
	    it('should return an unique subscriber id', function() {
	      var subscriberId1, subscriberId2;
	      subscriberId1 = socketIORemoteClient.subscribe('context', handler);
	      subscriberId2 = socketIORemoteClient.subscribe('context', handler);
	      expect(subscriberId1).to.be.a('object');
	      expect(subscriberId2).to.be.a('object');
	      return expect(subscriberId1).not.to.equal(subscriberId2);
	    });
	    describe('given only a context name', function() {
	      beforeEach(function() {
	        return socketIORemoteClient.subscribe('context', handler);
	      });
	      it('should join the correct channel', function() {
	        return expect(socketIOClientStub.emit.calledWith('eventric:joinRoom', 'context')).to.be["true"];
	      });
	      return it('should subscribe to the correct event', function() {
	        return expect(socketIOClientStub.on.calledWith('context', handler)).to.be["true"];
	      });
	    });
	    describe('given a context name and event name', function() {
	      beforeEach(function() {
	        return socketIORemoteClient.subscribe('context', 'EventName', handler);
	      });
	      it('should join the correct channel', function() {
	        return expect(socketIOClientStub.emit.calledWith('eventric:joinRoom', 'context/EventName')).to.be["true"];
	      });
	      return it('should subscribe to the correct event', function() {
	        return expect(socketIOClientStub.on.calledWith('context/EventName', handler)).to.be["true"];
	      });
	    });
	    return describe('given a context name, event name and aggregate id', function() {
	      beforeEach(function() {
	        return socketIORemoteClient.subscribe('context', 'EventName', '12345', handler);
	      });
	      it('should join the correct channel', function() {
	        return expect(socketIOClientStub.emit.calledWith('eventric:joinRoom', 'context/EventName/12345')).to.be["true"];
	      });
	      return it('should subscribe to the correct event', function() {
	        return expect(socketIOClientStub.on.calledWith('context/EventName/12345', handler)).to.be["true"];
	      });
	    });
	  });
	  return describe('#unsubscribe', function() {
	    var handler;
	    handler = null;
	    beforeEach(function() {
	      handler = function() {};
	      return socketIORemoteClient.initialize({
	        ioClientInstance: socketIOClientStub
	      });
	    });
	    it('should unsubscribe from the given event', function() {
	      return socketIORemoteClient.subscribe('context/EventName/12345', handler).then(function(subscriberId) {
	        socketIORemoteClient.unsubscribe(subscriberId);
	        return expect(socketIOClientStub.removeListener.calledWith('context/EventName/12345', handler)).to.be["true"];
	      });
	    });
	    describe('given there are no more handlers for this event', function() {
	      return it('should leave the given channel', function() {
	        return socketIORemoteClient.subscribe('context', 'EventName', '12345', handler).then(function(subscriberId1) {
	          socketIORemoteClient.unsubscribe(subscriberId1);
	          return expect(socketIOClientStub.emit.calledWith('eventric:leaveRoom', 'context/EventName/12345')).to.be["true"];
	        });
	      });
	    });
	    return describe('given there are still handlers for this event', function() {
	      return it('should not leave the given channel', function() {
	        var subscriberId1Promise, subscriberId2Promise;
	        subscriberId1Promise = socketIORemoteClient.subscribe('context', 'EventName', '12345', handler);
	        subscriberId2Promise = socketIORemoteClient.subscribe('context', 'EventName', '12345', handler);
	        return Promise.all([subscriberId1Promise, subscriberId2Promise]).then(function(subscriberIds) {
	          socketIORemoteClient.unsubscribe(subscriberIds[1]);
	          return expect(socketIOClientStub.emit.calledWith('eventric:leaveRoom')).not.to.be["true"];
	        });
	      });
	    });
	  });
	});

	/* WEBPACK VAR INJECTION */}.call(exports, (function() { return this; }())))

/***/ },
/* 3 */
/***/ function(module, exports, __webpack_require__) {

	var require;var __WEBPACK_AMD_DEFINE_RESULT__;/* WEBPACK VAR INJECTION */(function(process, setImmediate, global, module) {/*!
	 * @overview es6-promise - a tiny implementation of Promises/A+.
	 * @copyright Copyright (c) 2014 Yehuda Katz, Tom Dale, Stefan Penner and contributors (Conversion to ES6 API by Jake Archibald)
	 * @license   Licensed under MIT license
	 *            See https://raw.githubusercontent.com/jakearchibald/es6-promise/master/LICENSE
	 * @version   2.1.1
	 */

	(function() {
	    "use strict";
	    function lib$es6$promise$utils$$objectOrFunction(x) {
	      return typeof x === 'function' || (typeof x === 'object' && x !== null);
	    }

	    function lib$es6$promise$utils$$isFunction(x) {
	      return typeof x === 'function';
	    }

	    function lib$es6$promise$utils$$isMaybeThenable(x) {
	      return typeof x === 'object' && x !== null;
	    }

	    var lib$es6$promise$utils$$_isArray;
	    if (!Array.isArray) {
	      lib$es6$promise$utils$$_isArray = function (x) {
	        return Object.prototype.toString.call(x) === '[object Array]';
	      };
	    } else {
	      lib$es6$promise$utils$$_isArray = Array.isArray;
	    }

	    var lib$es6$promise$utils$$isArray = lib$es6$promise$utils$$_isArray;
	    var lib$es6$promise$asap$$len = 0;
	    var lib$es6$promise$asap$$toString = {}.toString;
	    var lib$es6$promise$asap$$vertxNext;
	    function lib$es6$promise$asap$$asap(callback, arg) {
	      lib$es6$promise$asap$$queue[lib$es6$promise$asap$$len] = callback;
	      lib$es6$promise$asap$$queue[lib$es6$promise$asap$$len + 1] = arg;
	      lib$es6$promise$asap$$len += 2;
	      if (lib$es6$promise$asap$$len === 2) {
	        // If len is 2, that means that we need to schedule an async flush.
	        // If additional callbacks are queued before the queue is flushed, they
	        // will be processed by this flush that we are scheduling.
	        lib$es6$promise$asap$$scheduleFlush();
	      }
	    }

	    var lib$es6$promise$asap$$default = lib$es6$promise$asap$$asap;

	    var lib$es6$promise$asap$$browserWindow = (typeof window !== 'undefined') ? window : undefined;
	    var lib$es6$promise$asap$$browserGlobal = lib$es6$promise$asap$$browserWindow || {};
	    var lib$es6$promise$asap$$BrowserMutationObserver = lib$es6$promise$asap$$browserGlobal.MutationObserver || lib$es6$promise$asap$$browserGlobal.WebKitMutationObserver;
	    var lib$es6$promise$asap$$isNode = typeof process !== 'undefined' && {}.toString.call(process) === '[object process]';

	    // test for web worker but not in IE10
	    var lib$es6$promise$asap$$isWorker = typeof Uint8ClampedArray !== 'undefined' &&
	      typeof importScripts !== 'undefined' &&
	      typeof MessageChannel !== 'undefined';

	    // node
	    function lib$es6$promise$asap$$useNextTick() {
	      var nextTick = process.nextTick;
	      // node version 0.10.x displays a deprecation warning when nextTick is used recursively
	      // setImmediate should be used instead instead
	      var version = process.versions.node.match(/^(?:(\d+)\.)?(?:(\d+)\.)?(\*|\d+)$/);
	      if (Array.isArray(version) && version[1] === '0' && version[2] === '10') {
	        nextTick = setImmediate;
	      }
	      return function() {
	        nextTick(lib$es6$promise$asap$$flush);
	      };
	    }

	    // vertx
	    function lib$es6$promise$asap$$useVertxTimer() {
	      return function() {
	        lib$es6$promise$asap$$vertxNext(lib$es6$promise$asap$$flush);
	      };
	    }

	    function lib$es6$promise$asap$$useMutationObserver() {
	      var iterations = 0;
	      var observer = new lib$es6$promise$asap$$BrowserMutationObserver(lib$es6$promise$asap$$flush);
	      var node = document.createTextNode('');
	      observer.observe(node, { characterData: true });

	      return function() {
	        node.data = (iterations = ++iterations % 2);
	      };
	    }

	    // web worker
	    function lib$es6$promise$asap$$useMessageChannel() {
	      var channel = new MessageChannel();
	      channel.port1.onmessage = lib$es6$promise$asap$$flush;
	      return function () {
	        channel.port2.postMessage(0);
	      };
	    }

	    function lib$es6$promise$asap$$useSetTimeout() {
	      return function() {
	        setTimeout(lib$es6$promise$asap$$flush, 1);
	      };
	    }

	    var lib$es6$promise$asap$$queue = new Array(1000);
	    function lib$es6$promise$asap$$flush() {
	      for (var i = 0; i < lib$es6$promise$asap$$len; i+=2) {
	        var callback = lib$es6$promise$asap$$queue[i];
	        var arg = lib$es6$promise$asap$$queue[i+1];

	        callback(arg);

	        lib$es6$promise$asap$$queue[i] = undefined;
	        lib$es6$promise$asap$$queue[i+1] = undefined;
	      }

	      lib$es6$promise$asap$$len = 0;
	    }

	    function lib$es6$promise$asap$$attemptVertex() {
	      try {
	        var r = require;
	        var vertx = __webpack_require__(7);
	        lib$es6$promise$asap$$vertxNext = vertx.runOnLoop || vertx.runOnContext;
	        return lib$es6$promise$asap$$useVertxTimer();
	      } catch(e) {
	        return lib$es6$promise$asap$$useSetTimeout();
	      }
	    }

	    var lib$es6$promise$asap$$scheduleFlush;
	    // Decide what async method to use to triggering processing of queued callbacks:
	    if (lib$es6$promise$asap$$isNode) {
	      lib$es6$promise$asap$$scheduleFlush = lib$es6$promise$asap$$useNextTick();
	    } else if (lib$es6$promise$asap$$BrowserMutationObserver) {
	      lib$es6$promise$asap$$scheduleFlush = lib$es6$promise$asap$$useMutationObserver();
	    } else if (lib$es6$promise$asap$$isWorker) {
	      lib$es6$promise$asap$$scheduleFlush = lib$es6$promise$asap$$useMessageChannel();
	    } else if (lib$es6$promise$asap$$browserWindow === undefined && "function" === 'function') {
	      lib$es6$promise$asap$$scheduleFlush = lib$es6$promise$asap$$attemptVertex();
	    } else {
	      lib$es6$promise$asap$$scheduleFlush = lib$es6$promise$asap$$useSetTimeout();
	    }

	    function lib$es6$promise$$internal$$noop() {}

	    var lib$es6$promise$$internal$$PENDING   = void 0;
	    var lib$es6$promise$$internal$$FULFILLED = 1;
	    var lib$es6$promise$$internal$$REJECTED  = 2;

	    var lib$es6$promise$$internal$$GET_THEN_ERROR = new lib$es6$promise$$internal$$ErrorObject();

	    function lib$es6$promise$$internal$$selfFullfillment() {
	      return new TypeError("You cannot resolve a promise with itself");
	    }

	    function lib$es6$promise$$internal$$cannotReturnOwn() {
	      return new TypeError('A promises callback cannot return that same promise.');
	    }

	    function lib$es6$promise$$internal$$getThen(promise) {
	      try {
	        return promise.then;
	      } catch(error) {
	        lib$es6$promise$$internal$$GET_THEN_ERROR.error = error;
	        return lib$es6$promise$$internal$$GET_THEN_ERROR;
	      }
	    }

	    function lib$es6$promise$$internal$$tryThen(then, value, fulfillmentHandler, rejectionHandler) {
	      try {
	        then.call(value, fulfillmentHandler, rejectionHandler);
	      } catch(e) {
	        return e;
	      }
	    }

	    function lib$es6$promise$$internal$$handleForeignThenable(promise, thenable, then) {
	       lib$es6$promise$asap$$default(function(promise) {
	        var sealed = false;
	        var error = lib$es6$promise$$internal$$tryThen(then, thenable, function(value) {
	          if (sealed) { return; }
	          sealed = true;
	          if (thenable !== value) {
	            lib$es6$promise$$internal$$resolve(promise, value);
	          } else {
	            lib$es6$promise$$internal$$fulfill(promise, value);
	          }
	        }, function(reason) {
	          if (sealed) { return; }
	          sealed = true;

	          lib$es6$promise$$internal$$reject(promise, reason);
	        }, 'Settle: ' + (promise._label || ' unknown promise'));

	        if (!sealed && error) {
	          sealed = true;
	          lib$es6$promise$$internal$$reject(promise, error);
	        }
	      }, promise);
	    }

	    function lib$es6$promise$$internal$$handleOwnThenable(promise, thenable) {
	      if (thenable._state === lib$es6$promise$$internal$$FULFILLED) {
	        lib$es6$promise$$internal$$fulfill(promise, thenable._result);
	      } else if (thenable._state === lib$es6$promise$$internal$$REJECTED) {
	        lib$es6$promise$$internal$$reject(promise, thenable._result);
	      } else {
	        lib$es6$promise$$internal$$subscribe(thenable, undefined, function(value) {
	          lib$es6$promise$$internal$$resolve(promise, value);
	        }, function(reason) {
	          lib$es6$promise$$internal$$reject(promise, reason);
	        });
	      }
	    }

	    function lib$es6$promise$$internal$$handleMaybeThenable(promise, maybeThenable) {
	      if (maybeThenable.constructor === promise.constructor) {
	        lib$es6$promise$$internal$$handleOwnThenable(promise, maybeThenable);
	      } else {
	        var then = lib$es6$promise$$internal$$getThen(maybeThenable);

	        if (then === lib$es6$promise$$internal$$GET_THEN_ERROR) {
	          lib$es6$promise$$internal$$reject(promise, lib$es6$promise$$internal$$GET_THEN_ERROR.error);
	        } else if (then === undefined) {
	          lib$es6$promise$$internal$$fulfill(promise, maybeThenable);
	        } else if (lib$es6$promise$utils$$isFunction(then)) {
	          lib$es6$promise$$internal$$handleForeignThenable(promise, maybeThenable, then);
	        } else {
	          lib$es6$promise$$internal$$fulfill(promise, maybeThenable);
	        }
	      }
	    }

	    function lib$es6$promise$$internal$$resolve(promise, value) {
	      if (promise === value) {
	        lib$es6$promise$$internal$$reject(promise, lib$es6$promise$$internal$$selfFullfillment());
	      } else if (lib$es6$promise$utils$$objectOrFunction(value)) {
	        lib$es6$promise$$internal$$handleMaybeThenable(promise, value);
	      } else {
	        lib$es6$promise$$internal$$fulfill(promise, value);
	      }
	    }

	    function lib$es6$promise$$internal$$publishRejection(promise) {
	      if (promise._onerror) {
	        promise._onerror(promise._result);
	      }

	      lib$es6$promise$$internal$$publish(promise);
	    }

	    function lib$es6$promise$$internal$$fulfill(promise, value) {
	      if (promise._state !== lib$es6$promise$$internal$$PENDING) { return; }

	      promise._result = value;
	      promise._state = lib$es6$promise$$internal$$FULFILLED;

	      if (promise._subscribers.length !== 0) {
	        lib$es6$promise$asap$$default(lib$es6$promise$$internal$$publish, promise);
	      }
	    }

	    function lib$es6$promise$$internal$$reject(promise, reason) {
	      if (promise._state !== lib$es6$promise$$internal$$PENDING) { return; }
	      promise._state = lib$es6$promise$$internal$$REJECTED;
	      promise._result = reason;

	      lib$es6$promise$asap$$default(lib$es6$promise$$internal$$publishRejection, promise);
	    }

	    function lib$es6$promise$$internal$$subscribe(parent, child, onFulfillment, onRejection) {
	      var subscribers = parent._subscribers;
	      var length = subscribers.length;

	      parent._onerror = null;

	      subscribers[length] = child;
	      subscribers[length + lib$es6$promise$$internal$$FULFILLED] = onFulfillment;
	      subscribers[length + lib$es6$promise$$internal$$REJECTED]  = onRejection;

	      if (length === 0 && parent._state) {
	        lib$es6$promise$asap$$default(lib$es6$promise$$internal$$publish, parent);
	      }
	    }

	    function lib$es6$promise$$internal$$publish(promise) {
	      var subscribers = promise._subscribers;
	      var settled = promise._state;

	      if (subscribers.length === 0) { return; }

	      var child, callback, detail = promise._result;

	      for (var i = 0; i < subscribers.length; i += 3) {
	        child = subscribers[i];
	        callback = subscribers[i + settled];

	        if (child) {
	          lib$es6$promise$$internal$$invokeCallback(settled, child, callback, detail);
	        } else {
	          callback(detail);
	        }
	      }

	      promise._subscribers.length = 0;
	    }

	    function lib$es6$promise$$internal$$ErrorObject() {
	      this.error = null;
	    }

	    var lib$es6$promise$$internal$$TRY_CATCH_ERROR = new lib$es6$promise$$internal$$ErrorObject();

	    function lib$es6$promise$$internal$$tryCatch(callback, detail) {
	      try {
	        return callback(detail);
	      } catch(e) {
	        lib$es6$promise$$internal$$TRY_CATCH_ERROR.error = e;
	        return lib$es6$promise$$internal$$TRY_CATCH_ERROR;
	      }
	    }

	    function lib$es6$promise$$internal$$invokeCallback(settled, promise, callback, detail) {
	      var hasCallback = lib$es6$promise$utils$$isFunction(callback),
	          value, error, succeeded, failed;

	      if (hasCallback) {
	        value = lib$es6$promise$$internal$$tryCatch(callback, detail);

	        if (value === lib$es6$promise$$internal$$TRY_CATCH_ERROR) {
	          failed = true;
	          error = value.error;
	          value = null;
	        } else {
	          succeeded = true;
	        }

	        if (promise === value) {
	          lib$es6$promise$$internal$$reject(promise, lib$es6$promise$$internal$$cannotReturnOwn());
	          return;
	        }

	      } else {
	        value = detail;
	        succeeded = true;
	      }

	      if (promise._state !== lib$es6$promise$$internal$$PENDING) {
	        // noop
	      } else if (hasCallback && succeeded) {
	        lib$es6$promise$$internal$$resolve(promise, value);
	      } else if (failed) {
	        lib$es6$promise$$internal$$reject(promise, error);
	      } else if (settled === lib$es6$promise$$internal$$FULFILLED) {
	        lib$es6$promise$$internal$$fulfill(promise, value);
	      } else if (settled === lib$es6$promise$$internal$$REJECTED) {
	        lib$es6$promise$$internal$$reject(promise, value);
	      }
	    }

	    function lib$es6$promise$$internal$$initializePromise(promise, resolver) {
	      try {
	        resolver(function resolvePromise(value){
	          lib$es6$promise$$internal$$resolve(promise, value);
	        }, function rejectPromise(reason) {
	          lib$es6$promise$$internal$$reject(promise, reason);
	        });
	      } catch(e) {
	        lib$es6$promise$$internal$$reject(promise, e);
	      }
	    }

	    function lib$es6$promise$enumerator$$Enumerator(Constructor, input) {
	      var enumerator = this;

	      enumerator._instanceConstructor = Constructor;
	      enumerator.promise = new Constructor(lib$es6$promise$$internal$$noop);

	      if (enumerator._validateInput(input)) {
	        enumerator._input     = input;
	        enumerator.length     = input.length;
	        enumerator._remaining = input.length;

	        enumerator._init();

	        if (enumerator.length === 0) {
	          lib$es6$promise$$internal$$fulfill(enumerator.promise, enumerator._result);
	        } else {
	          enumerator.length = enumerator.length || 0;
	          enumerator._enumerate();
	          if (enumerator._remaining === 0) {
	            lib$es6$promise$$internal$$fulfill(enumerator.promise, enumerator._result);
	          }
	        }
	      } else {
	        lib$es6$promise$$internal$$reject(enumerator.promise, enumerator._validationError());
	      }
	    }

	    lib$es6$promise$enumerator$$Enumerator.prototype._validateInput = function(input) {
	      return lib$es6$promise$utils$$isArray(input);
	    };

	    lib$es6$promise$enumerator$$Enumerator.prototype._validationError = function() {
	      return new Error('Array Methods must be provided an Array');
	    };

	    lib$es6$promise$enumerator$$Enumerator.prototype._init = function() {
	      this._result = new Array(this.length);
	    };

	    var lib$es6$promise$enumerator$$default = lib$es6$promise$enumerator$$Enumerator;

	    lib$es6$promise$enumerator$$Enumerator.prototype._enumerate = function() {
	      var enumerator = this;

	      var length  = enumerator.length;
	      var promise = enumerator.promise;
	      var input   = enumerator._input;

	      for (var i = 0; promise._state === lib$es6$promise$$internal$$PENDING && i < length; i++) {
	        enumerator._eachEntry(input[i], i);
	      }
	    };

	    lib$es6$promise$enumerator$$Enumerator.prototype._eachEntry = function(entry, i) {
	      var enumerator = this;
	      var c = enumerator._instanceConstructor;

	      if (lib$es6$promise$utils$$isMaybeThenable(entry)) {
	        if (entry.constructor === c && entry._state !== lib$es6$promise$$internal$$PENDING) {
	          entry._onerror = null;
	          enumerator._settledAt(entry._state, i, entry._result);
	        } else {
	          enumerator._willSettleAt(c.resolve(entry), i);
	        }
	      } else {
	        enumerator._remaining--;
	        enumerator._result[i] = entry;
	      }
	    };

	    lib$es6$promise$enumerator$$Enumerator.prototype._settledAt = function(state, i, value) {
	      var enumerator = this;
	      var promise = enumerator.promise;

	      if (promise._state === lib$es6$promise$$internal$$PENDING) {
	        enumerator._remaining--;

	        if (state === lib$es6$promise$$internal$$REJECTED) {
	          lib$es6$promise$$internal$$reject(promise, value);
	        } else {
	          enumerator._result[i] = value;
	        }
	      }

	      if (enumerator._remaining === 0) {
	        lib$es6$promise$$internal$$fulfill(promise, enumerator._result);
	      }
	    };

	    lib$es6$promise$enumerator$$Enumerator.prototype._willSettleAt = function(promise, i) {
	      var enumerator = this;

	      lib$es6$promise$$internal$$subscribe(promise, undefined, function(value) {
	        enumerator._settledAt(lib$es6$promise$$internal$$FULFILLED, i, value);
	      }, function(reason) {
	        enumerator._settledAt(lib$es6$promise$$internal$$REJECTED, i, reason);
	      });
	    };
	    function lib$es6$promise$promise$all$$all(entries) {
	      return new lib$es6$promise$enumerator$$default(this, entries).promise;
	    }
	    var lib$es6$promise$promise$all$$default = lib$es6$promise$promise$all$$all;
	    function lib$es6$promise$promise$race$$race(entries) {
	      /*jshint validthis:true */
	      var Constructor = this;

	      var promise = new Constructor(lib$es6$promise$$internal$$noop);

	      if (!lib$es6$promise$utils$$isArray(entries)) {
	        lib$es6$promise$$internal$$reject(promise, new TypeError('You must pass an array to race.'));
	        return promise;
	      }

	      var length = entries.length;

	      function onFulfillment(value) {
	        lib$es6$promise$$internal$$resolve(promise, value);
	      }

	      function onRejection(reason) {
	        lib$es6$promise$$internal$$reject(promise, reason);
	      }

	      for (var i = 0; promise._state === lib$es6$promise$$internal$$PENDING && i < length; i++) {
	        lib$es6$promise$$internal$$subscribe(Constructor.resolve(entries[i]), undefined, onFulfillment, onRejection);
	      }

	      return promise;
	    }
	    var lib$es6$promise$promise$race$$default = lib$es6$promise$promise$race$$race;
	    function lib$es6$promise$promise$resolve$$resolve(object) {
	      /*jshint validthis:true */
	      var Constructor = this;

	      if (object && typeof object === 'object' && object.constructor === Constructor) {
	        return object;
	      }

	      var promise = new Constructor(lib$es6$promise$$internal$$noop);
	      lib$es6$promise$$internal$$resolve(promise, object);
	      return promise;
	    }
	    var lib$es6$promise$promise$resolve$$default = lib$es6$promise$promise$resolve$$resolve;
	    function lib$es6$promise$promise$reject$$reject(reason) {
	      /*jshint validthis:true */
	      var Constructor = this;
	      var promise = new Constructor(lib$es6$promise$$internal$$noop);
	      lib$es6$promise$$internal$$reject(promise, reason);
	      return promise;
	    }
	    var lib$es6$promise$promise$reject$$default = lib$es6$promise$promise$reject$$reject;

	    var lib$es6$promise$promise$$counter = 0;

	    function lib$es6$promise$promise$$needsResolver() {
	      throw new TypeError('You must pass a resolver function as the first argument to the promise constructor');
	    }

	    function lib$es6$promise$promise$$needsNew() {
	      throw new TypeError("Failed to construct 'Promise': Please use the 'new' operator, this object constructor cannot be called as a function.");
	    }

	    var lib$es6$promise$promise$$default = lib$es6$promise$promise$$Promise;
	    /**
	      Promise objects represent the eventual result of an asynchronous operation. The
	      primary way of interacting with a promise is through its `then` method, which
	      registers callbacks to receive either a promiseâ€™s eventual value or the reason
	      why the promise cannot be fulfilled.

	      Terminology
	      -----------

	      - `promise` is an object or function with a `then` method whose behavior conforms to this specification.
	      - `thenable` is an object or function that defines a `then` method.
	      - `value` is any legal JavaScript value (including undefined, a thenable, or a promise).
	      - `exception` is a value that is thrown using the throw statement.
	      - `reason` is a value that indicates why a promise was rejected.
	      - `settled` the final resting state of a promise, fulfilled or rejected.

	      A promise can be in one of three states: pending, fulfilled, or rejected.

	      Promises that are fulfilled have a fulfillment value and are in the fulfilled
	      state.  Promises that are rejected have a rejection reason and are in the
	      rejected state.  A fulfillment value is never a thenable.

	      Promises can also be said to *resolve* a value.  If this value is also a
	      promise, then the original promise's settled state will match the value's
	      settled state.  So a promise that *resolves* a promise that rejects will
	      itself reject, and a promise that *resolves* a promise that fulfills will
	      itself fulfill.


	      Basic Usage:
	      ------------

	      ```js
	      var promise = new Promise(function(resolve, reject) {
	        // on success
	        resolve(value);

	        // on failure
	        reject(reason);
	      });

	      promise.then(function(value) {
	        // on fulfillment
	      }, function(reason) {
	        // on rejection
	      });
	      ```

	      Advanced Usage:
	      ---------------

	      Promises shine when abstracting away asynchronous interactions such as
	      `XMLHttpRequest`s.

	      ```js
	      function getJSON(url) {
	        return new Promise(function(resolve, reject){
	          var xhr = new XMLHttpRequest();

	          xhr.open('GET', url);
	          xhr.onreadystatechange = handler;
	          xhr.responseType = 'json';
	          xhr.setRequestHeader('Accept', 'application/json');
	          xhr.send();

	          function handler() {
	            if (this.readyState === this.DONE) {
	              if (this.status === 200) {
	                resolve(this.response);
	              } else {
	                reject(new Error('getJSON: `' + url + '` failed with status: [' + this.status + ']'));
	              }
	            }
	          };
	        });
	      }

	      getJSON('/posts.json').then(function(json) {
	        // on fulfillment
	      }, function(reason) {
	        // on rejection
	      });
	      ```

	      Unlike callbacks, promises are great composable primitives.

	      ```js
	      Promise.all([
	        getJSON('/posts'),
	        getJSON('/comments')
	      ]).then(function(values){
	        values[0] // => postsJSON
	        values[1] // => commentsJSON

	        return values;
	      });
	      ```

	      @class Promise
	      @param {function} resolver
	      Useful for tooling.
	      @constructor
	    */
	    function lib$es6$promise$promise$$Promise(resolver) {
	      this._id = lib$es6$promise$promise$$counter++;
	      this._state = undefined;
	      this._result = undefined;
	      this._subscribers = [];

	      if (lib$es6$promise$$internal$$noop !== resolver) {
	        if (!lib$es6$promise$utils$$isFunction(resolver)) {
	          lib$es6$promise$promise$$needsResolver();
	        }

	        if (!(this instanceof lib$es6$promise$promise$$Promise)) {
	          lib$es6$promise$promise$$needsNew();
	        }

	        lib$es6$promise$$internal$$initializePromise(this, resolver);
	      }
	    }

	    lib$es6$promise$promise$$Promise.all = lib$es6$promise$promise$all$$default;
	    lib$es6$promise$promise$$Promise.race = lib$es6$promise$promise$race$$default;
	    lib$es6$promise$promise$$Promise.resolve = lib$es6$promise$promise$resolve$$default;
	    lib$es6$promise$promise$$Promise.reject = lib$es6$promise$promise$reject$$default;

	    lib$es6$promise$promise$$Promise.prototype = {
	      constructor: lib$es6$promise$promise$$Promise,

	    /**
	      The primary way of interacting with a promise is through its `then` method,
	      which registers callbacks to receive either a promise's eventual value or the
	      reason why the promise cannot be fulfilled.

	      ```js
	      findUser().then(function(user){
	        // user is available
	      }, function(reason){
	        // user is unavailable, and you are given the reason why
	      });
	      ```

	      Chaining
	      --------

	      The return value of `then` is itself a promise.  This second, 'downstream'
	      promise is resolved with the return value of the first promise's fulfillment
	      or rejection handler, or rejected if the handler throws an exception.

	      ```js
	      findUser().then(function (user) {
	        return user.name;
	      }, function (reason) {
	        return 'default name';
	      }).then(function (userName) {
	        // If `findUser` fulfilled, `userName` will be the user's name, otherwise it
	        // will be `'default name'`
	      });

	      findUser().then(function (user) {
	        throw new Error('Found user, but still unhappy');
	      }, function (reason) {
	        throw new Error('`findUser` rejected and we're unhappy');
	      }).then(function (value) {
	        // never reached
	      }, function (reason) {
	        // if `findUser` fulfilled, `reason` will be 'Found user, but still unhappy'.
	        // If `findUser` rejected, `reason` will be '`findUser` rejected and we're unhappy'.
	      });
	      ```
	      If the downstream promise does not specify a rejection handler, rejection reasons will be propagated further downstream.

	      ```js
	      findUser().then(function (user) {
	        throw new PedagogicalException('Upstream error');
	      }).then(function (value) {
	        // never reached
	      }).then(function (value) {
	        // never reached
	      }, function (reason) {
	        // The `PedgagocialException` is propagated all the way down to here
	      });
	      ```

	      Assimilation
	      ------------

	      Sometimes the value you want to propagate to a downstream promise can only be
	      retrieved asynchronously. This can be achieved by returning a promise in the
	      fulfillment or rejection handler. The downstream promise will then be pending
	      until the returned promise is settled. This is called *assimilation*.

	      ```js
	      findUser().then(function (user) {
	        return findCommentsByAuthor(user);
	      }).then(function (comments) {
	        // The user's comments are now available
	      });
	      ```

	      If the assimliated promise rejects, then the downstream promise will also reject.

	      ```js
	      findUser().then(function (user) {
	        return findCommentsByAuthor(user);
	      }).then(function (comments) {
	        // If `findCommentsByAuthor` fulfills, we'll have the value here
	      }, function (reason) {
	        // If `findCommentsByAuthor` rejects, we'll have the reason here
	      });
	      ```

	      Simple Example
	      --------------

	      Synchronous Example

	      ```javascript
	      var result;

	      try {
	        result = findResult();
	        // success
	      } catch(reason) {
	        // failure
	      }
	      ```

	      Errback Example

	      ```js
	      findResult(function(result, err){
	        if (err) {
	          // failure
	        } else {
	          // success
	        }
	      });
	      ```

	      Promise Example;

	      ```javascript
	      findResult().then(function(result){
	        // success
	      }, function(reason){
	        // failure
	      });
	      ```

	      Advanced Example
	      --------------

	      Synchronous Example

	      ```javascript
	      var author, books;

	      try {
	        author = findAuthor();
	        books  = findBooksByAuthor(author);
	        // success
	      } catch(reason) {
	        // failure
	      }
	      ```

	      Errback Example

	      ```js

	      function foundBooks(books) {

	      }

	      function failure(reason) {

	      }

	      findAuthor(function(author, err){
	        if (err) {
	          failure(err);
	          // failure
	        } else {
	          try {
	            findBoooksByAuthor(author, function(books, err) {
	              if (err) {
	                failure(err);
	              } else {
	                try {
	                  foundBooks(books);
	                } catch(reason) {
	                  failure(reason);
	                }
	              }
	            });
	          } catch(error) {
	            failure(err);
	          }
	          // success
	        }
	      });
	      ```

	      Promise Example;

	      ```javascript
	      findAuthor().
	        then(findBooksByAuthor).
	        then(function(books){
	          // found books
	      }).catch(function(reason){
	        // something went wrong
	      });
	      ```

	      @method then
	      @param {Function} onFulfilled
	      @param {Function} onRejected
	      Useful for tooling.
	      @return {Promise}
	    */
	      then: function(onFulfillment, onRejection) {
	        var parent = this;
	        var state = parent._state;

	        if (state === lib$es6$promise$$internal$$FULFILLED && !onFulfillment || state === lib$es6$promise$$internal$$REJECTED && !onRejection) {
	          return this;
	        }

	        var child = new this.constructor(lib$es6$promise$$internal$$noop);
	        var result = parent._result;

	        if (state) {
	          var callback = arguments[state - 1];
	          lib$es6$promise$asap$$default(function(){
	            lib$es6$promise$$internal$$invokeCallback(state, child, callback, result);
	          });
	        } else {
	          lib$es6$promise$$internal$$subscribe(parent, child, onFulfillment, onRejection);
	        }

	        return child;
	      },

	    /**
	      `catch` is simply sugar for `then(undefined, onRejection)` which makes it the same
	      as the catch block of a try/catch statement.

	      ```js
	      function findAuthor(){
	        throw new Error('couldn't find that author');
	      }

	      // synchronous
	      try {
	        findAuthor();
	      } catch(reason) {
	        // something went wrong
	      }

	      // async with promises
	      findAuthor().catch(function(reason){
	        // something went wrong
	      });
	      ```

	      @method catch
	      @param {Function} onRejection
	      Useful for tooling.
	      @return {Promise}
	    */
	      'catch': function(onRejection) {
	        return this.then(null, onRejection);
	      }
	    };
	    function lib$es6$promise$polyfill$$polyfill() {
	      var local;

	      if (typeof global !== 'undefined') {
	          local = global;
	      } else if (typeof self !== 'undefined') {
	          local = self;
	      } else {
	          try {
	              local = Function('return this')();
	          } catch (e) {
	              throw new Error('polyfill failed because global object is unavailable in this environment');
	          }
	      }

	      var P = local.Promise;

	      if (P && Object.prototype.toString.call(P.resolve()) === '[object Promise]' && !P.cast) {
	        return;
	      }

	      local.Promise = lib$es6$promise$promise$$default;
	    }
	    var lib$es6$promise$polyfill$$default = lib$es6$promise$polyfill$$polyfill;

	    var lib$es6$promise$umd$$ES6Promise = {
	      'Promise': lib$es6$promise$promise$$default,
	      'polyfill': lib$es6$promise$polyfill$$default
	    };

	    /* global define:true module:true window: true */
	    if ("function" === 'function' && __webpack_require__(8)['amd']) {
	      !(__WEBPACK_AMD_DEFINE_RESULT__ = function() { return lib$es6$promise$umd$$ES6Promise; }.call(exports, __webpack_require__, exports, module), __WEBPACK_AMD_DEFINE_RESULT__ !== undefined && (module.exports = __WEBPACK_AMD_DEFINE_RESULT__));
	    } else if (typeof module !== 'undefined' && module['exports']) {
	      module['exports'] = lib$es6$promise$umd$$ES6Promise;
	    } else if (typeof this !== 'undefined') {
	      this['ES6Promise'] = lib$es6$promise$umd$$ES6Promise;
	    }

	    lib$es6$promise$polyfill$$default();
	}).call(this);


	/* WEBPACK VAR INJECTION */}.call(exports, __webpack_require__(4), __webpack_require__(5).setImmediate, (function() { return this; }()), __webpack_require__(6)(module)))

/***/ },
/* 4 */
/***/ function(module, exports) {

	// shim for using process in browser

	var process = module.exports = {};
	var queue = [];
	var draining = false;
	var currentQueue;
	var queueIndex = -1;

	function cleanUpNextTick() {
	    draining = false;
	    if (currentQueue.length) {
	        queue = currentQueue.concat(queue);
	    } else {
	        queueIndex = -1;
	    }
	    if (queue.length) {
	        drainQueue();
	    }
	}

	function drainQueue() {
	    if (draining) {
	        return;
	    }
	    var timeout = setTimeout(cleanUpNextTick);
	    draining = true;

	    var len = queue.length;
	    while(len) {
	        currentQueue = queue;
	        queue = [];
	        while (++queueIndex < len) {
	            currentQueue[queueIndex].run();
	        }
	        queueIndex = -1;
	        len = queue.length;
	    }
	    currentQueue = null;
	    draining = false;
	    clearTimeout(timeout);
	}

	process.nextTick = function (fun) {
	    var args = new Array(arguments.length - 1);
	    if (arguments.length > 1) {
	        for (var i = 1; i < arguments.length; i++) {
	            args[i - 1] = arguments[i];
	        }
	    }
	    queue.push(new Item(fun, args));
	    if (queue.length === 1 && !draining) {
	        setTimeout(drainQueue, 0);
	    }
	};

	// v8 likes predictible objects
	function Item(fun, array) {
	    this.fun = fun;
	    this.array = array;
	}
	Item.prototype.run = function () {
	    this.fun.apply(null, this.array);
	};
	process.title = 'browser';
	process.browser = true;
	process.env = {};
	process.argv = [];
	process.version = ''; // empty string to avoid regexp issues
	process.versions = {};

	function noop() {}

	process.on = noop;
	process.addListener = noop;
	process.once = noop;
	process.off = noop;
	process.removeListener = noop;
	process.removeAllListeners = noop;
	process.emit = noop;

	process.binding = function (name) {
	    throw new Error('process.binding is not supported');
	};

	// TODO(shtylman)
	process.cwd = function () { return '/' };
	process.chdir = function (dir) {
	    throw new Error('process.chdir is not supported');
	};
	process.umask = function() { return 0; };


/***/ },
/* 5 */
/***/ function(module, exports, __webpack_require__) {

	/* WEBPACK VAR INJECTION */(function(setImmediate, clearImmediate) {var nextTick = __webpack_require__(4).nextTick;
	var apply = Function.prototype.apply;
	var slice = Array.prototype.slice;
	var immediateIds = {};
	var nextImmediateId = 0;

	// DOM APIs, for completeness

	exports.setTimeout = function() {
	  return new Timeout(apply.call(setTimeout, window, arguments), clearTimeout);
	};
	exports.setInterval = function() {
	  return new Timeout(apply.call(setInterval, window, arguments), clearInterval);
	};
	exports.clearTimeout =
	exports.clearInterval = function(timeout) { timeout.close(); };

	function Timeout(id, clearFn) {
	  this._id = id;
	  this._clearFn = clearFn;
	}
	Timeout.prototype.unref = Timeout.prototype.ref = function() {};
	Timeout.prototype.close = function() {
	  this._clearFn.call(window, this._id);
	};

	// Does not start the time, just sets up the members needed.
	exports.enroll = function(item, msecs) {
	  clearTimeout(item._idleTimeoutId);
	  item._idleTimeout = msecs;
	};

	exports.unenroll = function(item) {
	  clearTimeout(item._idleTimeoutId);
	  item._idleTimeout = -1;
	};

	exports._unrefActive = exports.active = function(item) {
	  clearTimeout(item._idleTimeoutId);

	  var msecs = item._idleTimeout;
	  if (msecs >= 0) {
	    item._idleTimeoutId = setTimeout(function onTimeout() {
	      if (item._onTimeout)
	        item._onTimeout();
	    }, msecs);
	  }
	};

	// That's not how node.js implements it but the exposed api is the same.
	exports.setImmediate = typeof setImmediate === "function" ? setImmediate : function(fn) {
	  var id = nextImmediateId++;
	  var args = arguments.length < 2 ? false : slice.call(arguments, 1);

	  immediateIds[id] = true;

	  nextTick(function onNextTick() {
	    if (immediateIds[id]) {
	      // fn.call() is faster so we optimize for the common use-case
	      // @see http://jsperf.com/call-apply-segu
	      if (args) {
	        fn.apply(null, args);
	      } else {
	        fn.call(null);
	      }
	      // Prevent ids from leaking
	      exports.clearImmediate(id);
	    }
	  });

	  return id;
	};

	exports.clearImmediate = typeof clearImmediate === "function" ? clearImmediate : function(id) {
	  delete immediateIds[id];
	};
	/* WEBPACK VAR INJECTION */}.call(exports, __webpack_require__(5).setImmediate, __webpack_require__(5).clearImmediate))

/***/ },
/* 6 */
/***/ function(module, exports) {

	module.exports = function(module) {
		if(!module.webpackPolyfill) {
			module.deprecate = function() {};
			module.paths = [];
			// module.parent = undefined by default
			module.children = [];
			module.webpackPolyfill = 1;
		}
		return module;
	}


/***/ },
/* 7 */
/***/ function(module, exports) {

	/* (ignored) */

/***/ },
/* 8 */
/***/ function(module, exports) {

	module.exports = function() { throw new Error("define cannot be used indirect"); };


/***/ },
/* 9 */
/***/ function(module, exports, __webpack_require__) {

	module.exports = __webpack_require__(10);


/***/ },
/* 10 */
/***/ function(module, exports, __webpack_require__) {

	/*!
	 * chai
	 * Copyright(c) 2011-2014 Jake Luer <jake@alogicalparadox.com>
	 * MIT Licensed
	 */

	var used = []
	  , exports = module.exports = {};

	/*!
	 * Chai version
	 */

	exports.version = '2.3.0';

	/*!
	 * Assertion Error
	 */

	exports.AssertionError = __webpack_require__(12);

	/*!
	 * Utils for plugins (not exported)
	 */

	var util = __webpack_require__(13);

	/**
	 * # .use(function)
	 *
	 * Provides a way to extend the internals of Chai
	 *
	 * @param {Function}
	 * @returns {this} for chaining
	 * @api public
	 */

	exports.use = function (fn) {
	  if (!~used.indexOf(fn)) {
	    fn(this, util);
	    used.push(fn);
	  }

	  return this;
	};

	/*!
	 * Utility Functions
	 */

	exports.util = util;

	/*!
	 * Configuration
	 */

	var config = __webpack_require__(24);
	exports.config = config;

	/*!
	 * Primary `Assertion` prototype
	 */

	var assertion = __webpack_require__(43);
	exports.use(assertion);

	/*!
	 * Core Assertions
	 */

	var core = __webpack_require__(11);
	exports.use(core);

	/*!
	 * Expect interface
	 */

	var expect = __webpack_require__(44);
	exports.use(expect);

	/*!
	 * Should interface
	 */

	var should = __webpack_require__(45);
	exports.use(should);

	/*!
	 * Assert interface
	 */

	var assert = __webpack_require__(46);
	exports.use(assert);


/***/ },
/* 11 */
/***/ function(module, exports) {

	/*!
	 * chai
	 * http://chaijs.com
	 * Copyright(c) 2011-2014 Jake Luer <jake@alogicalparadox.com>
	 * MIT Licensed
	 */

	module.exports = function (chai, _) {
	  var Assertion = chai.Assertion
	    , toString = Object.prototype.toString
	    , flag = _.flag;

	  /**
	   * ### Language Chains
	   *
	   * The following are provided as chainable getters to
	   * improve the readability of your assertions. They
	   * do not provide testing capabilities unless they
	   * have been overwritten by a plugin.
	   *
	   * **Chains**
	   *
	   * - to
	   * - be
	   * - been
	   * - is
	   * - that
	   * - which
	   * - and
	   * - has
	   * - have
	   * - with
	   * - at
	   * - of
	   * - same
	   *
	   * @name language chains
	   * @api public
	   */

	  [ 'to', 'be', 'been'
	  , 'is', 'and', 'has', 'have'
	  , 'with', 'that', 'which', 'at'
	  , 'of', 'same' ].forEach(function (chain) {
	    Assertion.addProperty(chain, function () {
	      return this;
	    });
	  });

	  /**
	   * ### .not
	   *
	   * Negates any of assertions following in the chain.
	   *
	   *     expect(foo).to.not.equal('bar');
	   *     expect(goodFn).to.not.throw(Error);
	   *     expect({ foo: 'baz' }).to.have.property('foo')
	   *       .and.not.equal('bar');
	   *
	   * @name not
	   * @api public
	   */

	  Assertion.addProperty('not', function () {
	    flag(this, 'negate', true);
	  });

	  /**
	   * ### .deep
	   *
	   * Sets the `deep` flag, later used by the `equal` and
	   * `property` assertions.
	   *
	   *     expect(foo).to.deep.equal({ bar: 'baz' });
	   *     expect({ foo: { bar: { baz: 'quux' } } })
	   *       .to.have.deep.property('foo.bar.baz', 'quux');
	   *
	   * `.deep.property` special characters can be escaped
	   * by adding two slashes before the `.` or `[]`.
	   *
	   *     var deepCss = { '.link': { '[target]': 42 }};
	   *     expect(deepCss).to.have.deep.property('\\.link.\\[target\\]', 42);
	   *
	   * @name deep
	   * @api public
	   */

	  Assertion.addProperty('deep', function () {
	    flag(this, 'deep', true);
	  });

	  /**
	   * ### .any
	   *
	   * Sets the `any` flag, (opposite of the `all` flag)
	   * later used in the `keys` assertion.
	   *
	   *     expect(foo).to.have.any.keys('bar', 'baz');
	   *
	   * @name any
	   * @api public
	   */

	  Assertion.addProperty('any', function () {
	    flag(this, 'any', true);
	    flag(this, 'all', false)
	  });


	  /**
	   * ### .all
	   *
	   * Sets the `all` flag (opposite of the `any` flag)
	   * later used by the `keys` assertion.
	   *
	   *     expect(foo).to.have.all.keys('bar', 'baz');
	   *
	   * @name all
	   * @api public
	   */

	  Assertion.addProperty('all', function () {
	    flag(this, 'all', true);
	    flag(this, 'any', false);
	  });

	  /**
	   * ### .a(type)
	   *
	   * The `a` and `an` assertions are aliases that can be
	   * used either as language chains or to assert a value's
	   * type.
	   *
	   *     // typeof
	   *     expect('test').to.be.a('string');
	   *     expect({ foo: 'bar' }).to.be.an('object');
	   *     expect(null).to.be.a('null');
	   *     expect(undefined).to.be.an('undefined');
	   *
	   *     // language chain
	   *     expect(foo).to.be.an.instanceof(Foo);
	   *
	   * @name a
	   * @alias an
	   * @param {String} type
	   * @param {String} message _optional_
	   * @api public
	   */

	  function an (type, msg) {
	    if (msg) flag(this, 'message', msg);
	    type = type.toLowerCase();
	    var obj = flag(this, 'object')
	      , article = ~[ 'a', 'e', 'i', 'o', 'u' ].indexOf(type.charAt(0)) ? 'an ' : 'a ';

	    this.assert(
	        type === _.type(obj)
	      , 'expected #{this} to be ' + article + type
	      , 'expected #{this} not to be ' + article + type
	    );
	  }

	  Assertion.addChainableMethod('an', an);
	  Assertion.addChainableMethod('a', an);

	  /**
	   * ### .include(value)
	   *
	   * The `include` and `contain` assertions can be used as either property
	   * based language chains or as methods to assert the inclusion of an object
	   * in an array or a substring in a string. When used as language chains,
	   * they toggle the `contains` flag for the `keys` assertion.
	   *
	   *     expect([1,2,3]).to.include(2);
	   *     expect('foobar').to.contain('foo');
	   *     expect({ foo: 'bar', hello: 'universe' }).to.include.keys('foo');
	   *
	   * @name include
	   * @alias contain
	   * @alias includes
	   * @alias contains
	   * @param {Object|String|Number} obj
	   * @param {String} message _optional_
	   * @api public
	   */

	  function includeChainingBehavior () {
	    flag(this, 'contains', true);
	  }

	  function include (val, msg) {
	    if (msg) flag(this, 'message', msg);
	    var obj = flag(this, 'object');
	    var expected = false;
	    if (_.type(obj) === 'array' && _.type(val) === 'object') {
	      for (var i in obj) {
	        if (_.eql(obj[i], val)) {
	          expected = true;
	          break;
	        }
	      }
	    } else if (_.type(val) === 'object') {
	      if (!flag(this, 'negate')) {
	        for (var k in val) new Assertion(obj).property(k, val[k]);
	        return;
	      }
	      var subset = {};
	      for (var k in val) subset[k] = obj[k];
	      expected = _.eql(subset, val);
	    } else {
	      expected = obj && ~obj.indexOf(val);
	    }
	    this.assert(
	        expected
	      , 'expected #{this} to include ' + _.inspect(val)
	      , 'expected #{this} to not include ' + _.inspect(val));
	  }

	  Assertion.addChainableMethod('include', include, includeChainingBehavior);
	  Assertion.addChainableMethod('contain', include, includeChainingBehavior);
	  Assertion.addChainableMethod('contains', include, includeChainingBehavior);
	  Assertion.addChainableMethod('includes', include, includeChainingBehavior);

	  /**
	   * ### .ok
	   *
	   * Asserts that the target is truthy.
	   *
	   *     expect('everthing').to.be.ok;
	   *     expect(1).to.be.ok;
	   *     expect(false).to.not.be.ok;
	   *     expect(undefined).to.not.be.ok;
	   *     expect(null).to.not.be.ok;
	   *
	   * @name ok
	   * @api public
	   */

	  Assertion.addProperty('ok', function () {
	    this.assert(
	        flag(this, 'object')
	      , 'expected #{this} to be truthy'
	      , 'expected #{this} to be falsy');
	  });

	  /**
	   * ### .true
	   *
	   * Asserts that the target is `true`.
	   *
	   *     expect(true).to.be.true;
	   *     expect(1).to.not.be.true;
	   *
	   * @name true
	   * @api public
	   */

	  Assertion.addProperty('true', function () {
	    this.assert(
	        true === flag(this, 'object')
	      , 'expected #{this} to be true'
	      , 'expected #{this} to be false'
	      , this.negate ? false : true
	    );
	  });

	  /**
	   * ### .false
	   *
	   * Asserts that the target is `false`.
	   *
	   *     expect(false).to.be.false;
	   *     expect(0).to.not.be.false;
	   *
	   * @name false
	   * @api public
	   */

	  Assertion.addProperty('false', function () {
	    this.assert(
	        false === flag(this, 'object')
	      , 'expected #{this} to be false'
	      , 'expected #{this} to be true'
	      , this.negate ? true : false
	    );
	  });

	  /**
	   * ### .null
	   *
	   * Asserts that the target is `null`.
	   *
	   *     expect(null).to.be.null;
	   *     expect(undefined).to.not.be.null;
	   *
	   * @name null
	   * @api public
	   */

	  Assertion.addProperty('null', function () {
	    this.assert(
	        null === flag(this, 'object')
	      , 'expected #{this} to be null'
	      , 'expected #{this} not to be null'
	    );
	  });

	  /**
	   * ### .undefined
	   *
	   * Asserts that the target is `undefined`.
	   *
	   *     expect(undefined).to.be.undefined;
	   *     expect(null).to.not.be.undefined;
	   *
	   * @name undefined
	   * @api public
	   */

	  Assertion.addProperty('undefined', function () {
	    this.assert(
	        undefined === flag(this, 'object')
	      , 'expected #{this} to be undefined'
	      , 'expected #{this} not to be undefined'
	    );
	  });

	  /**
	   * ### .exist
	   *
	   * Asserts that the target is neither `null` nor `undefined`.
	   *
	   *     var foo = 'hi'
	   *       , bar = null
	   *       , baz;
	   *
	   *     expect(foo).to.exist;
	   *     expect(bar).to.not.exist;
	   *     expect(baz).to.not.exist;
	   *
	   * @name exist
	   * @api public
	   */

	  Assertion.addProperty('exist', function () {
	    this.assert(
	        null != flag(this, 'object')
	      , 'expected #{this} to exist'
	      , 'expected #{this} to not exist'
	    );
	  });


	  /**
	   * ### .empty
	   *
	   * Asserts that the target's length is `0`. For arrays and strings, it checks
	   * the `length` property. For objects, it gets the count of
	   * enumerable keys.
	   *
	   *     expect([]).to.be.empty;
	   *     expect('').to.be.empty;
	   *     expect({}).to.be.empty;
	   *
	   * @name empty
	   * @api public
	   */

	  Assertion.addProperty('empty', function () {
	    var obj = flag(this, 'object')
	      , expected = obj;

	    if (Array.isArray(obj) || 'string' === typeof object) {
	      expected = obj.length;
	    } else if (typeof obj === 'object') {
	      expected = Object.keys(obj).length;
	    }

	    this.assert(
	        !expected
	      , 'expected #{this} to be empty'
	      , 'expected #{this} not to be empty'
	    );
	  });

	  /**
	   * ### .arguments
	   *
	   * Asserts that the target is an arguments object.
	   *
	   *     function test () {
	   *       expect(arguments).to.be.arguments;
	   *     }
	   *
	   * @name arguments
	   * @alias Arguments
	   * @api public
	   */

	  function checkArguments () {
	    var obj = flag(this, 'object')
	      , type = Object.prototype.toString.call(obj);
	    this.assert(
	        '[object Arguments]' === type
	      , 'expected #{this} to be arguments but got ' + type
	      , 'expected #{this} to not be arguments'
	    );
	  }

	  Assertion.addProperty('arguments', checkArguments);
	  Assertion.addProperty('Arguments', checkArguments);

	  /**
	   * ### .equal(value)
	   *
	   * Asserts that the target is strictly equal (`===`) to `value`.
	   * Alternately, if the `deep` flag is set, asserts that
	   * the target is deeply equal to `value`.
	   *
	   *     expect('hello').to.equal('hello');
	   *     expect(42).to.equal(42);
	   *     expect(1).to.not.equal(true);
	   *     expect({ foo: 'bar' }).to.not.equal({ foo: 'bar' });
	   *     expect({ foo: 'bar' }).to.deep.equal({ foo: 'bar' });
	   *
	   * @name equal
	   * @alias equals
	   * @alias eq
	   * @alias deep.equal
	   * @param {Mixed} value
	   * @param {String} message _optional_
	   * @api public
	   */

	  function assertEqual (val, msg) {
	    if (msg) flag(this, 'message', msg);
	    var obj = flag(this, 'object');
	    if (flag(this, 'deep')) {
	      return this.eql(val);
	    } else {
	      this.assert(
	          val === obj
	        , 'expected #{this} to equal #{exp}'
	        , 'expected #{this} to not equal #{exp}'
	        , val
	        , this._obj
	        , true
	      );
	    }
	  }

	  Assertion.addMethod('equal', assertEqual);
	  Assertion.addMethod('equals', assertEqual);
	  Assertion.addMethod('eq', assertEqual);

	  /**
	   * ### .eql(value)
	   *
	   * Asserts that the target is deeply equal to `value`.
	   *
	   *     expect({ foo: 'bar' }).to.eql({ foo: 'bar' });
	   *     expect([ 1, 2, 3 ]).to.eql([ 1, 2, 3 ]);
	   *
	   * @name eql
	   * @alias eqls
	   * @param {Mixed} value
	   * @param {String} message _optional_
	   * @api public
	   */

	  function assertEql(obj, msg) {
	    if (msg) flag(this, 'message', msg);
	    this.assert(
	        _.eql(obj, flag(this, 'object'))
	      , 'expected #{this} to deeply equal #{exp}'
	      , 'expected #{this} to not deeply equal #{exp}'
	      , obj
	      , this._obj
	      , true
	    );
	  }

	  Assertion.addMethod('eql', assertEql);
	  Assertion.addMethod('eqls', assertEql);

	  /**
	   * ### .above(value)
	   *
	   * Asserts that the target is greater than `value`.
	   *
	   *     expect(10).to.be.above(5);
	   *
	   * Can also be used in conjunction with `length` to
	   * assert a minimum length. The benefit being a
	   * more informative error message than if the length
	   * was supplied directly.
	   *
	   *     expect('foo').to.have.length.above(2);
	   *     expect([ 1, 2, 3 ]).to.have.length.above(2);
	   *
	   * @name above
	   * @alias gt
	   * @alias greaterThan
	   * @param {Number} value
	   * @param {String} message _optional_
	   * @api public
	   */

	  function assertAbove (n, msg) {
	    if (msg) flag(this, 'message', msg);
	    var obj = flag(this, 'object');
	    if (flag(this, 'doLength')) {
	      new Assertion(obj, msg).to.have.property('length');
	      var len = obj.length;
	      this.assert(
	          len > n
	        , 'expected #{this} to have a length above #{exp} but got #{act}'
	        , 'expected #{this} to not have a length above #{exp}'
	        , n
	        , len
	      );
	    } else {
	      this.assert(
	          obj > n
	        , 'expected #{this} to be above ' + n
	        , 'expected #{this} to be at most ' + n
	      );
	    }
	  }

	  Assertion.addMethod('above', assertAbove);
	  Assertion.addMethod('gt', assertAbove);
	  Assertion.addMethod('greaterThan', assertAbove);

	  /**
	   * ### .least(value)
	   *
	   * Asserts that the target is greater than or equal to `value`.
	   *
	   *     expect(10).to.be.at.least(10);
	   *
	   * Can also be used in conjunction with `length` to
	   * assert a minimum length. The benefit being a
	   * more informative error message than if the length
	   * was supplied directly.
	   *
	   *     expect('foo').to.have.length.of.at.least(2);
	   *     expect([ 1, 2, 3 ]).to.have.length.of.at.least(3);
	   *
	   * @name least
	   * @alias gte
	   * @param {Number} value
	   * @param {String} message _optional_
	   * @api public
	   */

	  function assertLeast (n, msg) {
	    if (msg) flag(this, 'message', msg);
	    var obj = flag(this, 'object');
	    if (flag(this, 'doLength')) {
	      new Assertion(obj, msg).to.have.property('length');
	      var len = obj.length;
	      this.assert(
	          len >= n
	        , 'expected #{this} to have a length at least #{exp} but got #{act}'
	        , 'expected #{this} to have a length below #{exp}'
	        , n
	        , len
	      );
	    } else {
	      this.assert(
	          obj >= n
	        , 'expected #{this} to be at least ' + n
	        , 'expected #{this} to be below ' + n
	      );
	    }
	  }

	  Assertion.addMethod('least', assertLeast);
	  Assertion.addMethod('gte', assertLeast);

	  /**
	   * ### .below(value)
	   *
	   * Asserts that the target is less than `value`.
	   *
	   *     expect(5).to.be.below(10);
	   *
	   * Can also be used in conjunction with `length` to
	   * assert a maximum length. The benefit being a
	   * more informative error message than if the length
	   * was supplied directly.
	   *
	   *     expect('foo').to.have.length.below(4);
	   *     expect([ 1, 2, 3 ]).to.have.length.below(4);
	   *
	   * @name below
	   * @alias lt
	   * @alias lessThan
	   * @param {Number} value
	   * @param {String} message _optional_
	   * @api public
	   */

	  function assertBelow (n, msg) {
	    if (msg) flag(this, 'message', msg);
	    var obj = flag(this, 'object');
	    if (flag(this, 'doLength')) {
	      new Assertion(obj, msg).to.have.property('length');
	      var len = obj.length;
	      this.assert(
	          len < n
	        , 'expected #{this} to have a length below #{exp} but got #{act}'
	        , 'expected #{this} to not have a length below #{exp}'
	        , n
	        , len
	      );
	    } else {
	      this.assert(
	          obj < n
	        , 'expected #{this} to be below ' + n
	        , 'expected #{this} to be at least ' + n
	      );
	    }
	  }

	  Assertion.addMethod('below', assertBelow);
	  Assertion.addMethod('lt', assertBelow);
	  Assertion.addMethod('lessThan', assertBelow);

	  /**
	   * ### .most(value)
	   *
	   * Asserts that the target is less than or equal to `value`.
	   *
	   *     expect(5).to.be.at.most(5);
	   *
	   * Can also be used in conjunction with `length` to
	   * assert a maximum length. The benefit being a
	   * more informative error message than if the length
	   * was supplied directly.
	   *
	   *     expect('foo').to.have.length.of.at.most(4);
	   *     expect([ 1, 2, 3 ]).to.have.length.of.at.most(3);
	   *
	   * @name most
	   * @alias lte
	   * @param {Number} value
	   * @param {String} message _optional_
	   * @api public
	   */

	  function assertMost (n, msg) {
	    if (msg) flag(this, 'message', msg);
	    var obj = flag(this, 'object');
	    if (flag(this, 'doLength')) {
	      new Assertion(obj, msg).to.have.property('length');
	      var len = obj.length;
	      this.assert(
	          len <= n
	        , 'expected #{this} to have a length at most #{exp} but got #{act}'
	        , 'expected #{this} to have a length above #{exp}'
	        , n
	        , len
	      );
	    } else {
	      this.assert(
	          obj <= n
	        , 'expected #{this} to be at most ' + n
	        , 'expected #{this} to be above ' + n
	      );
	    }
	  }

	  Assertion.addMethod('most', assertMost);
	  Assertion.addMethod('lte', assertMost);

	  /**
	   * ### .within(start, finish)
	   *
	   * Asserts that the target is within a range.
	   *
	   *     expect(7).to.be.within(5,10);
	   *
	   * Can also be used in conjunction with `length` to
	   * assert a length range. The benefit being a
	   * more informative error message than if the length
	   * was supplied directly.
	   *
	   *     expect('foo').to.have.length.within(2,4);
	   *     expect([ 1, 2, 3 ]).to.have.length.within(2,4);
	   *
	   * @name within
	   * @param {Number} start lowerbound inclusive
	   * @param {Number} finish upperbound inclusive
	   * @param {String} message _optional_
	   * @api public
	   */

	  Assertion.addMethod('within', function (start, finish, msg) {
	    if (msg) flag(this, 'message', msg);
	    var obj = flag(this, 'object')
	      , range = start + '..' + finish;
	    if (flag(this, 'doLength')) {
	      new Assertion(obj, msg).to.have.property('length');
	      var len = obj.length;
	      this.assert(
	          len >= start && len <= finish
	        , 'expected #{this} to have a length within ' + range
	        , 'expected #{this} to not have a length within ' + range
	      );
	    } else {
	      this.assert(
	          obj >= start && obj <= finish
	        , 'expected #{this} to be within ' + range
	        , 'expected #{this} to not be within ' + range
	      );
	    }
	  });

	  /**
	   * ### .instanceof(constructor)
	   *
	   * Asserts that the target is an instance of `constructor`.
	   *
	   *     var Tea = function (name) { this.name = name; }
	   *       , Chai = new Tea('chai');
	   *
	   *     expect(Chai).to.be.an.instanceof(Tea);
	   *     expect([ 1, 2, 3 ]).to.be.instanceof(Array);
	   *
	   * @name instanceof
	   * @param {Constructor} constructor
	   * @param {String} message _optional_
	   * @alias instanceOf
	   * @api public
	   */

	  function assertInstanceOf (constructor, msg) {
	    if (msg) flag(this, 'message', msg);
	    var name = _.getName(constructor);
	    this.assert(
	        flag(this, 'object') instanceof constructor
	      , 'expected #{this} to be an instance of ' + name
	      , 'expected #{this} to not be an instance of ' + name
	    );
	  };

	  Assertion.addMethod('instanceof', assertInstanceOf);
	  Assertion.addMethod('instanceOf', assertInstanceOf);

	  /**
	   * ### .property(name, [value])
	   *
	   * Asserts that the target has a property `name`, optionally asserting that
	   * the value of that property is strictly equal to  `value`.
	   * If the `deep` flag is set, you can use dot- and bracket-notation for deep
	   * references into objects and arrays.
	   *
	   *     // simple referencing
	   *     var obj = { foo: 'bar' };
	   *     expect(obj).to.have.property('foo');
	   *     expect(obj).to.have.property('foo', 'bar');
	   *
	   *     // deep referencing
	   *     var deepObj = {
	   *         green: { tea: 'matcha' }
	   *       , teas: [ 'chai', 'matcha', { tea: 'konacha' } ]
	   *     };
	   *
	   *     expect(deepObj).to.have.deep.property('green.tea', 'matcha');
	   *     expect(deepObj).to.have.deep.property('teas[1]', 'matcha');
	   *     expect(deepObj).to.have.deep.property('teas[2].tea', 'konacha');
	   *
	   * You can also use an array as the starting point of a `deep.property`
	   * assertion, or traverse nested arrays.
	   *
	   *     var arr = [
	   *         [ 'chai', 'matcha', 'konacha' ]
	   *       , [ { tea: 'chai' }
	   *         , { tea: 'matcha' }
	   *         , { tea: 'konacha' } ]
	   *     ];
	   *
	   *     expect(arr).to.have.deep.property('[0][1]', 'matcha');
	   *     expect(arr).to.have.deep.property('[1][2].tea', 'konacha');
	   *
	   * Furthermore, `property` changes the subject of the assertion
	   * to be the value of that property from the original object. This
	   * permits for further chainable assertions on that property.
	   *
	   *     expect(obj).to.have.property('foo')
	   *       .that.is.a('string');
	   *     expect(deepObj).to.have.property('green')
	   *       .that.is.an('object')
	   *       .that.deep.equals({ tea: 'matcha' });
	   *     expect(deepObj).to.have.property('teas')
	   *       .that.is.an('array')
	   *       .with.deep.property('[2]')
	   *         .that.deep.equals({ tea: 'konacha' });
	   *
	   * Note that dots and bracket in `name` must be backslash-escaped when
	   * the `deep` flag is set, while they must NOT be escaped when the `deep`
	   * flag is not set.
	   *
	   *     // simple referencing
	   *     var css = { '.link[target]': 42 };
	   *     expect(css).to.have.property('.link[target]', 42);
	   *
	   *     // deep referencing
	   *     var deepCss = { '.link': { '[target]': 42 }};
	   *     expect(deepCss).to.have.deep.property('\\.link.\\[target\\]', 42);
	   *
	   * @name property
	   * @alias deep.property
	   * @param {String} name
	   * @param {Mixed} value (optional)
	   * @param {String} message _optional_
	   * @returns value of property for chaining
	   * @api public
	   */

	  Assertion.addMethod('property', function (name, val, msg) {
	    if (msg) flag(this, 'message', msg);

	    var isDeep = !!flag(this, 'deep')
	      , descriptor = isDeep ? 'deep property ' : 'property '
	      , negate = flag(this, 'negate')
	      , obj = flag(this, 'object')
	      , pathInfo = isDeep ? _.getPathInfo(name, obj) : null
	      , hasProperty = isDeep
	        ? pathInfo.exists
	        : _.hasProperty(name, obj)
	      , value = isDeep
	        ? pathInfo.value
	        : obj[name];

	    if (negate && undefined !== val) {
	      if (undefined === value) {
	        msg = (msg != null) ? msg + ': ' : '';
	        throw new Error(msg + _.inspect(obj) + ' has no ' + descriptor + _.inspect(name));
	      }
	    } else {
	      this.assert(
	          hasProperty
	        , 'expected #{this} to have a ' + descriptor + _.inspect(name)
	        , 'expected #{this} to not have ' + descriptor + _.inspect(name));
	    }

	    if (undefined !== val) {
	      this.assert(
	          val === value
	        , 'expected #{this} to have a ' + descriptor + _.inspect(name) + ' of #{exp}, but got #{act}'
	        , 'expected #{this} to not have a ' + descriptor + _.inspect(name) + ' of #{act}'
	        , val
	        , value
	      );
	    }

	    flag(this, 'object', value);
	  });


	  /**
	   * ### .ownProperty(name)
	   *
	   * Asserts that the target has an own property `name`.
	   *
	   *     expect('test').to.have.ownProperty('length');
	   *
	   * @name ownProperty
	   * @alias haveOwnProperty
	   * @param {String} name
	   * @param {String} message _optional_
	   * @api public
	   */

	  function assertOwnProperty (name, msg) {
	    if (msg) flag(this, 'message', msg);
	    var obj = flag(this, 'object');
	    this.assert(
	        obj.hasOwnProperty(name)
	      , 'expected #{this} to have own property ' + _.inspect(name)
	      , 'expected #{this} to not have own property ' + _.inspect(name)
	    );
	  }

	  Assertion.addMethod('ownProperty', assertOwnProperty);
	  Assertion.addMethod('haveOwnProperty', assertOwnProperty);

	  /**
	   * ### .ownPropertyDescriptor(name[, descriptor[, message]])
	   *
	   * Asserts that the target has an own property descriptor `name`, that optionally matches `descriptor`.
	   *
	   *     expect('test').to.have.ownPropertyDescriptor('length');
	   *     expect('test').to.have.ownPropertyDescriptor('length', { enumerable: false, configurable: false, writable: false, value: 4 });
	   *     expect('test').not.to.have.ownPropertyDescriptor('length', { enumerable: false, configurable: false, writable: false, value: 3 });
	   *     expect('test').ownPropertyDescriptor('length').to.have.property('enumerable', false);
	   *     expect('test').ownPropertyDescriptor('length').to.have.keys('value');
	   *
	   * @name ownPropertyDescriptor
	   * @alias haveOwnPropertyDescriptor
	   * @param {String} name
	   * @param {Object} descriptor _optional_
	   * @param {String} message _optional_
	   * @api public
	   */

	  function assertOwnPropertyDescriptor (name, descriptor, msg) {
	    if (typeof descriptor === 'string') {
	      msg = descriptor;
	      descriptor = null;
	    }
	    if (msg) flag(this, 'message', msg);
	    var obj = flag(this, 'object');
	    var actualDescriptor = Object.getOwnPropertyDescriptor(Object(obj), name);
	    if (actualDescriptor && descriptor) {
	      this.assert(
	          _.eql(descriptor, actualDescriptor)
	        , 'expected the own property descriptor for ' + _.inspect(name) + ' on #{this} to match ' + _.inspect(descriptor) + ', got ' + _.inspect(actualDescriptor)
	        , 'expected the own property descriptor for ' + _.inspect(name) + ' on #{this} to not match ' + _.inspect(descriptor)
	        , descriptor
	        , actualDescriptor
	        , true
	      );
	    } else {
	      this.assert(
	          actualDescriptor
	        , 'expected #{this} to have an own property descriptor for ' + _.inspect(name)
	        , 'expected #{this} to not have an own property descriptor for ' + _.inspect(name)
	      );
	    }
	    flag(this, 'object', actualDescriptor);
	  }

	  Assertion.addMethod('ownPropertyDescriptor', assertOwnPropertyDescriptor);
	  Assertion.addMethod('haveOwnPropertyDescriptor', assertOwnPropertyDescriptor);

	  /**
	   * ### .length(value)
	   *
	   * Asserts that the target's `length` property has
	   * the expected value.
	   *
	   *     expect([ 1, 2, 3]).to.have.length(3);
	   *     expect('foobar').to.have.length(6);
	   *
	   * Can also be used as a chain precursor to a value
	   * comparison for the length property.
	   *
	   *     expect('foo').to.have.length.above(2);
	   *     expect([ 1, 2, 3 ]).to.have.length.above(2);
	   *     expect('foo').to.have.length.below(4);
	   *     expect([ 1, 2, 3 ]).to.have.length.below(4);
	   *     expect('foo').to.have.length.within(2,4);
	   *     expect([ 1, 2, 3 ]).to.have.length.within(2,4);
	   *
	   * @name length
	   * @alias lengthOf
	   * @param {Number} length
	   * @param {String} message _optional_
	   * @api public
	   */

	  function assertLengthChain () {
	    flag(this, 'doLength', true);
	  }

	  function assertLength (n, msg) {
	    if (msg) flag(this, 'message', msg);
	    var obj = flag(this, 'object');
	    new Assertion(obj, msg).to.have.property('length');
	    var len = obj.length;

	    this.assert(
	        len == n
	      , 'expected #{this} to have a length of #{exp} but got #{act}'
	      , 'expected #{this} to not have a length of #{act}'
	      , n
	      , len
	    );
	  }

	  Assertion.addChainableMethod('length', assertLength, assertLengthChain);
	  Assertion.addMethod('lengthOf', assertLength);

	  /**
	   * ### .match(regexp)
	   *
	   * Asserts that the target matches a regular expression.
	   *
	   *     expect('foobar').to.match(/^foo/);
	   *
	   * @name match
	   * @param {RegExp} RegularExpression
	   * @param {String} message _optional_
	   * @api public
	   */

	  Assertion.addMethod('match', function (re, msg) {
	    if (msg) flag(this, 'message', msg);
	    var obj = flag(this, 'object');
	    this.assert(
	        re.exec(obj)
	      , 'expected #{this} to match ' + re
	      , 'expected #{this} not to match ' + re
	    );
	  });

	  /**
	   * ### .string(string)
	   *
	   * Asserts that the string target contains another string.
	   *
	   *     expect('foobar').to.have.string('bar');
	   *
	   * @name string
	   * @param {String} string
	   * @param {String} message _optional_
	   * @api public
	   */

	  Assertion.addMethod('string', function (str, msg) {
	    if (msg) flag(this, 'message', msg);
	    var obj = flag(this, 'object');
	    new Assertion(obj, msg).is.a('string');

	    this.assert(
	        ~obj.indexOf(str)
	      , 'expected #{this} to contain ' + _.inspect(str)
	      , 'expected #{this} to not contain ' + _.inspect(str)
	    );
	  });


	  /**
	   * ### .keys(key1, [key2], [...])
	   *
	   * Asserts that the target contains any or all of the passed-in keys.
	   * Use in combination with `any`, `all`, `contains`, or `have` will affect
	   * what will pass.
	   *
	   * When used in conjunction with `any`, at least one key that is passed
	   * in must exist in the target object. This is regardless whether or not
	   * the `have` or `contain` qualifiers are used. Note, either `any` or `all`
	   * should be used in the assertion. If neither are used, the assertion is
	   * defaulted to `all`.
	   *
	   * When both `all` and `contain` are used, the target object must have at
	   * least all of the passed-in keys but may have more keys not listed.
	   *
	   * When both `all` and `have` are used, the target object must both contain
	   * all of the passed-in keys AND the number of keys in the target object must
	   * match the number of keys passed in (in other words, a target object must
	   * have all and only all of the passed-in keys).
	   *
	   *     expect({ foo: 1, bar: 2 }).to.have.any.keys('foo', 'baz');
	   *     expect({ foo: 1, bar: 2 }).to.have.any.keys('foo');
	   *     expect({ foo: 1, bar: 2 }).to.contain.any.keys('bar', 'baz');
	   *     expect({ foo: 1, bar: 2 }).to.contain.any.keys(['foo']);
	   *     expect({ foo: 1, bar: 2 }).to.contain.any.keys({'foo': 6});
	   *     expect({ foo: 1, bar: 2 }).to.have.all.keys(['bar', 'foo']);
	   *     expect({ foo: 1, bar: 2 }).to.have.all.keys({'bar': 6, 'foo': 7});
	   *     expect({ foo: 1, bar: 2, baz: 3 }).to.contain.all.keys(['bar', 'foo']);
	   *     expect({ foo: 1, bar: 2, baz: 3 }).to.contain.all.keys([{'bar': 6}}]);
	   *
	   *
	   * @name keys
	   * @alias key
	   * @param {String...|Array|Object} keys
	   * @api public
	   */

	  function assertKeys (keys) {
	    var obj = flag(this, 'object')
	      , str
	      , ok = true
	      , mixedArgsMsg = 'keys must be given single argument of Array|Object|String, or multiple String arguments';

	    switch (_.type(keys)) {
	      case "array":
	        if (arguments.length > 1) throw (new Error(mixedArgsMsg));
	        break;
	      case "object":
	        if (arguments.length > 1) throw (new Error(mixedArgsMsg));
	        keys = Object.keys(keys);
	        break;
	      default:
	        keys = Array.prototype.slice.call(arguments);
	    }

	    if (!keys.length) throw new Error('keys required');

	    var actual = Object.keys(obj)
	      , expected = keys
	      , len = keys.length
	      , any = flag(this, 'any')
	      , all = flag(this, 'all');

	    if (!any && !all) {
	      all = true;
	    }

	    // Has any
	    if (any) {
	      var intersection = expected.filter(function(key) {
	        return ~actual.indexOf(key);
	      });
	      ok = intersection.length > 0;
	    }

	    // Has all
	    if (all) {
	      ok = keys.every(function(key){
	        return ~actual.indexOf(key);
	      });
	      if (!flag(this, 'negate') && !flag(this, 'contains')) {
	        ok = ok && keys.length == actual.length;
	      }
	    }

	    // Key string
	    if (len > 1) {
	      keys = keys.map(function(key){
	        return _.inspect(key);
	      });
	      var last = keys.pop();
	      if (all) {
	        str = keys.join(', ') + ', and ' + last;
	      }
	      if (any) {
	        str = keys.join(', ') + ', or ' + last;
	      }
	    } else {
	      str = _.inspect(keys[0]);
	    }

	    // Form
	    str = (len > 1 ? 'keys ' : 'key ') + str;

	    // Have / include
	    str = (flag(this, 'contains') ? 'contain ' : 'have ') + str;

	    // Assertion
	    this.assert(
	        ok
	      , 'expected #{this} to ' + str
	      , 'expected #{this} to not ' + str
	      , expected.slice(0).sort()
	      , actual.sort()
	      , true
	    );
	  }

	  Assertion.addMethod('keys', assertKeys);
	  Assertion.addMethod('key', assertKeys);

	  /**
	   * ### .throw(constructor)
	   *
	   * Asserts that the function target will throw a specific error, or specific type of error
	   * (as determined using `instanceof`), optionally with a RegExp or string inclusion test
	   * for the error's message.
	   *
	   *     var err = new ReferenceError('This is a bad function.');
	   *     var fn = function () { throw err; }
	   *     expect(fn).to.throw(ReferenceError);
	   *     expect(fn).to.throw(Error);
	   *     expect(fn).to.throw(/bad function/);
	   *     expect(fn).to.not.throw('good function');
	   *     expect(fn).to.throw(ReferenceError, /bad function/);
	   *     expect(fn).to.throw(err);
	   *     expect(fn).to.not.throw(new RangeError('Out of range.'));
	   *
	   * Please note that when a throw expectation is negated, it will check each
	   * parameter independently, starting with error constructor type. The appropriate way
	   * to check for the existence of a type of error but for a message that does not match
	   * is to use `and`.
	   *
	   *     expect(fn).to.throw(ReferenceError)
	   *        .and.not.throw(/good function/);
	   *
	   * @name throw
	   * @alias throws
	   * @alias Throw
	   * @param {ErrorConstructor} constructor
	   * @param {String|RegExp} expected error message
	   * @param {String} message _optional_
	   * @see https://developer.mozilla.org/en/JavaScript/Reference/Global_Objects/Error#Error_types
	   * @returns error for chaining (null if no error)
	   * @api public
	   */

	  function assertThrows (constructor, errMsg, msg) {
	    if (msg) flag(this, 'message', msg);
	    var obj = flag(this, 'object');
	    new Assertion(obj, msg).is.a('function');

	    var thrown = false
	      , desiredError = null
	      , name = null
	      , thrownError = null;

	    if (arguments.length === 0) {
	      errMsg = null;
	      constructor = null;
	    } else if (constructor && (constructor instanceof RegExp || 'string' === typeof constructor)) {
	      errMsg = constructor;
	      constructor = null;
	    } else if (constructor && constructor instanceof Error) {
	      desiredError = constructor;
	      constructor = null;
	      errMsg = null;
	    } else if (typeof constructor === 'function') {
	      name = constructor.prototype.name || constructor.name;
	      if (name === 'Error' && constructor !== Error) {
	        name = (new constructor()).name;
	      }
	    } else {
	      constructor = null;
	    }

	    try {
	      obj();
	    } catch (err) {
	      // first, check desired error
	      if (desiredError) {
	        this.assert(
	            err === desiredError
	          , 'expected #{this} to throw #{exp} but #{act} was thrown'
	          , 'expected #{this} to not throw #{exp}'
	          , (desiredError instanceof Error ? desiredError.toString() : desiredError)
	          , (err instanceof Error ? err.toString() : err)
	        );

	        flag(this, 'object', err);
	        return this;
	      }

	      // next, check constructor
	      if (constructor) {
	        this.assert(
	            err instanceof constructor
	          , 'expected #{this} to throw #{exp} but #{act} was thrown'
	          , 'expected #{this} to not throw #{exp} but #{act} was thrown'
	          , name
	          , (err instanceof Error ? err.toString() : err)
	        );

	        if (!errMsg) {
	          flag(this, 'object', err);
	          return this;
	        }
	      }

	      // next, check message
	      var message = 'object' === _.type(err) && "message" in err
	        ? err.message
	        : '' + err;

	      if ((message != null) && errMsg && errMsg instanceof RegExp) {
	        this.assert(
	            errMsg.exec(message)
	          , 'expected #{this} to throw error matching #{exp} but got #{act}'
	          , 'expected #{this} to throw error not matching #{exp}'
	          , errMsg
	          , message
	        );

	        flag(this, 'object', err);
	        return this;
	      } else if ((message != null) && errMsg && 'string' === typeof errMsg) {
	        this.assert(
	            ~message.indexOf(errMsg)
	          , 'expected #{this} to throw error including #{exp} but got #{act}'
	          , 'expected #{this} to throw error not including #{act}'
	          , errMsg
	          , message
	        );

	        flag(this, 'object', err);
	        return this;
	      } else {
	        thrown = true;
	        thrownError = err;
	      }
	    }

	    var actuallyGot = ''
	      , expectedThrown = name !== null
	        ? name
	        : desiredError
	          ? '#{exp}' //_.inspect(desiredError)
	          : 'an error';

	    if (thrown) {
	      actuallyGot = ' but #{act} was thrown'
	    }

	    this.assert(
	        thrown === true
	      , 'expected #{this} to throw ' + expectedThrown + actuallyGot
	      , 'expected #{this} to not throw ' + expectedThrown + actuallyGot
	      , (desiredError instanceof Error ? desiredError.toString() : desiredError)
	      , (thrownError instanceof Error ? thrownError.toString() : thrownError)
	    );

	    flag(this, 'object', thrownError);
	  };

	  Assertion.addMethod('throw', assertThrows);
	  Assertion.addMethod('throws', assertThrows);
	  Assertion.addMethod('Throw', assertThrows);

	  /**
	   * ### .respondTo(method)
	   *
	   * Asserts that the object or class target will respond to a method.
	   *
	   *     Klass.prototype.bar = function(){};
	   *     expect(Klass).to.respondTo('bar');
	   *     expect(obj).to.respondTo('bar');
	   *
	   * To check if a constructor will respond to a static function,
	   * set the `itself` flag.
	   *
	   *     Klass.baz = function(){};
	   *     expect(Klass).itself.to.respondTo('baz');
	   *
	   * @name respondTo
	   * @param {String} method
	   * @param {String} message _optional_
	   * @api public
	   */

	  Assertion.addMethod('respondTo', function (method, msg) {
	    if (msg) flag(this, 'message', msg);
	    var obj = flag(this, 'object')
	      , itself = flag(this, 'itself')
	      , context = ('function' === _.type(obj) && !itself)
	        ? obj.prototype[method]
	        : obj[method];

	    this.assert(
	        'function' === typeof context
	      , 'expected #{this} to respond to ' + _.inspect(method)
	      , 'expected #{this} to not respond to ' + _.inspect(method)
	    );
	  });

	  /**
	   * ### .itself
	   *
	   * Sets the `itself` flag, later used by the `respondTo` assertion.
	   *
	   *     function Foo() {}
	   *     Foo.bar = function() {}
	   *     Foo.prototype.baz = function() {}
	   *
	   *     expect(Foo).itself.to.respondTo('bar');
	   *     expect(Foo).itself.not.to.respondTo('baz');
	   *
	   * @name itself
	   * @api public
	   */

	  Assertion.addProperty('itself', function () {
	    flag(this, 'itself', true);
	  });

	  /**
	   * ### .satisfy(method)
	   *
	   * Asserts that the target passes a given truth test.
	   *
	   *     expect(1).to.satisfy(function(num) { return num > 0; });
	   *
	   * @name satisfy
	   * @param {Function} matcher
	   * @param {String} message _optional_
	   * @api public
	   */

	  Assertion.addMethod('satisfy', function (matcher, msg) {
	    if (msg) flag(this, 'message', msg);
	    var obj = flag(this, 'object');
	    var result = matcher(obj);
	    this.assert(
	        result
	      , 'expected #{this} to satisfy ' + _.objDisplay(matcher)
	      , 'expected #{this} to not satisfy' + _.objDisplay(matcher)
	      , this.negate ? false : true
	      , result
	    );
	  });

	  /**
	   * ### .closeTo(expected, delta)
	   *
	   * Asserts that the target is equal `expected`, to within a +/- `delta` range.
	   *
	   *     expect(1.5).to.be.closeTo(1, 0.5);
	   *
	   * @name closeTo
	   * @param {Number} expected
	   * @param {Number} delta
	   * @param {String} message _optional_
	   * @api public
	   */

	  Assertion.addMethod('closeTo', function (expected, delta, msg) {
	    if (msg) flag(this, 'message', msg);
	    var obj = flag(this, 'object');

	    new Assertion(obj, msg).is.a('number');
	    if (_.type(expected) !== 'number' || _.type(delta) !== 'number') {
	      throw new Error('the arguments to closeTo must be numbers');
	    }

	    this.assert(
	        Math.abs(obj - expected) <= delta
	      , 'expected #{this} to be close to ' + expected + ' +/- ' + delta
	      , 'expected #{this} not to be close to ' + expected + ' +/- ' + delta
	    );
	  });

	  function isSubsetOf(subset, superset, cmp) {
	    return subset.every(function(elem) {
	      if (!cmp) return superset.indexOf(elem) !== -1;

	      return superset.some(function(elem2) {
	        return cmp(elem, elem2);
	      });
	    })
	  }

	  /**
	   * ### .members(set)
	   *
	   * Asserts that the target is a superset of `set`,
	   * or that the target and `set` have the same strictly-equal (===) members.
	   * Alternately, if the `deep` flag is set, set members are compared for deep
	   * equality.
	   *
	   *     expect([1, 2, 3]).to.include.members([3, 2]);
	   *     expect([1, 2, 3]).to.not.include.members([3, 2, 8]);
	   *
	   *     expect([4, 2]).to.have.members([2, 4]);
	   *     expect([5, 2]).to.not.have.members([5, 2, 1]);
	   *
	   *     expect([{ id: 1 }]).to.deep.include.members([{ id: 1 }]);
	   *
	   * @name members
	   * @param {Array} set
	   * @param {String} message _optional_
	   * @api public
	   */

	  Assertion.addMethod('members', function (subset, msg) {
	    if (msg) flag(this, 'message', msg);
	    var obj = flag(this, 'object');

	    new Assertion(obj).to.be.an('array');
	    new Assertion(subset).to.be.an('array');

	    var cmp = flag(this, 'deep') ? _.eql : undefined;

	    if (flag(this, 'contains')) {
	      return this.assert(
	          isSubsetOf(subset, obj, cmp)
	        , 'expected #{this} to be a superset of #{act}'
	        , 'expected #{this} to not be a superset of #{act}'
	        , obj
	        , subset
	      );
	    }

	    this.assert(
	        isSubsetOf(obj, subset, cmp) && isSubsetOf(subset, obj, cmp)
	        , 'expected #{this} to have the same members as #{act}'
	        , 'expected #{this} to not have the same members as #{act}'
	        , obj
	        , subset
	    );
	  });

	  /**
	   * ### .change(function)
	   *
	   * Asserts that a function changes an object property
	   *
	   *     var obj = { val: 10 };
	   *     var fn = function() { obj.val += 3 };
	   *     var noChangeFn = function() { return 'foo' + 'bar'; }
	   *     expect(fn).to.change(obj, 'val');
	   *     expect(noChangFn).to.not.change(obj, 'val')
	   *
	   * @name change
	   * @alias changes
	   * @alias Change
	   * @param {String} object
	   * @param {String} property name
	   * @param {String} message _optional_
	   * @api public
	   */

	  function assertChanges (object, prop, msg) {
	    if (msg) flag(this, 'message', msg);
	    var fn = flag(this, 'object');
	    new Assertion(object, msg).to.have.property(prop);
	    new Assertion(fn).is.a('function');

	    var initial = object[prop];
	    fn();

	    this.assert(
	      initial !== object[prop]
	      , 'expected .' + prop + ' to change'
	      , 'expected .' + prop + ' to not change'
	    );
	  }

	  Assertion.addChainableMethod('change', assertChanges);
	  Assertion.addChainableMethod('changes', assertChanges);

	  /**
	   * ### .increase(function)
	   *
	   * Asserts that a function increases an object property
	   *
	   *     var obj = { val: 10 };
	   *     var fn = function() { obj.val = 15 };
	   *     expect(fn).to.increase(obj, 'val');
	   *
	   * @name increase
	   * @alias increases
	   * @alias Increase
	   * @param {String} object
	   * @param {String} property name
	   * @param {String} message _optional_
	   * @api public
	   */

	  function assertIncreases (object, prop, msg) {
	    if (msg) flag(this, 'message', msg);
	    var fn = flag(this, 'object');
	    new Assertion(object, msg).to.have.property(prop);
	    new Assertion(fn).is.a('function');

	    var initial = object[prop];
	    fn();

	    this.assert(
	      object[prop] - initial > 0
	      , 'expected .' + prop + ' to increase'
	      , 'expected .' + prop + ' to not increase'
	    );
	  }

	  Assertion.addChainableMethod('increase', assertIncreases);
	  Assertion.addChainableMethod('increases', assertIncreases);

	  /**
	   * ### .decrease(function)
	   *
	   * Asserts that a function decreases an object property
	   *
	   *     var obj = { val: 10 };
	   *     var fn = function() { obj.val = 5 };
	   *     expect(fn).to.decrease(obj, 'val');
	   *
	   * @name decrease
	   * @alias decreases
	   * @alias Decrease
	   * @param {String} object
	   * @param {String} property name
	   * @param {String} message _optional_
	   * @api public
	   */

	  function assertDecreases (object, prop, msg) {
	    if (msg) flag(this, 'message', msg);
	    var fn = flag(this, 'object');
	    new Assertion(object, msg).to.have.property(prop);
	    new Assertion(fn).is.a('function');

	    var initial = object[prop];
	    fn();

	    this.assert(
	      object[prop] - initial < 0
	      , 'expected .' + prop + ' to decrease'
	      , 'expected .' + prop + ' to not decrease'
	    );
	  }

	  Assertion.addChainableMethod('decrease', assertDecreases);
	  Assertion.addChainableMethod('decreases', assertDecreases);

	};


/***/ },
/* 12 */
/***/ function(module, exports) {

	/*!
	 * assertion-error
	 * Copyright(c) 2013 Jake Luer <jake@qualiancy.com>
	 * MIT Licensed
	 */

	/*!
	 * Return a function that will copy properties from
	 * one object to another excluding any originally
	 * listed. Returned function will create a new `{}`.
	 *
	 * @param {String} excluded properties ...
	 * @return {Function}
	 */

	function exclude () {
	  var excludes = [].slice.call(arguments);

	  function excludeProps (res, obj) {
	    Object.keys(obj).forEach(function (key) {
	      if (!~excludes.indexOf(key)) res[key] = obj[key];
	    });
	  }

	  return function extendExclude () {
	    var args = [].slice.call(arguments)
	      , i = 0
	      , res = {};

	    for (; i < args.length; i++) {
	      excludeProps(res, args[i]);
	    }

	    return res;
	  };
	};

	/*!
	 * Primary Exports
	 */

	module.exports = AssertionError;

	/**
	 * ### AssertionError
	 *
	 * An extension of the JavaScript `Error` constructor for
	 * assertion and validation scenarios.
	 *
	 * @param {String} message
	 * @param {Object} properties to include (optional)
	 * @param {callee} start stack function (optional)
	 */

	function AssertionError (message, _props, ssf) {
	  var extend = exclude('name', 'message', 'stack', 'constructor', 'toJSON')
	    , props = extend(_props || {});

	  // default values
	  this.message = message || 'Unspecified AssertionError';
	  this.showDiff = false;

	  // copy from properties
	  for (var key in props) {
	    this[key] = props[key];
	  }

	  // capture stack trace
	  ssf = ssf || arguments.callee;
	  if (ssf && Error.captureStackTrace) {
	    Error.captureStackTrace(this, ssf);
	  }
	}

	/*!
	 * Inherit from Error.prototype
	 */

	AssertionError.prototype = Object.create(Error.prototype);

	/*!
	 * Statically set name
	 */

	AssertionError.prototype.name = 'AssertionError';

	/*!
	 * Ensure correct constructor
	 */

	AssertionError.prototype.constructor = AssertionError;

	/**
	 * Allow errors to be converted to JSON for static transfer.
	 *
	 * @param {Boolean} include stack (default: `true`)
	 * @return {Object} object that can be `JSON.stringify`
	 */

	AssertionError.prototype.toJSON = function (stack) {
	  var extend = exclude('constructor', 'toJSON', 'stack')
	    , props = extend({ name: this.name }, this);

	  // include stack if exists and not turned off
	  if (false !== stack && this.stack) {
	    props.stack = this.stack;
	  }

	  return props;
	};


/***/ },
/* 13 */
/***/ function(module, exports, __webpack_require__) {

	/*!
	 * chai
	 * Copyright(c) 2011 Jake Luer <jake@alogicalparadox.com>
	 * MIT Licensed
	 */

	/*!
	 * Main exports
	 */

	var exports = module.exports = {};

	/*!
	 * test utility
	 */

	exports.test = __webpack_require__(14);

	/*!
	 * type utility
	 */

	exports.type = __webpack_require__(16);

	/*!
	 * message utility
	 */

	exports.getMessage = __webpack_require__(17);

	/*!
	 * actual utility
	 */

	exports.getActual = __webpack_require__(18);

	/*!
	 * Inspect util
	 */

	exports.inspect = __webpack_require__(19);

	/*!
	 * Object Display util
	 */

	exports.objDisplay = __webpack_require__(23);

	/*!
	 * Flag utility
	 */

	exports.flag = __webpack_require__(15);

	/*!
	 * Flag transferring utility
	 */

	exports.transferFlags = __webpack_require__(25);

	/*!
	 * Deep equal utility
	 */

	exports.eql = __webpack_require__(26);

	/*!
	 * Deep path value
	 */

	exports.getPathValue = __webpack_require__(34);

	/*!
	 * Deep path info
	 */

	exports.getPathInfo = __webpack_require__(35);

	/*!
	 * Check if a property exists
	 */

	exports.hasProperty = __webpack_require__(36);

	/*!
	 * Function name
	 */

	exports.getName = __webpack_require__(20);

	/*!
	 * add Property
	 */

	exports.addProperty = __webpack_require__(37);

	/*!
	 * add Method
	 */

	exports.addMethod = __webpack_require__(38);

	/*!
	 * overwrite Property
	 */

	exports.overwriteProperty = __webpack_require__(39);

	/*!
	 * overwrite Method
	 */

	exports.overwriteMethod = __webpack_require__(40);

	/*!
	 * Add a chainable method
	 */

	exports.addChainableMethod = __webpack_require__(41);

	/*!
	 * Overwrite chainable method
	 */

	exports.overwriteChainableMethod = __webpack_require__(42);



/***/ },
/* 14 */
/***/ function(module, exports, __webpack_require__) {

	/*!
	 * Chai - test utility
	 * Copyright(c) 2012-2014 Jake Luer <jake@alogicalparadox.com>
	 * MIT Licensed
	 */

	/*!
	 * Module dependancies
	 */

	var flag = __webpack_require__(15);

	/**
	 * # test(object, expression)
	 *
	 * Test and object for expression.
	 *
	 * @param {Object} object (constructed Assertion)
	 * @param {Arguments} chai.Assertion.prototype.assert arguments
	 */

	module.exports = function (obj, args) {
	  var negate = flag(obj, 'negate')
	    , expr = args[0];
	  return negate ? !expr : expr;
	};


/***/ },
/* 15 */
/***/ function(module, exports) {

	/*!
	 * Chai - flag utility
	 * Copyright(c) 2012-2014 Jake Luer <jake@alogicalparadox.com>
	 * MIT Licensed
	 */

	/**
	 * ### flag(object, key, [value])
	 *
	 * Get or set a flag value on an object. If a
	 * value is provided it will be set, else it will
	 * return the currently set value or `undefined` if
	 * the value is not set.
	 *
	 *     utils.flag(this, 'foo', 'bar'); // setter
	 *     utils.flag(this, 'foo'); // getter, returns `bar`
	 *
	 * @param {Object} object constructed Assertion
	 * @param {String} key
	 * @param {Mixed} value (optional)
	 * @name flag
	 * @api private
	 */

	module.exports = function (obj, key, value) {
	  var flags = obj.__flags || (obj.__flags = Object.create(null));
	  if (arguments.length === 3) {
	    flags[key] = value;
	  } else {
	    return flags[key];
	  }
	};


/***/ },
/* 16 */
/***/ function(module, exports) {

	/*!
	 * Chai - type utility
	 * Copyright(c) 2012-2014 Jake Luer <jake@alogicalparadox.com>
	 * MIT Licensed
	 */

	/*!
	 * Detectable javascript natives
	 */

	var natives = {
	    '[object Arguments]': 'arguments'
	  , '[object Array]': 'array'
	  , '[object Date]': 'date'
	  , '[object Function]': 'function'
	  , '[object Number]': 'number'
	  , '[object RegExp]': 'regexp'
	  , '[object String]': 'string'
	};

	/**
	 * ### type(object)
	 *
	 * Better implementation of `typeof` detection that can
	 * be used cross-browser. Handles the inconsistencies of
	 * Array, `null`, and `undefined` detection.
	 *
	 *     utils.type({}) // 'object'
	 *     utils.type(null) // `null'
	 *     utils.type(undefined) // `undefined`
	 *     utils.type([]) // `array`
	 *
	 * @param {Mixed} object to detect type of
	 * @name type
	 * @api private
	 */

	module.exports = function (obj) {
	  var str = Object.prototype.toString.call(obj);
	  if (natives[str]) return natives[str];
	  if (obj === null) return 'null';
	  if (obj === undefined) return 'undefined';
	  if (obj === Object(obj)) return 'object';
	  return typeof obj;
	};


/***/ },
/* 17 */
/***/ function(module, exports, __webpack_require__) {

	/*!
	 * Chai - message composition utility
	 * Copyright(c) 2012-2014 Jake Luer <jake@alogicalparadox.com>
	 * MIT Licensed
	 */

	/*!
	 * Module dependancies
	 */

	var flag = __webpack_require__(15)
	  , getActual = __webpack_require__(18)
	  , inspect = __webpack_require__(19)
	  , objDisplay = __webpack_require__(23);

	/**
	 * ### .getMessage(object, message, negateMessage)
	 *
	 * Construct the error message based on flags
	 * and template tags. Template tags will return
	 * a stringified inspection of the object referenced.
	 *
	 * Message template tags:
	 * - `#{this}` current asserted object
	 * - `#{act}` actual value
	 * - `#{exp}` expected value
	 *
	 * @param {Object} object (constructed Assertion)
	 * @param {Arguments} chai.Assertion.prototype.assert arguments
	 * @name getMessage
	 * @api public
	 */

	module.exports = function (obj, args) {
	  var negate = flag(obj, 'negate')
	    , val = flag(obj, 'object')
	    , expected = args[3]
	    , actual = getActual(obj, args)
	    , msg = negate ? args[2] : args[1]
	    , flagMsg = flag(obj, 'message');

	  if(typeof msg === "function") msg = msg();
	  msg = msg || '';
	  msg = msg
	    .replace(/#{this}/g, objDisplay(val))
	    .replace(/#{act}/g, objDisplay(actual))
	    .replace(/#{exp}/g, objDisplay(expected));

	  return flagMsg ? flagMsg + ': ' + msg : msg;
	};


/***/ },
/* 18 */
/***/ function(module, exports) {

	/*!
	 * Chai - getActual utility
	 * Copyright(c) 2012-2014 Jake Luer <jake@alogicalparadox.com>
	 * MIT Licensed
	 */

	/**
	 * # getActual(object, [actual])
	 *
	 * Returns the `actual` value for an Assertion
	 *
	 * @param {Object} object (constructed Assertion)
	 * @param {Arguments} chai.Assertion.prototype.assert arguments
	 */

	module.exports = function (obj, args) {
	  return args.length > 4 ? args[4] : obj._obj;
	};


/***/ },
/* 19 */
/***/ function(module, exports, __webpack_require__) {

	// This is (almost) directly from Node.js utils
	// https://github.com/joyent/node/blob/f8c335d0caf47f16d31413f89aa28eda3878e3aa/lib/util.js

	var getName = __webpack_require__(20);
	var getProperties = __webpack_require__(21);
	var getEnumerableProperties = __webpack_require__(22);

	module.exports = inspect;

	/**
	 * Echos the value of a value. Trys to print the value out
	 * in the best way possible given the different types.
	 *
	 * @param {Object} obj The object to print out.
	 * @param {Boolean} showHidden Flag that shows hidden (not enumerable)
	 *    properties of objects.
	 * @param {Number} depth Depth in which to descend in object. Default is 2.
	 * @param {Boolean} colors Flag to turn on ANSI escape codes to color the
	 *    output. Default is false (no coloring).
	 */
	function inspect(obj, showHidden, depth, colors) {
	  var ctx = {
	    showHidden: showHidden,
	    seen: [],
	    stylize: function (str) { return str; }
	  };
	  return formatValue(ctx, obj, (typeof depth === 'undefined' ? 2 : depth));
	}

	// Returns true if object is a DOM element.
	var isDOMElement = function (object) {
	  if (typeof HTMLElement === 'object') {
	    return object instanceof HTMLElement;
	  } else {
	    return object &&
	      typeof object === 'object' &&
	      object.nodeType === 1 &&
	      typeof object.nodeName === 'string';
	  }
	};

	function formatValue(ctx, value, recurseTimes) {
	  // Provide a hook for user-specified inspect functions.
	  // Check that value is an object with an inspect function on it
	  if (value && typeof value.inspect === 'function' &&
	      // Filter out the util module, it's inspect function is special
	      value.inspect !== exports.inspect &&
	      // Also filter out any prototype objects using the circular check.
	      !(value.constructor && value.constructor.prototype === value)) {
	    var ret = value.inspect(recurseTimes);
	    if (typeof ret !== 'string') {
	      ret = formatValue(ctx, ret, recurseTimes);
	    }
	    return ret;
	  }

	  // Primitive types cannot have properties
	  var primitive = formatPrimitive(ctx, value);
	  if (primitive) {
	    return primitive;
	  }

	  // If this is a DOM element, try to get the outer HTML.
	  if (isDOMElement(value)) {
	    if ('outerHTML' in value) {
	      return value.outerHTML;
	      // This value does not have an outerHTML attribute,
	      //   it could still be an XML element
	    } else {
	      // Attempt to serialize it
	      try {
	        if (document.xmlVersion) {
	          var xmlSerializer = new XMLSerializer();
	          return xmlSerializer.serializeToString(value);
	        } else {
	          // Firefox 11- do not support outerHTML
	          //   It does, however, support innerHTML
	          //   Use the following to render the element
	          var ns = "http://www.w3.org/1999/xhtml";
	          var container = document.createElementNS(ns, '_');

	          container.appendChild(value.cloneNode(false));
	          html = container.innerHTML
	            .replace('><', '>' + value.innerHTML + '<');
	          container.innerHTML = '';
	          return html;
	        }
	      } catch (err) {
	        // This could be a non-native DOM implementation,
	        //   continue with the normal flow:
	        //   printing the element as if it is an object.
	      }
	    }
	  }

	  // Look up the keys of the object.
	  var visibleKeys = getEnumerableProperties(value);
	  var keys = ctx.showHidden ? getProperties(value) : visibleKeys;

	  // Some type of object without properties can be shortcutted.
	  // In IE, errors have a single `stack` property, or if they are vanilla `Error`,
	  // a `stack` plus `description` property; ignore those for consistency.
	  if (keys.length === 0 || (isError(value) && (
	      (keys.length === 1 && keys[0] === 'stack') ||
	      (keys.length === 2 && keys[0] === 'description' && keys[1] === 'stack')
	     ))) {
	    if (typeof value === 'function') {
	      var name = getName(value);
	      var nameSuffix = name ? ': ' + name : '';
	      return ctx.stylize('[Function' + nameSuffix + ']', 'special');
	    }
	    if (isRegExp(value)) {
	      return ctx.stylize(RegExp.prototype.toString.call(value), 'regexp');
	    }
	    if (isDate(value)) {
	      return ctx.stylize(Date.prototype.toUTCString.call(value), 'date');
	    }
	    if (isError(value)) {
	      return formatError(value);
	    }
	  }

	  var base = '', array = false, braces = ['{', '}'];

	  // Make Array say that they are Array
	  if (isArray(value)) {
	    array = true;
	    braces = ['[', ']'];
	  }

	  // Make functions say that they are functions
	  if (typeof value === 'function') {
	    var name = getName(value);
	    var nameSuffix = name ? ': ' + name : '';
	    base = ' [Function' + nameSuffix + ']';
	  }

	  // Make RegExps say that they are RegExps
	  if (isRegExp(value)) {
	    base = ' ' + RegExp.prototype.toString.call(value);
	  }

	  // Make dates with properties first say the date
	  if (isDate(value)) {
	    base = ' ' + Date.prototype.toUTCString.call(value);
	  }

	  // Make error with message first say the error
	  if (isError(value)) {
	    return formatError(value);
	  }

	  if (keys.length === 0 && (!array || value.length == 0)) {
	    return braces[0] + base + braces[1];
	  }

	  if (recurseTimes < 0) {
	    if (isRegExp(value)) {
	      return ctx.stylize(RegExp.prototype.toString.call(value), 'regexp');
	    } else {
	      return ctx.stylize('[Object]', 'special');
	    }
	  }

	  ctx.seen.push(value);

	  var output;
	  if (array) {
	    output = formatArray(ctx, value, recurseTimes, visibleKeys, keys);
	  } else {
	    output = keys.map(function(key) {
	      return formatProperty(ctx, value, recurseTimes, visibleKeys, key, array);
	    });
	  }

	  ctx.seen.pop();

	  return reduceToSingleString(output, base, braces);
	}


	function formatPrimitive(ctx, value) {
	  switch (typeof value) {
	    case 'undefined':
	      return ctx.stylize('undefined', 'undefined');

	    case 'string':
	      var simple = '\'' + JSON.stringify(value).replace(/^"|"$/g, '')
	                                               .replace(/'/g, "\\'")
	                                               .replace(/\\"/g, '"') + '\'';
	      return ctx.stylize(simple, 'string');

	    case 'number':
	      if (value === 0 && (1/value) === -Infinity) {
	        return ctx.stylize('-0', 'number');
	      }
	      return ctx.stylize('' + value, 'number');

	    case 'boolean':
	      return ctx.stylize('' + value, 'boolean');
	  }
	  // For some reason typeof null is "object", so special case here.
	  if (value === null) {
	    return ctx.stylize('null', 'null');
	  }
	}


	function formatError(value) {
	  return '[' + Error.prototype.toString.call(value) + ']';
	}


	function formatArray(ctx, value, recurseTimes, visibleKeys, keys) {
	  var output = [];
	  for (var i = 0, l = value.length; i < l; ++i) {
	    if (Object.prototype.hasOwnProperty.call(value, String(i))) {
	      output.push(formatProperty(ctx, value, recurseTimes, visibleKeys,
	          String(i), true));
	    } else {
	      output.push('');
	    }
	  }
	  keys.forEach(function(key) {
	    if (!key.match(/^\d+$/)) {
	      output.push(formatProperty(ctx, value, recurseTimes, visibleKeys,
	          key, true));
	    }
	  });
	  return output;
	}


	function formatProperty(ctx, value, recurseTimes, visibleKeys, key, array) {
	  var name, str;
	  if (value.__lookupGetter__) {
	    if (value.__lookupGetter__(key)) {
	      if (value.__lookupSetter__(key)) {
	        str = ctx.stylize('[Getter/Setter]', 'special');
	      } else {
	        str = ctx.stylize('[Getter]', 'special');
	      }
	    } else {
	      if (value.__lookupSetter__(key)) {
	        str = ctx.stylize('[Setter]', 'special');
	      }
	    }
	  }
	  if (visibleKeys.indexOf(key) < 0) {
	    name = '[' + key + ']';
	  }
	  if (!str) {
	    if (ctx.seen.indexOf(value[key]) < 0) {
	      if (recurseTimes === null) {
	        str = formatValue(ctx, value[key], null);
	      } else {
	        str = formatValue(ctx, value[key], recurseTimes - 1);
	      }
	      if (str.indexOf('\n') > -1) {
	        if (array) {
	          str = str.split('\n').map(function(line) {
	            return '  ' + line;
	          }).join('\n').substr(2);
	        } else {
	          str = '\n' + str.split('\n').map(function(line) {
	            return '   ' + line;
	          }).join('\n');
	        }
	      }
	    } else {
	      str = ctx.stylize('[Circular]', 'special');
	    }
	  }
	  if (typeof name === 'undefined') {
	    if (array && key.match(/^\d+$/)) {
	      return str;
	    }
	    name = JSON.stringify('' + key);
	    if (name.match(/^"([a-zA-Z_][a-zA-Z_0-9]*)"$/)) {
	      name = name.substr(1, name.length - 2);
	      name = ctx.stylize(name, 'name');
	    } else {
	      name = name.replace(/'/g, "\\'")
	                 .replace(/\\"/g, '"')
	                 .replace(/(^"|"$)/g, "'");
	      name = ctx.stylize(name, 'string');
	    }
	  }

	  return name + ': ' + str;
	}


	function reduceToSingleString(output, base, braces) {
	  var numLinesEst = 0;
	  var length = output.reduce(function(prev, cur) {
	    numLinesEst++;
	    if (cur.indexOf('\n') >= 0) numLinesEst++;
	    return prev + cur.length + 1;
	  }, 0);

	  if (length > 60) {
	    return braces[0] +
	           (base === '' ? '' : base + '\n ') +
	           ' ' +
	           output.join(',\n  ') +
	           ' ' +
	           braces[1];
	  }

	  return braces[0] + base + ' ' + output.join(', ') + ' ' + braces[1];
	}

	function isArray(ar) {
	  return Array.isArray(ar) ||
	         (typeof ar === 'object' && objectToString(ar) === '[object Array]');
	}

	function isRegExp(re) {
	  return typeof re === 'object' && objectToString(re) === '[object RegExp]';
	}

	function isDate(d) {
	  return typeof d === 'object' && objectToString(d) === '[object Date]';
	}

	function isError(e) {
	  return typeof e === 'object' && objectToString(e) === '[object Error]';
	}

	function objectToString(o) {
	  return Object.prototype.toString.call(o);
	}


/***/ },
/* 20 */
/***/ function(module, exports) {

	/*!
	 * Chai - getName utility
	 * Copyright(c) 2012-2014 Jake Luer <jake@alogicalparadox.com>
	 * MIT Licensed
	 */

	/**
	 * # getName(func)
	 *
	 * Gets the name of a function, in a cross-browser way.
	 *
	 * @param {Function} a function (usually a constructor)
	 */

	module.exports = function (func) {
	  if (func.name) return func.name;

	  var match = /^\s?function ([^(]*)\(/.exec(func);
	  return match && match[1] ? match[1] : "";
	};


/***/ },
/* 21 */
/***/ function(module, exports) {

	/*!
	 * Chai - getProperties utility
	 * Copyright(c) 2012-2014 Jake Luer <jake@alogicalparadox.com>
	 * MIT Licensed
	 */

	/**
	 * ### .getProperties(object)
	 *
	 * This allows the retrieval of property names of an object, enumerable or not,
	 * inherited or not.
	 *
	 * @param {Object} object
	 * @returns {Array}
	 * @name getProperties
	 * @api public
	 */

	module.exports = function getProperties(object) {
	  var result = Object.getOwnPropertyNames(subject);

	  function addProperty(property) {
	    if (result.indexOf(property) === -1) {
	      result.push(property);
	    }
	  }

	  var proto = Object.getPrototypeOf(subject);
	  while (proto !== null) {
	    Object.getOwnPropertyNames(proto).forEach(addProperty);
	    proto = Object.getPrototypeOf(proto);
	  }

	  return result;
	};


/***/ },
/* 22 */
/***/ function(module, exports) {

	/*!
	 * Chai - getEnumerableProperties utility
	 * Copyright(c) 2012-2014 Jake Luer <jake@alogicalparadox.com>
	 * MIT Licensed
	 */

	/**
	 * ### .getEnumerableProperties(object)
	 *
	 * This allows the retrieval of enumerable property names of an object,
	 * inherited or not.
	 *
	 * @param {Object} object
	 * @returns {Array}
	 * @name getEnumerableProperties
	 * @api public
	 */

	module.exports = function getEnumerableProperties(object) {
	  var result = [];
	  for (var name in object) {
	    result.push(name);
	  }
	  return result;
	};


/***/ },
/* 23 */
/***/ function(module, exports, __webpack_require__) {

	/*!
	 * Chai - flag utility
	 * Copyright(c) 2012-2014 Jake Luer <jake@alogicalparadox.com>
	 * MIT Licensed
	 */

	/*!
	 * Module dependancies
	 */

	var inspect = __webpack_require__(19);
	var config = __webpack_require__(24);

	/**
	 * ### .objDisplay (object)
	 *
	 * Determines if an object or an array matches
	 * criteria to be inspected in-line for error
	 * messages or should be truncated.
	 *
	 * @param {Mixed} javascript object to inspect
	 * @name objDisplay
	 * @api public
	 */

	module.exports = function (obj) {
	  var str = inspect(obj)
	    , type = Object.prototype.toString.call(obj);

	  if (config.truncateThreshold && str.length >= config.truncateThreshold) {
	    if (type === '[object Function]') {
	      return !obj.name || obj.name === ''
	        ? '[Function]'
	        : '[Function: ' + obj.name + ']';
	    } else if (type === '[object Array]') {
	      return '[ Array(' + obj.length + ') ]';
	    } else if (type === '[object Object]') {
	      var keys = Object.keys(obj)
	        , kstr = keys.length > 2
	          ? keys.splice(0, 2).join(', ') + ', ...'
	          : keys.join(', ');
	      return '{ Object (' + kstr + ') }';
	    } else {
	      return str;
	    }
	  } else {
	    return str;
	  }
	};


/***/ },
/* 24 */
/***/ function(module, exports) {

	module.exports = {

	  /**
	   * ### config.includeStack
	   *
	   * User configurable property, influences whether stack trace
	   * is included in Assertion error message. Default of false
	   * suppresses stack trace in the error message.
	   *
	   *     chai.config.includeStack = true;  // enable stack on error
	   *
	   * @param {Boolean}
	   * @api public
	   */

	   includeStack: false,

	  /**
	   * ### config.showDiff
	   *
	   * User configurable property, influences whether or not
	   * the `showDiff` flag should be included in the thrown
	   * AssertionErrors. `false` will always be `false`; `true`
	   * will be true when the assertion has requested a diff
	   * be shown.
	   *
	   * @param {Boolean}
	   * @api public
	   */

	  showDiff: true,

	  /**
	   * ### config.truncateThreshold
	   *
	   * User configurable property, sets length threshold for actual and
	   * expected values in assertion errors. If this threshold is exceeded, for
	   * example for large data structures, the value is replaced with something
	   * like `[ Array(3) ]` or `{ Object (prop1, prop2) }`.
	   *
	   * Set it to zero if you want to disable truncating altogether.
	   *
	   * This is especially userful when doing assertions on arrays: having this
	   * set to a reasonable large value makes the failure messages readily
	   * inspectable.
	   *
	   *     chai.config.truncateThreshold = 0;  // disable truncating
	   *
	   * @param {Number}
	   * @api public
	   */

	  truncateThreshold: 40

	};


/***/ },
/* 25 */
/***/ function(module, exports) {

	/*!
	 * Chai - transferFlags utility
	 * Copyright(c) 2012-2014 Jake Luer <jake@alogicalparadox.com>
	 * MIT Licensed
	 */

	/**
	 * ### transferFlags(assertion, object, includeAll = true)
	 *
	 * Transfer all the flags for `assertion` to `object`. If
	 * `includeAll` is set to `false`, then the base Chai
	 * assertion flags (namely `object`, `ssfi`, and `message`)
	 * will not be transferred.
	 *
	 *
	 *     var newAssertion = new Assertion();
	 *     utils.transferFlags(assertion, newAssertion);
	 *
	 *     var anotherAsseriton = new Assertion(myObj);
	 *     utils.transferFlags(assertion, anotherAssertion, false);
	 *
	 * @param {Assertion} assertion the assertion to transfer the flags from
	 * @param {Object} object the object to transfer the flags to; usually a new assertion
	 * @param {Boolean} includeAll
	 * @name transferFlags
	 * @api private
	 */

	module.exports = function (assertion, object, includeAll) {
	  var flags = assertion.__flags || (assertion.__flags = Object.create(null));

	  if (!object.__flags) {
	    object.__flags = Object.create(null);
	  }

	  includeAll = arguments.length === 3 ? includeAll : true;

	  for (var flag in flags) {
	    if (includeAll ||
	        (flag !== 'object' && flag !== 'ssfi' && flag != 'message')) {
	      object.__flags[flag] = flags[flag];
	    }
	  }
	};


/***/ },
/* 26 */
/***/ function(module, exports, __webpack_require__) {

	module.exports = __webpack_require__(27);


/***/ },
/* 27 */
/***/ function(module, exports, __webpack_require__) {

	/*!
	 * deep-eql
	 * Copyright(c) 2013 Jake Luer <jake@alogicalparadox.com>
	 * MIT Licensed
	 */

	/*!
	 * Module dependencies
	 */

	var type = __webpack_require__(28);

	/*!
	 * Buffer.isBuffer browser shim
	 */

	var Buffer;
	try { Buffer = __webpack_require__(30).Buffer; }
	catch(ex) {
	  Buffer = {};
	  Buffer.isBuffer = function() { return false; }
	}

	/*!
	 * Primary Export
	 */

	module.exports = deepEqual;

	/**
	 * Assert super-strict (egal) equality between
	 * two objects of any type.
	 *
	 * @param {Mixed} a
	 * @param {Mixed} b
	 * @param {Array} memoised (optional)
	 * @return {Boolean} equal match
	 */

	function deepEqual(a, b, m) {
	  if (sameValue(a, b)) {
	    return true;
	  } else if ('date' === type(a)) {
	    return dateEqual(a, b);
	  } else if ('regexp' === type(a)) {
	    return regexpEqual(a, b);
	  } else if (Buffer.isBuffer(a)) {
	    return bufferEqual(a, b);
	  } else if ('arguments' === type(a)) {
	    return argumentsEqual(a, b, m);
	  } else if (!typeEqual(a, b)) {
	    return false;
	  } else if (('object' !== type(a) && 'object' !== type(b))
	  && ('array' !== type(a) && 'array' !== type(b))) {
	    return sameValue(a, b);
	  } else {
	    return objectEqual(a, b, m);
	  }
	}

	/*!
	 * Strict (egal) equality test. Ensures that NaN always
	 * equals NaN and `-0` does not equal `+0`.
	 *
	 * @param {Mixed} a
	 * @param {Mixed} b
	 * @return {Boolean} equal match
	 */

	function sameValue(a, b) {
	  if (a === b) return a !== 0 || 1 / a === 1 / b;
	  return a !== a && b !== b;
	}

	/*!
	 * Compare the types of two given objects and
	 * return if they are equal. Note that an Array
	 * has a type of `array` (not `object`) and arguments
	 * have a type of `arguments` (not `array`/`object`).
	 *
	 * @param {Mixed} a
	 * @param {Mixed} b
	 * @return {Boolean} result
	 */

	function typeEqual(a, b) {
	  return type(a) === type(b);
	}

	/*!
	 * Compare two Date objects by asserting that
	 * the time values are equal using `saveValue`.
	 *
	 * @param {Date} a
	 * @param {Date} b
	 * @return {Boolean} result
	 */

	function dateEqual(a, b) {
	  if ('date' !== type(b)) return false;
	  return sameValue(a.getTime(), b.getTime());
	}

	/*!
	 * Compare two regular expressions by converting them
	 * to string and checking for `sameValue`.
	 *
	 * @param {RegExp} a
	 * @param {RegExp} b
	 * @return {Boolean} result
	 */

	function regexpEqual(a, b) {
	  if ('regexp' !== type(b)) return false;
	  return sameValue(a.toString(), b.toString());
	}

	/*!
	 * Assert deep equality of two `arguments` objects.
	 * Unfortunately, these must be sliced to arrays
	 * prior to test to ensure no bad behavior.
	 *
	 * @param {Arguments} a
	 * @param {Arguments} b
	 * @param {Array} memoize (optional)
	 * @return {Boolean} result
	 */

	function argumentsEqual(a, b, m) {
	  if ('arguments' !== type(b)) return false;
	  a = [].slice.call(a);
	  b = [].slice.call(b);
	  return deepEqual(a, b, m);
	}

	/*!
	 * Get enumerable properties of a given object.
	 *
	 * @param {Object} a
	 * @return {Array} property names
	 */

	function enumerable(a) {
	  var res = [];
	  for (var key in a) res.push(key);
	  return res;
	}

	/*!
	 * Simple equality for flat iterable objects
	 * such as Arrays or Node.js buffers.
	 *
	 * @param {Iterable} a
	 * @param {Iterable} b
	 * @return {Boolean} result
	 */

	function iterableEqual(a, b) {
	  if (a.length !==  b.length) return false;

	  var i = 0;
	  var match = true;

	  for (; i < a.length; i++) {
	    if (a[i] !== b[i]) {
	      match = false;
	      break;
	    }
	  }

	  return match;
	}

	/*!
	 * Extension to `iterableEqual` specifically
	 * for Node.js Buffers.
	 *
	 * @param {Buffer} a
	 * @param {Mixed} b
	 * @return {Boolean} result
	 */

	function bufferEqual(a, b) {
	  if (!Buffer.isBuffer(b)) return false;
	  return iterableEqual(a, b);
	}

	/*!
	 * Block for `objectEqual` ensuring non-existing
	 * values don't get in.
	 *
	 * @param {Mixed} object
	 * @return {Boolean} result
	 */

	function isValue(a) {
	  return a !== null && a !== undefined;
	}

	/*!
	 * Recursively check the equality of two objects.
	 * Once basic sameness has been established it will
	 * defer to `deepEqual` for each enumerable key
	 * in the object.
	 *
	 * @param {Mixed} a
	 * @param {Mixed} b
	 * @return {Boolean} result
	 */

	function objectEqual(a, b, m) {
	  if (!isValue(a) || !isValue(b)) {
	    return false;
	  }

	  if (a.prototype !== b.prototype) {
	    return false;
	  }

	  var i;
	  if (m) {
	    for (i = 0; i < m.length; i++) {
	      if ((m[i][0] === a && m[i][1] === b)
	      ||  (m[i][0] === b && m[i][1] === a)) {
	        return true;
	      }
	    }
	  } else {
	    m = [];
	  }

	  try {
	    var ka = enumerable(a);
	    var kb = enumerable(b);
	  } catch (ex) {
	    return false;
	  }

	  ka.sort();
	  kb.sort();

	  if (!iterableEqual(ka, kb)) {
	    return false;
	  }

	  m.push([ a, b ]);

	  var key;
	  for (i = ka.length - 1; i >= 0; i--) {
	    key = ka[i];
	    if (!deepEqual(a[key], b[key], m)) {
	      return false;
	    }
	  }

	  return true;
	}


/***/ },
/* 28 */
/***/ function(module, exports, __webpack_require__) {

	module.exports = __webpack_require__(29);


/***/ },
/* 29 */
/***/ function(module, exports) {

	/*!
	 * type-detect
	 * Copyright(c) 2013 jake luer <jake@alogicalparadox.com>
	 * MIT Licensed
	 */

	/*!
	 * Primary Exports
	 */

	var exports = module.exports = getType;

	/*!
	 * Detectable javascript natives
	 */

	var natives = {
	    '[object Array]': 'array'
	  , '[object RegExp]': 'regexp'
	  , '[object Function]': 'function'
	  , '[object Arguments]': 'arguments'
	  , '[object Date]': 'date'
	};

	/**
	 * ### typeOf (obj)
	 *
	 * Use several different techniques to determine
	 * the type of object being tested.
	 *
	 *
	 * @param {Mixed} object
	 * @return {String} object type
	 * @api public
	 */

	function getType (obj) {
	  var str = Object.prototype.toString.call(obj);
	  if (natives[str]) return natives[str];
	  if (obj === null) return 'null';
	  if (obj === undefined) return 'undefined';
	  if (obj === Object(obj)) return 'object';
	  return typeof obj;
	}

	exports.Library = Library;

	/**
	 * ### Library
	 *
	 * Create a repository for custom type detection.
	 *
	 * ```js
	 * var lib = new type.Library;
	 * ```
	 *
	 */

	function Library () {
	  this.tests = {};
	}

	/**
	 * #### .of (obj)
	 *
	 * Expose replacement `typeof` detection to the library.
	 *
	 * ```js
	 * if ('string' === lib.of('hello world')) {
	 *   // ...
	 * }
	 * ```
	 *
	 * @param {Mixed} object to test
	 * @return {String} type
	 */

	Library.prototype.of = getType;

	/**
	 * #### .define (type, test)
	 *
	 * Add a test to for the `.test()` assertion.
	 *
	 * Can be defined as a regular expression:
	 *
	 * ```js
	 * lib.define('int', /^[0-9]+$/);
	 * ```
	 *
	 * ... or as a function:
	 *
	 * ```js
	 * lib.define('bln', function (obj) {
	 *   if ('boolean' === lib.of(obj)) return true;
	 *   var blns = [ 'yes', 'no', 'true', 'false', 1, 0 ];
	 *   if ('string' === lib.of(obj)) obj = obj.toLowerCase();
	 *   return !! ~blns.indexOf(obj);
	 * });
	 * ```
	 *
	 * @param {String} type
	 * @param {RegExp|Function} test
	 * @api public
	 */

	Library.prototype.define = function (type, test) {
	  if (arguments.length === 1) return this.tests[type];
	  this.tests[type] = test;
	  return this;
	};

	/**
	 * #### .test (obj, test)
	 *
	 * Assert that an object is of type. Will first
	 * check natives, and if that does not pass it will
	 * use the user defined custom tests.
	 *
	 * ```js
	 * assert(lib.test('1', 'int'));
	 * assert(lib.test('yes', 'bln'));
	 * ```
	 *
	 * @param {Mixed} object
	 * @param {String} type
	 * @return {Boolean} result
	 * @api public
	 */

	Library.prototype.test = function (obj, type) {
	  if (type === getType(obj)) return true;
	  var test = this.tests[type];

	  if (test && 'regexp' === getType(test)) {
	    return test.test(obj);
	  } else if (test && 'function' === getType(test)) {
	    return test(obj);
	  } else {
	    throw new ReferenceError('Type test "' + type + '" not defined or invalid.');
	  }
	};


/***/ },
/* 30 */
/***/ function(module, exports, __webpack_require__) {

	/* WEBPACK VAR INJECTION */(function(Buffer) {/*!
	 * The buffer module from node.js, for the browser.
	 *
	 * @author   Feross Aboukhadijeh <feross@feross.org> <http://feross.org>
	 * @license  MIT
	 */

	var base64 = __webpack_require__(31)
	var ieee754 = __webpack_require__(32)
	var isArray = __webpack_require__(33)

	exports.Buffer = Buffer
	exports.SlowBuffer = SlowBuffer
	exports.INSPECT_MAX_BYTES = 50
	Buffer.poolSize = 8192 // not used by this implementation

	var rootParent = {}

	/**
	 * If `Buffer.TYPED_ARRAY_SUPPORT`:
	 *   === true    Use Uint8Array implementation (fastest)
	 *   === false   Use Object implementation (most compatible, even IE6)
	 *
	 * Browsers that support typed arrays are IE 10+, Firefox 4+, Chrome 7+, Safari 5.1+,
	 * Opera 11.6+, iOS 4.2+.
	 *
	 * Due to various browser bugs, sometimes the Object implementation will be used even
	 * when the browser supports typed arrays.
	 *
	 * Note:
	 *
	 *   - Firefox 4-29 lacks support for adding new properties to `Uint8Array` instances,
	 *     See: https://bugzilla.mozilla.org/show_bug.cgi?id=695438.
	 *
	 *   - Safari 5-7 lacks support for changing the `Object.prototype.constructor` property
	 *     on objects.
	 *
	 *   - Chrome 9-10 is missing the `TypedArray.prototype.subarray` function.
	 *
	 *   - IE10 has a broken `TypedArray.prototype.subarray` function which returns arrays of
	 *     incorrect length in some situations.

	 * We detect these buggy browsers and set `Buffer.TYPED_ARRAY_SUPPORT` to `false` so they
	 * get the Object implementation, which is slower but behaves correctly.
	 */
	Buffer.TYPED_ARRAY_SUPPORT = (function () {
	  function Bar () {}
	  try {
	    var arr = new Uint8Array(1)
	    arr.foo = function () { return 42 }
	    arr.constructor = Bar
	    return arr.foo() === 42 && // typed array instances can be augmented
	        arr.constructor === Bar && // constructor can be set
	        typeof arr.subarray === 'function' && // chrome 9-10 lack `subarray`
	        arr.subarray(1, 1).byteLength === 0 // ie10 has broken `subarray`
	  } catch (e) {
	    return false
	  }
	})()

	function kMaxLength () {
	  return Buffer.TYPED_ARRAY_SUPPORT
	    ? 0x7fffffff
	    : 0x3fffffff
	}

	/**
	 * Class: Buffer
	 * =============
	 *
	 * The Buffer constructor returns instances of `Uint8Array` that are augmented
	 * with function properties for all the node `Buffer` API functions. We use
	 * `Uint8Array` so that square bracket notation works as expected -- it returns
	 * a single octet.
	 *
	 * By augmenting the instances, we can avoid modifying the `Uint8Array`
	 * prototype.
	 */
	function Buffer (arg) {
	  if (!(this instanceof Buffer)) {
	    // Avoid going through an ArgumentsAdaptorTrampoline in the common case.
	    if (arguments.length > 1) return new Buffer(arg, arguments[1])
	    return new Buffer(arg)
	  }

	  this.length = 0
	  this.parent = undefined

	  // Common case.
	  if (typeof arg === 'number') {
	    return fromNumber(this, arg)
	  }

	  // Slightly less common case.
	  if (typeof arg === 'string') {
	    return fromString(this, arg, arguments.length > 1 ? arguments[1] : 'utf8')
	  }

	  // Unusual.
	  return fromObject(this, arg)
	}

	function fromNumber (that, length) {
	  that = allocate(that, length < 0 ? 0 : checked(length) | 0)
	  if (!Buffer.TYPED_ARRAY_SUPPORT) {
	    for (var i = 0; i < length; i++) {
	      that[i] = 0
	    }
	  }
	  return that
	}

	function fromString (that, string, encoding) {
	  if (typeof encoding !== 'string' || encoding === '') encoding = 'utf8'

	  // Assumption: byteLength() return value is always < kMaxLength.
	  var length = byteLength(string, encoding) | 0
	  that = allocate(that, length)

	  that.write(string, encoding)
	  return that
	}

	function fromObject (that, object) {
	  if (Buffer.isBuffer(object)) return fromBuffer(that, object)

	  if (isArray(object)) return fromArray(that, object)

	  if (object == null) {
	    throw new TypeError('must start with number, buffer, array or string')
	  }

	  if (typeof ArrayBuffer !== 'undefined') {
	    if (object.buffer instanceof ArrayBuffer) {
	      return fromTypedArray(that, object)
	    }
	    if (object instanceof ArrayBuffer) {
	      return fromArrayBuffer(that, object)
	    }
	  }

	  if (object.length) return fromArrayLike(that, object)

	  return fromJsonObject(that, object)
	}

	function fromBuffer (that, buffer) {
	  var length = checked(buffer.length) | 0
	  that = allocate(that, length)
	  buffer.copy(that, 0, 0, length)
	  return that
	}

	function fromArray (that, array) {
	  var length = checked(array.length) | 0
	  that = allocate(that, length)
	  for (var i = 0; i < length; i += 1) {
	    that[i] = array[i] & 255
	  }
	  return that
	}

	// Duplicate of fromArray() to keep fromArray() monomorphic.
	function fromTypedArray (that, array) {
	  var length = checked(array.length) | 0
	  that = allocate(that, length)
	  // Truncating the elements is probably not what people expect from typed
	  // arrays with BYTES_PER_ELEMENT > 1 but it's compatible with the behavior
	  // of the old Buffer constructor.
	  for (var i = 0; i < length; i += 1) {
	    that[i] = array[i] & 255
	  }
	  return that
	}

	function fromArrayBuffer (that, array) {
	  if (Buffer.TYPED_ARRAY_SUPPORT) {
	    // Return an augmented `Uint8Array` instance, for best performance
	    array.byteLength
	    that = Buffer._augment(new Uint8Array(array))
	  } else {
	    // Fallback: Return an object instance of the Buffer class
	    that = fromTypedArray(that, new Uint8Array(array))
	  }
	  return that
	}

	function fromArrayLike (that, array) {
	  var length = checked(array.length) | 0
	  that = allocate(that, length)
	  for (var i = 0; i < length; i += 1) {
	    that[i] = array[i] & 255
	  }
	  return that
	}

	// Deserialize { type: 'Buffer', data: [1,2,3,...] } into a Buffer object.
	// Returns a zero-length buffer for inputs that don't conform to the spec.
	function fromJsonObject (that, object) {
	  var array
	  var length = 0

	  if (object.type === 'Buffer' && isArray(object.data)) {
	    array = object.data
	    length = checked(array.length) | 0
	  }
	  that = allocate(that, length)

	  for (var i = 0; i < length; i += 1) {
	    that[i] = array[i] & 255
	  }
	  return that
	}

	function allocate (that, length) {
	  if (Buffer.TYPED_ARRAY_SUPPORT) {
	    // Return an augmented `Uint8Array` instance, for best performance
	    that = Buffer._augment(new Uint8Array(length))
	  } else {
	    // Fallback: Return an object instance of the Buffer class
	    that.length = length
	    that._isBuffer = true
	  }

	  var fromPool = length !== 0 && length <= Buffer.poolSize >>> 1
	  if (fromPool) that.parent = rootParent

	  return that
	}

	function checked (length) {
	  // Note: cannot use `length < kMaxLength` here because that fails when
	  // length is NaN (which is otherwise coerced to zero.)
	  if (length >= kMaxLength()) {
	    throw new RangeError('Attempt to allocate Buffer larger than maximum ' +
	                         'size: 0x' + kMaxLength().toString(16) + ' bytes')
	  }
	  return length | 0
	}

	function SlowBuffer (subject, encoding) {
	  if (!(this instanceof SlowBuffer)) return new SlowBuffer(subject, encoding)

	  var buf = new Buffer(subject, encoding)
	  delete buf.parent
	  return buf
	}

	Buffer.isBuffer = function isBuffer (b) {
	  return !!(b != null && b._isBuffer)
	}

	Buffer.compare = function compare (a, b) {
	  if (!Buffer.isBuffer(a) || !Buffer.isBuffer(b)) {
	    throw new TypeError('Arguments must be Buffers')
	  }

	  if (a === b) return 0

	  var x = a.length
	  var y = b.length

	  var i = 0
	  var len = Math.min(x, y)
	  while (i < len) {
	    if (a[i] !== b[i]) break

	    ++i
	  }

	  if (i !== len) {
	    x = a[i]
	    y = b[i]
	  }

	  if (x < y) return -1
	  if (y < x) return 1
	  return 0
	}

	Buffer.isEncoding = function isEncoding (encoding) {
	  switch (String(encoding).toLowerCase()) {
	    case 'hex':
	    case 'utf8':
	    case 'utf-8':
	    case 'ascii':
	    case 'binary':
	    case 'base64':
	    case 'raw':
	    case 'ucs2':
	    case 'ucs-2':
	    case 'utf16le':
	    case 'utf-16le':
	      return true
	    default:
	      return false
	  }
	}

	Buffer.concat = function concat (list, length) {
	  if (!isArray(list)) throw new TypeError('list argument must be an Array of Buffers.')

	  if (list.length === 0) {
	    return new Buffer(0)
	  }

	  var i
	  if (length === undefined) {
	    length = 0
	    for (i = 0; i < list.length; i++) {
	      length += list[i].length
	    }
	  }

	  var buf = new Buffer(length)
	  var pos = 0
	  for (i = 0; i < list.length; i++) {
	    var item = list[i]
	    item.copy(buf, pos)
	    pos += item.length
	  }
	  return buf
	}

	function byteLength (string, encoding) {
	  if (typeof string !== 'string') string = '' + string

	  var len = string.length
	  if (len === 0) return 0

	  // Use a for loop to avoid recursion
	  var loweredCase = false
	  for (;;) {
	    switch (encoding) {
	      case 'ascii':
	      case 'binary':
	      // Deprecated
	      case 'raw':
	      case 'raws':
	        return len
	      case 'utf8':
	      case 'utf-8':
	        return utf8ToBytes(string).length
	      case 'ucs2':
	      case 'ucs-2':
	      case 'utf16le':
	      case 'utf-16le':
	        return len * 2
	      case 'hex':
	        return len >>> 1
	      case 'base64':
	        return base64ToBytes(string).length
	      default:
	        if (loweredCase) return utf8ToBytes(string).length // assume utf8
	        encoding = ('' + encoding).toLowerCase()
	        loweredCase = true
	    }
	  }
	}
	Buffer.byteLength = byteLength

	// pre-set for values that may exist in the future
	Buffer.prototype.length = undefined
	Buffer.prototype.parent = undefined

	function slowToString (encoding, start, end) {
	  var loweredCase = false

	  start = start | 0
	  end = end === undefined || end === Infinity ? this.length : end | 0

	  if (!encoding) encoding = 'utf8'
	  if (start < 0) start = 0
	  if (end > this.length) end = this.length
	  if (end <= start) return ''

	  while (true) {
	    switch (encoding) {
	      case 'hex':
	        return hexSlice(this, start, end)

	      case 'utf8':
	      case 'utf-8':
	        return utf8Slice(this, start, end)

	      case 'ascii':
	        return asciiSlice(this, start, end)

	      case 'binary':
	        return binarySlice(this, start, end)

	      case 'base64':
	        return base64Slice(this, start, end)

	      case 'ucs2':
	      case 'ucs-2':
	      case 'utf16le':
	      case 'utf-16le':
	        return utf16leSlice(this, start, end)

	      default:
	        if (loweredCase) throw new TypeError('Unknown encoding: ' + encoding)
	        encoding = (encoding + '').toLowerCase()
	        loweredCase = true
	    }
	  }
	}

	Buffer.prototype.toString = function toString () {
	  var length = this.length | 0
	  if (length === 0) return ''
	  if (arguments.length === 0) return utf8Slice(this, 0, length)
	  return slowToString.apply(this, arguments)
	}

	Buffer.prototype.equals = function equals (b) {
	  if (!Buffer.isBuffer(b)) throw new TypeError('Argument must be a Buffer')
	  if (this === b) return true
	  return Buffer.compare(this, b) === 0
	}

	Buffer.prototype.inspect = function inspect () {
	  var str = ''
	  var max = exports.INSPECT_MAX_BYTES
	  if (this.length > 0) {
	    str = this.toString('hex', 0, max).match(/.{2}/g).join(' ')
	    if (this.length > max) str += ' ... '
	  }
	  return '<Buffer ' + str + '>'
	}

	Buffer.prototype.compare = function compare (b) {
	  if (!Buffer.isBuffer(b)) throw new TypeError('Argument must be a Buffer')
	  if (this === b) return 0
	  return Buffer.compare(this, b)
	}

	Buffer.prototype.indexOf = function indexOf (val, byteOffset) {
	  if (byteOffset > 0x7fffffff) byteOffset = 0x7fffffff
	  else if (byteOffset < -0x80000000) byteOffset = -0x80000000
	  byteOffset >>= 0

	  if (this.length === 0) return -1
	  if (byteOffset >= this.length) return -1

	  // Negative offsets start from the end of the buffer
	  if (byteOffset < 0) byteOffset = Math.max(this.length + byteOffset, 0)

	  if (typeof val === 'string') {
	    if (val.length === 0) return -1 // special case: looking for empty string always fails
	    return String.prototype.indexOf.call(this, val, byteOffset)
	  }
	  if (Buffer.isBuffer(val)) {
	    return arrayIndexOf(this, val, byteOffset)
	  }
	  if (typeof val === 'number') {
	    if (Buffer.TYPED_ARRAY_SUPPORT && Uint8Array.prototype.indexOf === 'function') {
	      return Uint8Array.prototype.indexOf.call(this, val, byteOffset)
	    }
	    return arrayIndexOf(this, [ val ], byteOffset)
	  }

	  function arrayIndexOf (arr, val, byteOffset) {
	    var foundIndex = -1
	    for (var i = 0; byteOffset + i < arr.length; i++) {
	      if (arr[byteOffset + i] === val[foundIndex === -1 ? 0 : i - foundIndex]) {
	        if (foundIndex === -1) foundIndex = i
	        if (i - foundIndex + 1 === val.length) return byteOffset + foundIndex
	      } else {
	        foundIndex = -1
	      }
	    }
	    return -1
	  }

	  throw new TypeError('val must be string, number or Buffer')
	}

	// `get` is deprecated
	Buffer.prototype.get = function get (offset) {
	  console.log('.get() is deprecated. Access using array indexes instead.')
	  return this.readUInt8(offset)
	}

	// `set` is deprecated
	Buffer.prototype.set = function set (v, offset) {
	  console.log('.set() is deprecated. Access using array indexes instead.')
	  return this.writeUInt8(v, offset)
	}

	function hexWrite (buf, string, offset, length) {
	  offset = Number(offset) || 0
	  var remaining = buf.length - offset
	  if (!length) {
	    length = remaining
	  } else {
	    length = Number(length)
	    if (length > remaining) {
	      length = remaining
	    }
	  }

	  // must be an even number of digits
	  var strLen = string.length
	  if (strLen % 2 !== 0) throw new Error('Invalid hex string')

	  if (length > strLen / 2) {
	    length = strLen / 2
	  }
	  for (var i = 0; i < length; i++) {
	    var parsed = parseInt(string.substr(i * 2, 2), 16)
	    if (isNaN(parsed)) throw new Error('Invalid hex string')
	    buf[offset + i] = parsed
	  }
	  return i
	}

	function utf8Write (buf, string, offset, length) {
	  return blitBuffer(utf8ToBytes(string, buf.length - offset), buf, offset, length)
	}

	function asciiWrite (buf, string, offset, length) {
	  return blitBuffer(asciiToBytes(string), buf, offset, length)
	}

	function binaryWrite (buf, string, offset, length) {
	  return asciiWrite(buf, string, offset, length)
	}

	function base64Write (buf, string, offset, length) {
	  return blitBuffer(base64ToBytes(string), buf, offset, length)
	}

	function ucs2Write (buf, string, offset, length) {
	  return blitBuffer(utf16leToBytes(string, buf.length - offset), buf, offset, length)
	}

	Buffer.prototype.write = function write (string, offset, length, encoding) {
	  // Buffer#write(string)
	  if (offset === undefined) {
	    encoding = 'utf8'
	    length = this.length
	    offset = 0
	  // Buffer#write(string, encoding)
	  } else if (length === undefined && typeof offset === 'string') {
	    encoding = offset
	    length = this.length
	    offset = 0
	  // Buffer#write(string, offset[, length][, encoding])
	  } else if (isFinite(offset)) {
	    offset = offset | 0
	    if (isFinite(length)) {
	      length = length | 0
	      if (encoding === undefined) encoding = 'utf8'
	    } else {
	      encoding = length
	      length = undefined
	    }
	  // legacy write(string, encoding, offset, length) - remove in v0.13
	  } else {
	    var swap = encoding
	    encoding = offset
	    offset = length | 0
	    length = swap
	  }

	  var remaining = this.length - offset
	  if (length === undefined || length > remaining) length = remaining

	  if ((string.length > 0 && (length < 0 || offset < 0)) || offset > this.length) {
	    throw new RangeError('attempt to write outside buffer bounds')
	  }

	  if (!encoding) encoding = 'utf8'

	  var loweredCase = false
	  for (;;) {
	    switch (encoding) {
	      case 'hex':
	        return hexWrite(this, string, offset, length)

	      case 'utf8':
	      case 'utf-8':
	        return utf8Write(this, string, offset, length)

	      case 'ascii':
	        return asciiWrite(this, string, offset, length)

	      case 'binary':
	        return binaryWrite(this, string, offset, length)

	      case 'base64':
	        // Warning: maxLength not taken into account in base64Write
	        return base64Write(this, string, offset, length)

	      case 'ucs2':
	      case 'ucs-2':
	      case 'utf16le':
	      case 'utf-16le':
	        return ucs2Write(this, string, offset, length)

	      default:
	        if (loweredCase) throw new TypeError('Unknown encoding: ' + encoding)
	        encoding = ('' + encoding).toLowerCase()
	        loweredCase = true
	    }
	  }
	}

	Buffer.prototype.toJSON = function toJSON () {
	  return {
	    type: 'Buffer',
	    data: Array.prototype.slice.call(this._arr || this, 0)
	  }
	}

	function base64Slice (buf, start, end) {
	  if (start === 0 && end === buf.length) {
	    return base64.fromByteArray(buf)
	  } else {
	    return base64.fromByteArray(buf.slice(start, end))
	  }
	}

	function utf8Slice (buf, start, end) {
	  var res = ''
	  var tmp = ''
	  end = Math.min(buf.length, end)

	  for (var i = start; i < end; i++) {
	    if (buf[i] <= 0x7F) {
	      res += decodeUtf8Char(tmp) + String.fromCharCode(buf[i])
	      tmp = ''
	    } else {
	      tmp += '%' + buf[i].toString(16)
	    }
	  }

	  return res + decodeUtf8Char(tmp)
	}

	function asciiSlice (buf, start, end) {
	  var ret = ''
	  end = Math.min(buf.length, end)

	  for (var i = start; i < end; i++) {
	    ret += String.fromCharCode(buf[i] & 0x7F)
	  }
	  return ret
	}

	function binarySlice (buf, start, end) {
	  var ret = ''
	  end = Math.min(buf.length, end)

	  for (var i = start; i < end; i++) {
	    ret += String.fromCharCode(buf[i])
	  }
	  return ret
	}

	function hexSlice (buf, start, end) {
	  var len = buf.length

	  if (!start || start < 0) start = 0
	  if (!end || end < 0 || end > len) end = len

	  var out = ''
	  for (var i = start; i < end; i++) {
	    out += toHex(buf[i])
	  }
	  return out
	}

	function utf16leSlice (buf, start, end) {
	  var bytes = buf.slice(start, end)
	  var res = ''
	  for (var i = 0; i < bytes.length; i += 2) {
	    res += String.fromCharCode(bytes[i] + bytes[i + 1] * 256)
	  }
	  return res
	}

	Buffer.prototype.slice = function slice (start, end) {
	  var len = this.length
	  start = ~~start
	  end = end === undefined ? len : ~~end

	  if (start < 0) {
	    start += len
	    if (start < 0) start = 0
	  } else if (start > len) {
	    start = len
	  }

	  if (end < 0) {
	    end += len
	    if (end < 0) end = 0
	  } else if (end > len) {
	    end = len
	  }

	  if (end < start) end = start

	  var newBuf
	  if (Buffer.TYPED_ARRAY_SUPPORT) {
	    newBuf = Buffer._augment(this.subarray(start, end))
	  } else {
	    var sliceLen = end - start
	    newBuf = new Buffer(sliceLen, undefined)
	    for (var i = 0; i < sliceLen; i++) {
	      newBuf[i] = this[i + start]
	    }
	  }

	  if (newBuf.length) newBuf.parent = this.parent || this

	  return newBuf
	}

	/*
	 * Need to make sure that buffer isn't trying to write out of bounds.
	 */
	function checkOffset (offset, ext, length) {
	  if ((offset % 1) !== 0 || offset < 0) throw new RangeError('offset is not uint')
	  if (offset + ext > length) throw new RangeError('Trying to access beyond buffer length')
	}

	Buffer.prototype.readUIntLE = function readUIntLE (offset, byteLength, noAssert) {
	  offset = offset | 0
	  byteLength = byteLength | 0
	  if (!noAssert) checkOffset(offset, byteLength, this.length)

	  var val = this[offset]
	  var mul = 1
	  var i = 0
	  while (++i < byteLength && (mul *= 0x100)) {
	    val += this[offset + i] * mul
	  }

	  return val
	}

	Buffer.prototype.readUIntBE = function readUIntBE (offset, byteLength, noAssert) {
	  offset = offset | 0
	  byteLength = byteLength | 0
	  if (!noAssert) {
	    checkOffset(offset, byteLength, this.length)
	  }

	  var val = this[offset + --byteLength]
	  var mul = 1
	  while (byteLength > 0 && (mul *= 0x100)) {
	    val += this[offset + --byteLength] * mul
	  }

	  return val
	}

	Buffer.prototype.readUInt8 = function readUInt8 (offset, noAssert) {
	  if (!noAssert) checkOffset(offset, 1, this.length)
	  return this[offset]
	}

	Buffer.prototype.readUInt16LE = function readUInt16LE (offset, noAssert) {
	  if (!noAssert) checkOffset(offset, 2, this.length)
	  return this[offset] | (this[offset + 1] << 8)
	}

	Buffer.prototype.readUInt16BE = function readUInt16BE (offset, noAssert) {
	  if (!noAssert) checkOffset(offset, 2, this.length)
	  return (this[offset] << 8) | this[offset + 1]
	}

	Buffer.prototype.readUInt32LE = function readUInt32LE (offset, noAssert) {
	  if (!noAssert) checkOffset(offset, 4, this.length)

	  return ((this[offset]) |
	      (this[offset + 1] << 8) |
	      (this[offset + 2] << 16)) +
	      (this[offset + 3] * 0x1000000)
	}

	Buffer.prototype.readUInt32BE = function readUInt32BE (offset, noAssert) {
	  if (!noAssert) checkOffset(offset, 4, this.length)

	  return (this[offset] * 0x1000000) +
	    ((this[offset + 1] << 16) |
	    (this[offset + 2] << 8) |
	    this[offset + 3])
	}

	Buffer.prototype.readIntLE = function readIntLE (offset, byteLength, noAssert) {
	  offset = offset | 0
	  byteLength = byteLength | 0
	  if (!noAssert) checkOffset(offset, byteLength, this.length)

	  var val = this[offset]
	  var mul = 1
	  var i = 0
	  while (++i < byteLength && (mul *= 0x100)) {
	    val += this[offset + i] * mul
	  }
	  mul *= 0x80

	  if (val >= mul) val -= Math.pow(2, 8 * byteLength)

	  return val
	}

	Buffer.prototype.readIntBE = function readIntBE (offset, byteLength, noAssert) {
	  offset = offset | 0
	  byteLength = byteLength | 0
	  if (!noAssert) checkOffset(offset, byteLength, this.length)

	  var i = byteLength
	  var mul = 1
	  var val = this[offset + --i]
	  while (i > 0 && (mul *= 0x100)) {
	    val += this[offset + --i] * mul
	  }
	  mul *= 0x80

	  if (val >= mul) val -= Math.pow(2, 8 * byteLength)

	  return val
	}

	Buffer.prototype.readInt8 = function readInt8 (offset, noAssert) {
	  if (!noAssert) checkOffset(offset, 1, this.length)
	  if (!(this[offset] & 0x80)) return (this[offset])
	  return ((0xff - this[offset] + 1) * -1)
	}

	Buffer.prototype.readInt16LE = function readInt16LE (offset, noAssert) {
	  if (!noAssert) checkOffset(offset, 2, this.length)
	  var val = this[offset] | (this[offset + 1] << 8)
	  return (val & 0x8000) ? val | 0xFFFF0000 : val
	}

	Buffer.prototype.readInt16BE = function readInt16BE (offset, noAssert) {
	  if (!noAssert) checkOffset(offset, 2, this.length)
	  var val = this[offset + 1] | (this[offset] << 8)
	  return (val & 0x8000) ? val | 0xFFFF0000 : val
	}

	Buffer.prototype.readInt32LE = function readInt32LE (offset, noAssert) {
	  if (!noAssert) checkOffset(offset, 4, this.length)

	  return (this[offset]) |
	    (this[offset + 1] << 8) |
	    (this[offset + 2] << 16) |
	    (this[offset + 3] << 24)
	}

	Buffer.prototype.readInt32BE = function readInt32BE (offset, noAssert) {
	  if (!noAssert) checkOffset(offset, 4, this.length)

	  return (this[offset] << 24) |
	    (this[offset + 1] << 16) |
	    (this[offset + 2] << 8) |
	    (this[offset + 3])
	}

	Buffer.prototype.readFloatLE = function readFloatLE (offset, noAssert) {
	  if (!noAssert) checkOffset(offset, 4, this.length)
	  return ieee754.read(this, offset, true, 23, 4)
	}

	Buffer.prototype.readFloatBE = function readFloatBE (offset, noAssert) {
	  if (!noAssert) checkOffset(offset, 4, this.length)
	  return ieee754.read(this, offset, false, 23, 4)
	}

	Buffer.prototype.readDoubleLE = function readDoubleLE (offset, noAssert) {
	  if (!noAssert) checkOffset(offset, 8, this.length)
	  return ieee754.read(this, offset, true, 52, 8)
	}

	Buffer.prototype.readDoubleBE = function readDoubleBE (offset, noAssert) {
	  if (!noAssert) checkOffset(offset, 8, this.length)
	  return ieee754.read(this, offset, false, 52, 8)
	}

	function checkInt (buf, value, offset, ext, max, min) {
	  if (!Buffer.isBuffer(buf)) throw new TypeError('buffer must be a Buffer instance')
	  if (value > max || value < min) throw new RangeError('value is out of bounds')
	  if (offset + ext > buf.length) throw new RangeError('index out of range')
	}

	Buffer.prototype.writeUIntLE = function writeUIntLE (value, offset, byteLength, noAssert) {
	  value = +value
	  offset = offset | 0
	  byteLength = byteLength | 0
	  if (!noAssert) checkInt(this, value, offset, byteLength, Math.pow(2, 8 * byteLength), 0)

	  var mul = 1
	  var i = 0
	  this[offset] = value & 0xFF
	  while (++i < byteLength && (mul *= 0x100)) {
	    this[offset + i] = (value / mul) & 0xFF
	  }

	  return offset + byteLength
	}

	Buffer.prototype.writeUIntBE = function writeUIntBE (value, offset, byteLength, noAssert) {
	  value = +value
	  offset = offset | 0
	  byteLength = byteLength | 0
	  if (!noAssert) checkInt(this, value, offset, byteLength, Math.pow(2, 8 * byteLength), 0)

	  var i = byteLength - 1
	  var mul = 1
	  this[offset + i] = value & 0xFF
	  while (--i >= 0 && (mul *= 0x100)) {
	    this[offset + i] = (value / mul) & 0xFF
	  }

	  return offset + byteLength
	}

	Buffer.prototype.writeUInt8 = function writeUInt8 (value, offset, noAssert) {
	  value = +value
	  offset = offset | 0
	  if (!noAssert) checkInt(this, value, offset, 1, 0xff, 0)
	  if (!Buffer.TYPED_ARRAY_SUPPORT) value = Math.floor(value)
	  this[offset] = value
	  return offset + 1
	}

	function objectWriteUInt16 (buf, value, offset, littleEndian) {
	  if (value < 0) value = 0xffff + value + 1
	  for (var i = 0, j = Math.min(buf.length - offset, 2); i < j; i++) {
	    buf[offset + i] = (value & (0xff << (8 * (littleEndian ? i : 1 - i)))) >>>
	      (littleEndian ? i : 1 - i) * 8
	  }
	}

	Buffer.prototype.writeUInt16LE = function writeUInt16LE (value, offset, noAssert) {
	  value = +value
	  offset = offset | 0
	  if (!noAssert) checkInt(this, value, offset, 2, 0xffff, 0)
	  if (Buffer.TYPED_ARRAY_SUPPORT) {
	    this[offset] = value
	    this[offset + 1] = (value >>> 8)
	  } else {
	    objectWriteUInt16(this, value, offset, true)
	  }
	  return offset + 2
	}

	Buffer.prototype.writeUInt16BE = function writeUInt16BE (value, offset, noAssert) {
	  value = +value
	  offset = offset | 0
	  if (!noAssert) checkInt(this, value, offset, 2, 0xffff, 0)
	  if (Buffer.TYPED_ARRAY_SUPPORT) {
	    this[offset] = (value >>> 8)
	    this[offset + 1] = value
	  } else {
	    objectWriteUInt16(this, value, offset, false)
	  }
	  return offset + 2
	}

	function objectWriteUInt32 (buf, value, offset, littleEndian) {
	  if (value < 0) value = 0xffffffff + value + 1
	  for (var i = 0, j = Math.min(buf.length - offset, 4); i < j; i++) {
	    buf[offset + i] = (value >>> (littleEndian ? i : 3 - i) * 8) & 0xff
	  }
	}

	Buffer.prototype.writeUInt32LE = function writeUInt32LE (value, offset, noAssert) {
	  value = +value
	  offset = offset | 0
	  if (!noAssert) checkInt(this, value, offset, 4, 0xffffffff, 0)
	  if (Buffer.TYPED_ARRAY_SUPPORT) {
	    this[offset + 3] = (value >>> 24)
	    this[offset + 2] = (value >>> 16)
	    this[offset + 1] = (value >>> 8)
	    this[offset] = value
	  } else {
	    objectWriteUInt32(this, value, offset, true)
	  }
	  return offset + 4
	}

	Buffer.prototype.writeUInt32BE = function writeUInt32BE (value, offset, noAssert) {
	  value = +value
	  offset = offset | 0
	  if (!noAssert) checkInt(this, value, offset, 4, 0xffffffff, 0)
	  if (Buffer.TYPED_ARRAY_SUPPORT) {
	    this[offset] = (value >>> 24)
	    this[offset + 1] = (value >>> 16)
	    this[offset + 2] = (value >>> 8)
	    this[offset + 3] = value
	  } else {
	    objectWriteUInt32(this, value, offset, false)
	  }
	  return offset + 4
	}

	Buffer.prototype.writeIntLE = function writeIntLE (value, offset, byteLength, noAssert) {
	  value = +value
	  offset = offset | 0
	  if (!noAssert) {
	    var limit = Math.pow(2, 8 * byteLength - 1)

	    checkInt(this, value, offset, byteLength, limit - 1, -limit)
	  }

	  var i = 0
	  var mul = 1
	  var sub = value < 0 ? 1 : 0
	  this[offset] = value & 0xFF
	  while (++i < byteLength && (mul *= 0x100)) {
	    this[offset + i] = ((value / mul) >> 0) - sub & 0xFF
	  }

	  return offset + byteLength
	}

	Buffer.prototype.writeIntBE = function writeIntBE (value, offset, byteLength, noAssert) {
	  value = +value
	  offset = offset | 0
	  if (!noAssert) {
	    var limit = Math.pow(2, 8 * byteLength - 1)

	    checkInt(this, value, offset, byteLength, limit - 1, -limit)
	  }

	  var i = byteLength - 1
	  var mul = 1
	  var sub = value < 0 ? 1 : 0
	  this[offset + i] = value & 0xFF
	  while (--i >= 0 && (mul *= 0x100)) {
	    this[offset + i] = ((value / mul) >> 0) - sub & 0xFF
	  }

	  return offset + byteLength
	}

	Buffer.prototype.writeInt8 = function writeInt8 (value, offset, noAssert) {
	  value = +value
	  offset = offset | 0
	  if (!noAssert) checkInt(this, value, offset, 1, 0x7f, -0x80)
	  if (!Buffer.TYPED_ARRAY_SUPPORT) value = Math.floor(value)
	  if (value < 0) value = 0xff + value + 1
	  this[offset] = value
	  return offset + 1
	}

	Buffer.prototype.writeInt16LE = function writeInt16LE (value, offset, noAssert) {
	  value = +value
	  offset = offset | 0
	  if (!noAssert) checkInt(this, value, offset, 2, 0x7fff, -0x8000)
	  if (Buffer.TYPED_ARRAY_SUPPORT) {
	    this[offset] = value
	    this[offset + 1] = (value >>> 8)
	  } else {
	    objectWriteUInt16(this, value, offset, true)
	  }
	  return offset + 2
	}

	Buffer.prototype.writeInt16BE = function writeInt16BE (value, offset, noAssert) {
	  value = +value
	  offset = offset | 0
	  if (!noAssert) checkInt(this, value, offset, 2, 0x7fff, -0x8000)
	  if (Buffer.TYPED_ARRAY_SUPPORT) {
	    this[offset] = (value >>> 8)
	    this[offset + 1] = value
	  } else {
	    objectWriteUInt16(this, value, offset, false)
	  }
	  return offset + 2
	}

	Buffer.prototype.writeInt32LE = function writeInt32LE (value, offset, noAssert) {
	  value = +value
	  offset = offset | 0
	  if (!noAssert) checkInt(this, value, offset, 4, 0x7fffffff, -0x80000000)
	  if (Buffer.TYPED_ARRAY_SUPPORT) {
	    this[offset] = value
	    this[offset + 1] = (value >>> 8)
	    this[offset + 2] = (value >>> 16)
	    this[offset + 3] = (value >>> 24)
	  } else {
	    objectWriteUInt32(this, value, offset, true)
	  }
	  return offset + 4
	}

	Buffer.prototype.writeInt32BE = function writeInt32BE (value, offset, noAssert) {
	  value = +value
	  offset = offset | 0
	  if (!noAssert) checkInt(this, value, offset, 4, 0x7fffffff, -0x80000000)
	  if (value < 0) value = 0xffffffff + value + 1
	  if (Buffer.TYPED_ARRAY_SUPPORT) {
	    this[offset] = (value >>> 24)
	    this[offset + 1] = (value >>> 16)
	    this[offset + 2] = (value >>> 8)
	    this[offset + 3] = value
	  } else {
	    objectWriteUInt32(this, value, offset, false)
	  }
	  return offset + 4
	}

	function checkIEEE754 (buf, value, offset, ext, max, min) {
	  if (value > max || value < min) throw new RangeError('value is out of bounds')
	  if (offset + ext > buf.length) throw new RangeError('index out of range')
	  if (offset < 0) throw new RangeError('index out of range')
	}

	function writeFloat (buf, value, offset, littleEndian, noAssert) {
	  if (!noAssert) {
	    checkIEEE754(buf, value, offset, 4, 3.4028234663852886e+38, -3.4028234663852886e+38)
	  }
	  ieee754.write(buf, value, offset, littleEndian, 23, 4)
	  return offset + 4
	}

	Buffer.prototype.writeFloatLE = function writeFloatLE (value, offset, noAssert) {
	  return writeFloat(this, value, offset, true, noAssert)
	}

	Buffer.prototype.writeFloatBE = function writeFloatBE (value, offset, noAssert) {
	  return writeFloat(this, value, offset, false, noAssert)
	}

	function writeDouble (buf, value, offset, littleEndian, noAssert) {
	  if (!noAssert) {
	    checkIEEE754(buf, value, offset, 8, 1.7976931348623157E+308, -1.7976931348623157E+308)
	  }
	  ieee754.write(buf, value, offset, littleEndian, 52, 8)
	  return offset + 8
	}

	Buffer.prototype.writeDoubleLE = function writeDoubleLE (value, offset, noAssert) {
	  return writeDouble(this, value, offset, true, noAssert)
	}

	Buffer.prototype.writeDoubleBE = function writeDoubleBE (value, offset, noAssert) {
	  return writeDouble(this, value, offset, false, noAssert)
	}

	// copy(targetBuffer, targetStart=0, sourceStart=0, sourceEnd=buffer.length)
	Buffer.prototype.copy = function copy (target, targetStart, start, end) {
	  if (!start) start = 0
	  if (!end && end !== 0) end = this.length
	  if (targetStart >= target.length) targetStart = target.length
	  if (!targetStart) targetStart = 0
	  if (end > 0 && end < start) end = start

	  // Copy 0 bytes; we're done
	  if (end === start) return 0
	  if (target.length === 0 || this.length === 0) return 0

	  // Fatal error conditions
	  if (targetStart < 0) {
	    throw new RangeError('targetStart out of bounds')
	  }
	  if (start < 0 || start >= this.length) throw new RangeError('sourceStart out of bounds')
	  if (end < 0) throw new RangeError('sourceEnd out of bounds')

	  // Are we oob?
	  if (end > this.length) end = this.length
	  if (target.length - targetStart < end - start) {
	    end = target.length - targetStart + start
	  }

	  var len = end - start

	  if (len < 1000 || !Buffer.TYPED_ARRAY_SUPPORT) {
	    for (var i = 0; i < len; i++) {
	      target[i + targetStart] = this[i + start]
	    }
	  } else {
	    target._set(this.subarray(start, start + len), targetStart)
	  }

	  return len
	}

	// fill(value, start=0, end=buffer.length)
	Buffer.prototype.fill = function fill (value, start, end) {
	  if (!value) value = 0
	  if (!start) start = 0
	  if (!end) end = this.length

	  if (end < start) throw new RangeError('end < start')

	  // Fill 0 bytes; we're done
	  if (end === start) return
	  if (this.length === 0) return

	  if (start < 0 || start >= this.length) throw new RangeError('start out of bounds')
	  if (end < 0 || end > this.length) throw new RangeError('end out of bounds')

	  var i
	  if (typeof value === 'number') {
	    for (i = start; i < end; i++) {
	      this[i] = value
	    }
	  } else {
	    var bytes = utf8ToBytes(value.toString())
	    var len = bytes.length
	    for (i = start; i < end; i++) {
	      this[i] = bytes[i % len]
	    }
	  }

	  return this
	}

	/**
	 * Creates a new `ArrayBuffer` with the *copied* memory of the buffer instance.
	 * Added in Node 0.12. Only available in browsers that support ArrayBuffer.
	 */
	Buffer.prototype.toArrayBuffer = function toArrayBuffer () {
	  if (typeof Uint8Array !== 'undefined') {
	    if (Buffer.TYPED_ARRAY_SUPPORT) {
	      return (new Buffer(this)).buffer
	    } else {
	      var buf = new Uint8Array(this.length)
	      for (var i = 0, len = buf.length; i < len; i += 1) {
	        buf[i] = this[i]
	      }
	      return buf.buffer
	    }
	  } else {
	    throw new TypeError('Buffer.toArrayBuffer not supported in this browser')
	  }
	}

	// HELPER FUNCTIONS
	// ================

	var BP = Buffer.prototype

	/**
	 * Augment a Uint8Array *instance* (not the Uint8Array class!) with Buffer methods
	 */
	Buffer._augment = function _augment (arr) {
	  arr.constructor = Buffer
	  arr._isBuffer = true

	  // save reference to original Uint8Array set method before overwriting
	  arr._set = arr.set

	  // deprecated
	  arr.get = BP.get
	  arr.set = BP.set

	  arr.write = BP.write
	  arr.toString = BP.toString
	  arr.toLocaleString = BP.toString
	  arr.toJSON = BP.toJSON
	  arr.equals = BP.equals
	  arr.compare = BP.compare
	  arr.indexOf = BP.indexOf
	  arr.copy = BP.copy
	  arr.slice = BP.slice
	  arr.readUIntLE = BP.readUIntLE
	  arr.readUIntBE = BP.readUIntBE
	  arr.readUInt8 = BP.readUInt8
	  arr.readUInt16LE = BP.readUInt16LE
	  arr.readUInt16BE = BP.readUInt16BE
	  arr.readUInt32LE = BP.readUInt32LE
	  arr.readUInt32BE = BP.readUInt32BE
	  arr.readIntLE = BP.readIntLE
	  arr.readIntBE = BP.readIntBE
	  arr.readInt8 = BP.readInt8
	  arr.readInt16LE = BP.readInt16LE
	  arr.readInt16BE = BP.readInt16BE
	  arr.readInt32LE = BP.readInt32LE
	  arr.readInt32BE = BP.readInt32BE
	  arr.readFloatLE = BP.readFloatLE
	  arr.readFloatBE = BP.readFloatBE
	  arr.readDoubleLE = BP.readDoubleLE
	  arr.readDoubleBE = BP.readDoubleBE
	  arr.writeUInt8 = BP.writeUInt8
	  arr.writeUIntLE = BP.writeUIntLE
	  arr.writeUIntBE = BP.writeUIntBE
	  arr.writeUInt16LE = BP.writeUInt16LE
	  arr.writeUInt16BE = BP.writeUInt16BE
	  arr.writeUInt32LE = BP.writeUInt32LE
	  arr.writeUInt32BE = BP.writeUInt32BE
	  arr.writeIntLE = BP.writeIntLE
	  arr.writeIntBE = BP.writeIntBE
	  arr.writeInt8 = BP.writeInt8
	  arr.writeInt16LE = BP.writeInt16LE
	  arr.writeInt16BE = BP.writeInt16BE
	  arr.writeInt32LE = BP.writeInt32LE
	  arr.writeInt32BE = BP.writeInt32BE
	  arr.writeFloatLE = BP.writeFloatLE
	  arr.writeFloatBE = BP.writeFloatBE
	  arr.writeDoubleLE = BP.writeDoubleLE
	  arr.writeDoubleBE = BP.writeDoubleBE
	  arr.fill = BP.fill
	  arr.inspect = BP.inspect
	  arr.toArrayBuffer = BP.toArrayBuffer

	  return arr
	}

	var INVALID_BASE64_RE = /[^+\/0-9A-Za-z-_]/g

	function base64clean (str) {
	  // Node strips out invalid characters like \n and \t from the string, base64-js does not
	  str = stringtrim(str).replace(INVALID_BASE64_RE, '')
	  // Node converts strings with length < 2 to ''
	  if (str.length < 2) return ''
	  // Node allows for non-padded base64 strings (missing trailing ===), base64-js does not
	  while (str.length % 4 !== 0) {
	    str = str + '='
	  }
	  return str
	}

	function stringtrim (str) {
	  if (str.trim) return str.trim()
	  return str.replace(/^\s+|\s+$/g, '')
	}

	function toHex (n) {
	  if (n < 16) return '0' + n.toString(16)
	  return n.toString(16)
	}

	function utf8ToBytes (string, units) {
	  units = units || Infinity
	  var codePoint
	  var length = string.length
	  var leadSurrogate = null
	  var bytes = []
	  var i = 0

	  for (; i < length; i++) {
	    codePoint = string.charCodeAt(i)

	    // is surrogate component
	    if (codePoint > 0xD7FF && codePoint < 0xE000) {
	      // last char was a lead
	      if (leadSurrogate) {
	        // 2 leads in a row
	        if (codePoint < 0xDC00) {
	          if ((units -= 3) > -1) bytes.push(0xEF, 0xBF, 0xBD)
	          leadSurrogate = codePoint
	          continue
	        } else {
	          // valid surrogate pair
	          codePoint = leadSurrogate - 0xD800 << 10 | codePoint - 0xDC00 | 0x10000
	          leadSurrogate = null
	        }
	      } else {
	        // no lead yet

	        if (codePoint > 0xDBFF) {
	          // unexpected trail
	          if ((units -= 3) > -1) bytes.push(0xEF, 0xBF, 0xBD)
	          continue
	        } else if (i + 1 === length) {
	          // unpaired lead
	          if ((units -= 3) > -1) bytes.push(0xEF, 0xBF, 0xBD)
	          continue
	        } else {
	          // valid lead
	          leadSurrogate = codePoint
	          continue
	        }
	      }
	    } else if (leadSurrogate) {
	      // valid bmp char, but last char was a lead
	      if ((units -= 3) > -1) bytes.push(0xEF, 0xBF, 0xBD)
	      leadSurrogate = null
	    }

	    // encode utf8
	    if (codePoint < 0x80) {
	      if ((units -= 1) < 0) break
	      bytes.push(codePoint)
	    } else if (codePoint < 0x800) {
	      if ((units -= 2) < 0) break
	      bytes.push(
	        codePoint >> 0x6 | 0xC0,
	        codePoint & 0x3F | 0x80
	      )
	    } else if (codePoint < 0x10000) {
	      if ((units -= 3) < 0) break
	      bytes.push(
	        codePoint >> 0xC | 0xE0,
	        codePoint >> 0x6 & 0x3F | 0x80,
	        codePoint & 0x3F | 0x80
	      )
	    } else if (codePoint < 0x200000) {
	      if ((units -= 4) < 0) break
	      bytes.push(
	        codePoint >> 0x12 | 0xF0,
	        codePoint >> 0xC & 0x3F | 0x80,
	        codePoint >> 0x6 & 0x3F | 0x80,
	        codePoint & 0x3F | 0x80
	      )
	    } else {
	      throw new Error('Invalid code point')
	    }
	  }

	  return bytes
	}

	function asciiToBytes (str) {
	  var byteArray = []
	  for (var i = 0; i < str.length; i++) {
	    // Node's code seems to be doing this and not & 0x7F..
	    byteArray.push(str.charCodeAt(i) & 0xFF)
	  }
	  return byteArray
	}

	function utf16leToBytes (str, units) {
	  var c, hi, lo
	  var byteArray = []
	  for (var i = 0; i < str.length; i++) {
	    if ((units -= 2) < 0) break

	    c = str.charCodeAt(i)
	    hi = c >> 8
	    lo = c % 256
	    byteArray.push(lo)
	    byteArray.push(hi)
	  }

	  return byteArray
	}

	function base64ToBytes (str) {
	  return base64.toByteArray(base64clean(str))
	}

	function blitBuffer (src, dst, offset, length) {
	  for (var i = 0; i < length; i++) {
	    if ((i + offset >= dst.length) || (i >= src.length)) break
	    dst[i + offset] = src[i]
	  }
	  return i
	}

	function decodeUtf8Char (str) {
	  try {
	    return decodeURIComponent(str)
	  } catch (err) {
	    return String.fromCharCode(0xFFFD) // UTF 8 invalid char
	  }
	}

	/* WEBPACK VAR INJECTION */}.call(exports, __webpack_require__(30).Buffer))

/***/ },
/* 31 */
/***/ function(module, exports, __webpack_require__) {

	var lookup = 'ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/';

	;(function (exports) {
		'use strict';

	  var Arr = (typeof Uint8Array !== 'undefined')
	    ? Uint8Array
	    : Array

		var PLUS   = '+'.charCodeAt(0)
		var SLASH  = '/'.charCodeAt(0)
		var NUMBER = '0'.charCodeAt(0)
		var LOWER  = 'a'.charCodeAt(0)
		var UPPER  = 'A'.charCodeAt(0)
		var PLUS_URL_SAFE = '-'.charCodeAt(0)
		var SLASH_URL_SAFE = '_'.charCodeAt(0)

		function decode (elt) {
			var code = elt.charCodeAt(0)
			if (code === PLUS ||
			    code === PLUS_URL_SAFE)
				return 62 // '+'
			if (code === SLASH ||
			    code === SLASH_URL_SAFE)
				return 63 // '/'
			if (code < NUMBER)
				return -1 //no match
			if (code < NUMBER + 10)
				return code - NUMBER + 26 + 26
			if (code < UPPER + 26)
				return code - UPPER
			if (code < LOWER + 26)
				return code - LOWER + 26
		}

		function b64ToByteArray (b64) {
			var i, j, l, tmp, placeHolders, arr

			if (b64.length % 4 > 0) {
				throw new Error('Invalid string. Length must be a multiple of 4')
			}

			// the number of equal signs (place holders)
			// if there are two placeholders, than the two characters before it
			// represent one byte
			// if there is only one, then the three characters before it represent 2 bytes
			// this is just a cheap hack to not do indexOf twice
			var len = b64.length
			placeHolders = '=' === b64.charAt(len - 2) ? 2 : '=' === b64.charAt(len - 1) ? 1 : 0

			// base64 is 4/3 + up to two characters of the original data
			arr = new Arr(b64.length * 3 / 4 - placeHolders)

			// if there are placeholders, only get up to the last complete 4 chars
			l = placeHolders > 0 ? b64.length - 4 : b64.length

			var L = 0

			function push (v) {
				arr[L++] = v
			}

			for (i = 0, j = 0; i < l; i += 4, j += 3) {
				tmp = (decode(b64.charAt(i)) << 18) | (decode(b64.charAt(i + 1)) << 12) | (decode(b64.charAt(i + 2)) << 6) | decode(b64.charAt(i + 3))
				push((tmp & 0xFF0000) >> 16)
				push((tmp & 0xFF00) >> 8)
				push(tmp & 0xFF)
			}

			if (placeHolders === 2) {
				tmp = (decode(b64.charAt(i)) << 2) | (decode(b64.charAt(i + 1)) >> 4)
				push(tmp & 0xFF)
			} else if (placeHolders === 1) {
				tmp = (decode(b64.charAt(i)) << 10) | (decode(b64.charAt(i + 1)) << 4) | (decode(b64.charAt(i + 2)) >> 2)
				push((tmp >> 8) & 0xFF)
				push(tmp & 0xFF)
			}

			return arr
		}

		function uint8ToBase64 (uint8) {
			var i,
				extraBytes = uint8.length % 3, // if we have 1 byte left, pad 2 bytes
				output = "",
				temp, length

			function encode (num) {
				return lookup.charAt(num)
			}

			function tripletToBase64 (num) {
				return encode(num >> 18 & 0x3F) + encode(num >> 12 & 0x3F) + encode(num >> 6 & 0x3F) + encode(num & 0x3F)
			}

			// go through the array every three bytes, we'll deal with trailing stuff later
			for (i = 0, length = uint8.length - extraBytes; i < length; i += 3) {
				temp = (uint8[i] << 16) + (uint8[i + 1] << 8) + (uint8[i + 2])
				output += tripletToBase64(temp)
			}

			// pad the end with zeros, but make sure to not forget the extra bytes
			switch (extraBytes) {
				case 1:
					temp = uint8[uint8.length - 1]
					output += encode(temp >> 2)
					output += encode((temp << 4) & 0x3F)
					output += '=='
					break
				case 2:
					temp = (uint8[uint8.length - 2] << 8) + (uint8[uint8.length - 1])
					output += encode(temp >> 10)
					output += encode((temp >> 4) & 0x3F)
					output += encode((temp << 2) & 0x3F)
					output += '='
					break
			}

			return output
		}

		exports.toByteArray = b64ToByteArray
		exports.fromByteArray = uint8ToBase64
	}( false ? (this.base64js = {}) : exports))


/***/ },
/* 32 */
/***/ function(module, exports) {

	exports.read = function (buffer, offset, isLE, mLen, nBytes) {
	  var e, m
	  var eLen = nBytes * 8 - mLen - 1
	  var eMax = (1 << eLen) - 1
	  var eBias = eMax >> 1
	  var nBits = -7
	  var i = isLE ? (nBytes - 1) : 0
	  var d = isLE ? -1 : 1
	  var s = buffer[offset + i]

	  i += d

	  e = s & ((1 << (-nBits)) - 1)
	  s >>= (-nBits)
	  nBits += eLen
	  for (; nBits > 0; e = e * 256 + buffer[offset + i], i += d, nBits -= 8) {}

	  m = e & ((1 << (-nBits)) - 1)
	  e >>= (-nBits)
	  nBits += mLen
	  for (; nBits > 0; m = m * 256 + buffer[offset + i], i += d, nBits -= 8) {}

	  if (e === 0) {
	    e = 1 - eBias
	  } else if (e === eMax) {
	    return m ? NaN : ((s ? -1 : 1) * Infinity)
	  } else {
	    m = m + Math.pow(2, mLen)
	    e = e - eBias
	  }
	  return (s ? -1 : 1) * m * Math.pow(2, e - mLen)
	}

	exports.write = function (buffer, value, offset, isLE, mLen, nBytes) {
	  var e, m, c
	  var eLen = nBytes * 8 - mLen - 1
	  var eMax = (1 << eLen) - 1
	  var eBias = eMax >> 1
	  var rt = (mLen === 23 ? Math.pow(2, -24) - Math.pow(2, -77) : 0)
	  var i = isLE ? 0 : (nBytes - 1)
	  var d = isLE ? 1 : -1
	  var s = value < 0 || (value === 0 && 1 / value < 0) ? 1 : 0

	  value = Math.abs(value)

	  if (isNaN(value) || value === Infinity) {
	    m = isNaN(value) ? 1 : 0
	    e = eMax
	  } else {
	    e = Math.floor(Math.log(value) / Math.LN2)
	    if (value * (c = Math.pow(2, -e)) < 1) {
	      e--
	      c *= 2
	    }
	    if (e + eBias >= 1) {
	      value += rt / c
	    } else {
	      value += rt * Math.pow(2, 1 - eBias)
	    }
	    if (value * c >= 2) {
	      e++
	      c /= 2
	    }

	    if (e + eBias >= eMax) {
	      m = 0
	      e = eMax
	    } else if (e + eBias >= 1) {
	      m = (value * c - 1) * Math.pow(2, mLen)
	      e = e + eBias
	    } else {
	      m = value * Math.pow(2, eBias - 1) * Math.pow(2, mLen)
	      e = 0
	    }
	  }

	  for (; mLen >= 8; buffer[offset + i] = m & 0xff, i += d, m /= 256, mLen -= 8) {}

	  e = (e << mLen) | m
	  eLen += mLen
	  for (; eLen > 0; buffer[offset + i] = e & 0xff, i += d, e /= 256, eLen -= 8) {}

	  buffer[offset + i - d] |= s * 128
	}


/***/ },
/* 33 */
/***/ function(module, exports) {

	
	/**
	 * isArray
	 */

	var isArray = Array.isArray;

	/**
	 * toString
	 */

	var str = Object.prototype.toString;

	/**
	 * Whether or not the given `val`
	 * is an array.
	 *
	 * example:
	 *
	 *        isArray([]);
	 *        // > true
	 *        isArray(arguments);
	 *        // > false
	 *        isArray('');
	 *        // > false
	 *
	 * @param {mixed} val
	 * @return {bool}
	 */

	module.exports = isArray || function (val) {
	  return !! val && '[object Array]' == str.call(val);
	};


/***/ },
/* 34 */
/***/ function(module, exports, __webpack_require__) {

	/*!
	 * Chai - getPathValue utility
	 * Copyright(c) 2012-2014 Jake Luer <jake@alogicalparadox.com>
	 * @see https://github.com/logicalparadox/filtr
	 * MIT Licensed
	 */

	var getPathInfo = __webpack_require__(35);

	/**
	 * ### .getPathValue(path, object)
	 *
	 * This allows the retrieval of values in an
	 * object given a string path.
	 *
	 *     var obj = {
	 *         prop1: {
	 *             arr: ['a', 'b', 'c']
	 *           , str: 'Hello'
	 *         }
	 *       , prop2: {
	 *             arr: [ { nested: 'Universe' } ]
	 *           , str: 'Hello again!'
	 *         }
	 *     }
	 *
	 * The following would be the results.
	 *
	 *     getPathValue('prop1.str', obj); // Hello
	 *     getPathValue('prop1.att[2]', obj); // b
	 *     getPathValue('prop2.arr[0].nested', obj); // Universe
	 *
	 * @param {String} path
	 * @param {Object} object
	 * @returns {Object} value or `undefined`
	 * @name getPathValue
	 * @api public
	 */
	module.exports = function(path, obj) {
	  var info = getPathInfo(path, obj);
	  return info.value;
	}; 


/***/ },
/* 35 */
/***/ function(module, exports, __webpack_require__) {

	/*!
	 * Chai - getPathInfo utility
	 * Copyright(c) 2012-2014 Jake Luer <jake@alogicalparadox.com>
	 * MIT Licensed
	 */

	var hasProperty = __webpack_require__(36);

	/**
	 * ### .getPathInfo(path, object)
	 *
	 * This allows the retrieval of property info in an
	 * object given a string path.
	 *
	 * The path info consists of an object with the
	 * following properties:
	 *
	 * * parent - The parent object of the property referenced by `path`
	 * * name - The name of the final property, a number if it was an array indexer
	 * * value - The value of the property, if it exists, otherwise `undefined`
	 * * exists - Whether the property exists or not
	 *
	 * @param {String} path
	 * @param {Object} object
	 * @returns {Object} info
	 * @name getPathInfo
	 * @api public
	 */

	module.exports = function getPathInfo(path, obj) {
	  var parsed = parsePath(path),
	      last = parsed[parsed.length - 1];

	  var info = {
	    parent: parsed.length > 1 ? _getPathValue(parsed, obj, parsed.length - 1) : obj,
	    name: last.p || last.i,
	    value: _getPathValue(parsed, obj),
	  };
	  info.exists = hasProperty(info.name, info.parent);

	  return info;
	};


	/*!
	 * ## parsePath(path)
	 *
	 * Helper function used to parse string object
	 * paths. Use in conjunction with `_getPathValue`.
	 *
	 *      var parsed = parsePath('myobject.property.subprop');
	 *
	 * ### Paths:
	 *
	 * * Can be as near infinitely deep and nested
	 * * Arrays are also valid using the formal `myobject.document[3].property`.
	 * * Literal dots and brackets (not delimiter) must be backslash-escaped.
	 *
	 * @param {String} path
	 * @returns {Object} parsed
	 * @api private
	 */

	function parsePath (path) {
	  var str = path.replace(/([^\\])\[/g, '$1.[')
	    , parts = str.match(/(\\\.|[^.]+?)+/g);
	  return parts.map(function (value) {
	    var re = /^\[(\d+)\]$/
	      , mArr = re.exec(value);
	    if (mArr) return { i: parseFloat(mArr[1]) };
	    else return { p: value.replace(/\\([.\[\]])/g, '$1') };
	  });
	}


	/*!
	 * ## _getPathValue(parsed, obj)
	 *
	 * Helper companion function for `.parsePath` that returns
	 * the value located at the parsed address.
	 *
	 *      var value = getPathValue(parsed, obj);
	 *
	 * @param {Object} parsed definition from `parsePath`.
	 * @param {Object} object to search against
	 * @param {Number} object to search against
	 * @returns {Object|Undefined} value
	 * @api private
	 */

	function _getPathValue (parsed, obj, index) {
	  var tmp = obj
	    , res;

	  index = (index === undefined ? parsed.length : index);

	  for (var i = 0, l = index; i < l; i++) {
	    var part = parsed[i];
	    if (tmp) {
	      if ('undefined' !== typeof part.p)
	        tmp = tmp[part.p];
	      else if ('undefined' !== typeof part.i)
	        tmp = tmp[part.i];
	      if (i == (l - 1)) res = tmp;
	    } else {
	      res = undefined;
	    }
	  }
	  return res;
	}


/***/ },
/* 36 */
/***/ function(module, exports, __webpack_require__) {

	/*!
	 * Chai - hasProperty utility
	 * Copyright(c) 2012-2014 Jake Luer <jake@alogicalparadox.com>
	 * MIT Licensed
	 */

	var type = __webpack_require__(16);

	/**
	 * ### .hasProperty(object, name)
	 *
	 * This allows checking whether an object has
	 * named property or numeric array index.
	 *
	 * Basically does the same thing as the `in`
	 * operator but works properly with natives
	 * and null/undefined values.
	 *
	 *     var obj = {
	 *         arr: ['a', 'b', 'c']
	 *       , str: 'Hello'
	 *     }
	 *
	 * The following would be the results.
	 *
	 *     hasProperty('str', obj);  // true
	 *     hasProperty('constructor', obj);  // true
	 *     hasProperty('bar', obj);  // false
	 *     
	 *     hasProperty('length', obj.str); // true
	 *     hasProperty(1, obj.str);  // true
	 *     hasProperty(5, obj.str);  // false
	 *
	 *     hasProperty('length', obj.arr);  // true
	 *     hasProperty(2, obj.arr);  // true
	 *     hasProperty(3, obj.arr);  // false
	 *
	 * @param {Objuect} object
	 * @param {String|Number} name
	 * @returns {Boolean} whether it exists
	 * @name getPathInfo
	 * @api public
	 */

	var literals = {
	    'number': Number
	  , 'string': String
	};

	module.exports = function hasProperty(name, obj) {
	  var ot = type(obj);

	  // Bad Object, obviously no props at all
	  if(ot === 'null' || ot === 'undefined')
	    return false;

	  // The `in` operator does not work with certain literals
	  // box these before the check
	  if(literals[ot] && typeof obj !== 'object')
	    obj = new literals[ot](obj);

	  return name in obj;
	};


/***/ },
/* 37 */
/***/ function(module, exports) {

	/*!
	 * Chai - addProperty utility
	 * Copyright(c) 2012-2014 Jake Luer <jake@alogicalparadox.com>
	 * MIT Licensed
	 */

	/**
	 * ### addProperty (ctx, name, getter)
	 *
	 * Adds a property to the prototype of an object.
	 *
	 *     utils.addProperty(chai.Assertion.prototype, 'foo', function () {
	 *       var obj = utils.flag(this, 'object');
	 *       new chai.Assertion(obj).to.be.instanceof(Foo);
	 *     });
	 *
	 * Can also be accessed directly from `chai.Assertion`.
	 *
	 *     chai.Assertion.addProperty('foo', fn);
	 *
	 * Then can be used as any other assertion.
	 *
	 *     expect(myFoo).to.be.foo;
	 *
	 * @param {Object} ctx object to which the property is added
	 * @param {String} name of property to add
	 * @param {Function} getter function to be used for name
	 * @name addProperty
	 * @api public
	 */

	module.exports = function (ctx, name, getter) {
	  Object.defineProperty(ctx, name,
	    { get: function () {
	        var result = getter.call(this);
	        return result === undefined ? this : result;
	      }
	    , configurable: true
	  });
	};


/***/ },
/* 38 */
/***/ function(module, exports, __webpack_require__) {

	/*!
	 * Chai - addMethod utility
	 * Copyright(c) 2012-2014 Jake Luer <jake@alogicalparadox.com>
	 * MIT Licensed
	 */

	var config = __webpack_require__(24);

	/**
	 * ### .addMethod (ctx, name, method)
	 *
	 * Adds a method to the prototype of an object.
	 *
	 *     utils.addMethod(chai.Assertion.prototype, 'foo', function (str) {
	 *       var obj = utils.flag(this, 'object');
	 *       new chai.Assertion(obj).to.be.equal(str);
	 *     });
	 *
	 * Can also be accessed directly from `chai.Assertion`.
	 *
	 *     chai.Assertion.addMethod('foo', fn);
	 *
	 * Then can be used as any other assertion.
	 *
	 *     expect(fooStr).to.be.foo('bar');
	 *
	 * @param {Object} ctx object to which the method is added
	 * @param {String} name of method to add
	 * @param {Function} method function to be used for name
	 * @name addMethod
	 * @api public
	 */
	var flag = __webpack_require__(15);

	module.exports = function (ctx, name, method) {
	  ctx[name] = function () {
	    var old_ssfi = flag(this, 'ssfi');
	    if (old_ssfi && config.includeStack === false)
	      flag(this, 'ssfi', ctx[name]);
	    var result = method.apply(this, arguments);
	    return result === undefined ? this : result;
	  };
	};


/***/ },
/* 39 */
/***/ function(module, exports) {

	/*!
	 * Chai - overwriteProperty utility
	 * Copyright(c) 2012-2014 Jake Luer <jake@alogicalparadox.com>
	 * MIT Licensed
	 */

	/**
	 * ### overwriteProperty (ctx, name, fn)
	 *
	 * Overwites an already existing property getter and provides
	 * access to previous value. Must return function to use as getter.
	 *
	 *     utils.overwriteProperty(chai.Assertion.prototype, 'ok', function (_super) {
	 *       return function () {
	 *         var obj = utils.flag(this, 'object');
	 *         if (obj instanceof Foo) {
	 *           new chai.Assertion(obj.name).to.equal('bar');
	 *         } else {
	 *           _super.call(this);
	 *         }
	 *       }
	 *     });
	 *
	 *
	 * Can also be accessed directly from `chai.Assertion`.
	 *
	 *     chai.Assertion.overwriteProperty('foo', fn);
	 *
	 * Then can be used as any other assertion.
	 *
	 *     expect(myFoo).to.be.ok;
	 *
	 * @param {Object} ctx object whose property is to be overwritten
	 * @param {String} name of property to overwrite
	 * @param {Function} getter function that returns a getter function to be used for name
	 * @name overwriteProperty
	 * @api public
	 */

	module.exports = function (ctx, name, getter) {
	  var _get = Object.getOwnPropertyDescriptor(ctx, name)
	    , _super = function () {};

	  if (_get && 'function' === typeof _get.get)
	    _super = _get.get

	  Object.defineProperty(ctx, name,
	    { get: function () {
	        var result = getter(_super).call(this);
	        return result === undefined ? this : result;
	      }
	    , configurable: true
	  });
	};


/***/ },
/* 40 */
/***/ function(module, exports) {

	/*!
	 * Chai - overwriteMethod utility
	 * Copyright(c) 2012-2014 Jake Luer <jake@alogicalparadox.com>
	 * MIT Licensed
	 */

	/**
	 * ### overwriteMethod (ctx, name, fn)
	 *
	 * Overwites an already existing method and provides
	 * access to previous function. Must return function
	 * to be used for name.
	 *
	 *     utils.overwriteMethod(chai.Assertion.prototype, 'equal', function (_super) {
	 *       return function (str) {
	 *         var obj = utils.flag(this, 'object');
	 *         if (obj instanceof Foo) {
	 *           new chai.Assertion(obj.value).to.equal(str);
	 *         } else {
	 *           _super.apply(this, arguments);
	 *         }
	 *       }
	 *     });
	 *
	 * Can also be accessed directly from `chai.Assertion`.
	 *
	 *     chai.Assertion.overwriteMethod('foo', fn);
	 *
	 * Then can be used as any other assertion.
	 *
	 *     expect(myFoo).to.equal('bar');
	 *
	 * @param {Object} ctx object whose method is to be overwritten
	 * @param {String} name of method to overwrite
	 * @param {Function} method function that returns a function to be used for name
	 * @name overwriteMethod
	 * @api public
	 */

	module.exports = function (ctx, name, method) {
	  var _method = ctx[name]
	    , _super = function () { return this; };

	  if (_method && 'function' === typeof _method)
	    _super = _method;

	  ctx[name] = function () {
	    var result = method(_super).apply(this, arguments);
	    return result === undefined ? this : result;
	  }
	};


/***/ },
/* 41 */
/***/ function(module, exports, __webpack_require__) {

	/*!
	 * Chai - addChainingMethod utility
	 * Copyright(c) 2012-2014 Jake Luer <jake@alogicalparadox.com>
	 * MIT Licensed
	 */

	/*!
	 * Module dependencies
	 */

	var transferFlags = __webpack_require__(25);
	var flag = __webpack_require__(15);
	var config = __webpack_require__(24);

	/*!
	 * Module variables
	 */

	// Check whether `__proto__` is supported
	var hasProtoSupport = '__proto__' in Object;

	// Without `__proto__` support, this module will need to add properties to a function.
	// However, some Function.prototype methods cannot be overwritten,
	// and there seems no easy cross-platform way to detect them (@see chaijs/chai/issues/69).
	var excludeNames = /^(?:length|name|arguments|caller)$/;

	// Cache `Function` properties
	var call  = Function.prototype.call,
	    apply = Function.prototype.apply;

	/**
	 * ### addChainableMethod (ctx, name, method, chainingBehavior)
	 *
	 * Adds a method to an object, such that the method can also be chained.
	 *
	 *     utils.addChainableMethod(chai.Assertion.prototype, 'foo', function (str) {
	 *       var obj = utils.flag(this, 'object');
	 *       new chai.Assertion(obj).to.be.equal(str);
	 *     });
	 *
	 * Can also be accessed directly from `chai.Assertion`.
	 *
	 *     chai.Assertion.addChainableMethod('foo', fn, chainingBehavior);
	 *
	 * The result can then be used as both a method assertion, executing both `method` and
	 * `chainingBehavior`, or as a language chain, which only executes `chainingBehavior`.
	 *
	 *     expect(fooStr).to.be.foo('bar');
	 *     expect(fooStr).to.be.foo.equal('foo');
	 *
	 * @param {Object} ctx object to which the method is added
	 * @param {String} name of method to add
	 * @param {Function} method function to be used for `name`, when called
	 * @param {Function} chainingBehavior function to be called every time the property is accessed
	 * @name addChainableMethod
	 * @api public
	 */

	module.exports = function (ctx, name, method, chainingBehavior) {
	  if (typeof chainingBehavior !== 'function') {
	    chainingBehavior = function () { };
	  }

	  var chainableBehavior = {
	      method: method
	    , chainingBehavior: chainingBehavior
	  };

	  // save the methods so we can overwrite them later, if we need to.
	  if (!ctx.__methods) {
	    ctx.__methods = {};
	  }
	  ctx.__methods[name] = chainableBehavior;

	  Object.defineProperty(ctx, name,
	    { get: function () {
	        chainableBehavior.chainingBehavior.call(this);

	        var assert = function assert() {
	          var old_ssfi = flag(this, 'ssfi');
	          if (old_ssfi && config.includeStack === false)
	            flag(this, 'ssfi', assert);
	          var result = chainableBehavior.method.apply(this, arguments);
	          return result === undefined ? this : result;
	        };

	        // Use `__proto__` if available
	        if (hasProtoSupport) {
	          // Inherit all properties from the object by replacing the `Function` prototype
	          var prototype = assert.__proto__ = Object.create(this);
	          // Restore the `call` and `apply` methods from `Function`
	          prototype.call = call;
	          prototype.apply = apply;
	        }
	        // Otherwise, redefine all properties (slow!)
	        else {
	          var asserterNames = Object.getOwnPropertyNames(ctx);
	          asserterNames.forEach(function (asserterName) {
	            if (!excludeNames.test(asserterName)) {
	              var pd = Object.getOwnPropertyDescriptor(ctx, asserterName);
	              Object.defineProperty(assert, asserterName, pd);
	            }
	          });
	        }

	        transferFlags(this, assert);
	        return assert;
	      }
	    , configurable: true
	  });
	};


/***/ },
/* 42 */
/***/ function(module, exports) {

	/*!
	 * Chai - overwriteChainableMethod utility
	 * Copyright(c) 2012-2014 Jake Luer <jake@alogicalparadox.com>
	 * MIT Licensed
	 */

	/**
	 * ### overwriteChainableMethod (ctx, name, method, chainingBehavior)
	 *
	 * Overwites an already existing chainable method
	 * and provides access to the previous function or
	 * property.  Must return functions to be used for
	 * name.
	 *
	 *     utils.overwriteChainableMethod(chai.Assertion.prototype, 'length',
	 *       function (_super) {
	 *       }
	 *     , function (_super) {
	 *       }
	 *     );
	 *
	 * Can also be accessed directly from `chai.Assertion`.
	 *
	 *     chai.Assertion.overwriteChainableMethod('foo', fn, fn);
	 *
	 * Then can be used as any other assertion.
	 *
	 *     expect(myFoo).to.have.length(3);
	 *     expect(myFoo).to.have.length.above(3);
	 *
	 * @param {Object} ctx object whose method / property is to be overwritten
	 * @param {String} name of method / property to overwrite
	 * @param {Function} method function that returns a function to be used for name
	 * @param {Function} chainingBehavior function that returns a function to be used for property
	 * @name overwriteChainableMethod
	 * @api public
	 */

	module.exports = function (ctx, name, method, chainingBehavior) {
	  var chainableBehavior = ctx.__methods[name];

	  var _chainingBehavior = chainableBehavior.chainingBehavior;
	  chainableBehavior.chainingBehavior = function () {
	    var result = chainingBehavior(_chainingBehavior).call(this);
	    return result === undefined ? this : result;
	  };

	  var _method = chainableBehavior.method;
	  chainableBehavior.method = function () {
	    var result = method(_method).apply(this, arguments);
	    return result === undefined ? this : result;
	  };
	};


/***/ },
/* 43 */
/***/ function(module, exports, __webpack_require__) {

	/*!
	 * chai
	 * http://chaijs.com
	 * Copyright(c) 2011-2014 Jake Luer <jake@alogicalparadox.com>
	 * MIT Licensed
	 */

	var config = __webpack_require__(24);

	module.exports = function (_chai, util) {
	  /*!
	   * Module dependencies.
	   */

	  var AssertionError = _chai.AssertionError
	    , flag = util.flag;

	  /*!
	   * Module export.
	   */

	  _chai.Assertion = Assertion;

	  /*!
	   * Assertion Constructor
	   *
	   * Creates object for chaining.
	   *
	   * @api private
	   */

	  function Assertion (obj, msg, stack) {
	    flag(this, 'ssfi', stack || arguments.callee);
	    flag(this, 'object', obj);
	    flag(this, 'message', msg);
	  }

	  Object.defineProperty(Assertion, 'includeStack', {
	    get: function() {
	      console.warn('Assertion.includeStack is deprecated, use chai.config.includeStack instead.');
	      return config.includeStack;
	    },
	    set: function(value) {
	      console.warn('Assertion.includeStack is deprecated, use chai.config.includeStack instead.');
	      config.includeStack = value;
	    }
	  });

	  Object.defineProperty(Assertion, 'showDiff', {
	    get: function() {
	      console.warn('Assertion.showDiff is deprecated, use chai.config.showDiff instead.');
	      return config.showDiff;
	    },
	    set: function(value) {
	      console.warn('Assertion.showDiff is deprecated, use chai.config.showDiff instead.');
	      config.showDiff = value;
	    }
	  });

	  Assertion.addProperty = function (name, fn) {
	    util.addProperty(this.prototype, name, fn);
	  };

	  Assertion.addMethod = function (name, fn) {
	    util.addMethod(this.prototype, name, fn);
	  };

	  Assertion.addChainableMethod = function (name, fn, chainingBehavior) {
	    util.addChainableMethod(this.prototype, name, fn, chainingBehavior);
	  };

	  Assertion.overwriteProperty = function (name, fn) {
	    util.overwriteProperty(this.prototype, name, fn);
	  };

	  Assertion.overwriteMethod = function (name, fn) {
	    util.overwriteMethod(this.prototype, name, fn);
	  };

	  Assertion.overwriteChainableMethod = function (name, fn, chainingBehavior) {
	    util.overwriteChainableMethod(this.prototype, name, fn, chainingBehavior);
	  };

	  /*!
	   * ### .assert(expression, message, negateMessage, expected, actual)
	   *
	   * Executes an expression and check expectations. Throws AssertionError for reporting if test doesn't pass.
	   *
	   * @name assert
	   * @param {Philosophical} expression to be tested
	   * @param {String or Function} message or function that returns message to display if expression fails
	   * @param {String or Function} negatedMessage or function that returns negatedMessage to display if negated expression fails
	   * @param {Mixed} expected value (remember to check for negation)
	   * @param {Mixed} actual (optional) will default to `this.obj`
	   * @param {Boolean} showDiff (optional) when set to `true`, assert will display a diff in addition to the message if expression fails
	   * @api private
	   */

	  Assertion.prototype.assert = function (expr, msg, negateMsg, expected, _actual, showDiff) {
	    var ok = util.test(this, arguments);
	    if (true !== showDiff) showDiff = false;
	    if (true !== config.showDiff) showDiff = false;

	    if (!ok) {
	      var msg = util.getMessage(this, arguments)
	        , actual = util.getActual(this, arguments);
	      throw new AssertionError(msg, {
	          actual: actual
	        , expected: expected
	        , showDiff: showDiff
	      }, (config.includeStack) ? this.assert : flag(this, 'ssfi'));
	    }
	  };

	  /*!
	   * ### ._obj
	   *
	   * Quick reference to stored `actual` value for plugin developers.
	   *
	   * @api private
	   */

	  Object.defineProperty(Assertion.prototype, '_obj',
	    { get: function () {
	        return flag(this, 'object');
	      }
	    , set: function (val) {
	        flag(this, 'object', val);
	      }
	  });
	};


/***/ },
/* 44 */
/***/ function(module, exports) {

	/*!
	 * chai
	 * Copyright(c) 2011-2014 Jake Luer <jake@alogicalparadox.com>
	 * MIT Licensed
	 */

	module.exports = function (chai, util) {
	  chai.expect = function (val, message) {
	    return new chai.Assertion(val, message);
	  };

	  /**
	   * ### .fail(actual, expected, [message], [operator])
	   *
	   * Throw a failure.
	   *
	   * @name fail
	   * @param {Mixed} actual
	   * @param {Mixed} expected
	   * @param {String} message
	   * @param {String} operator
	   * @api public
	   */

	  chai.expect.fail = function (actual, expected, message, operator) {
	    message = message || 'expect.fail()';
	    throw new chai.AssertionError(message, {
	        actual: actual
	      , expected: expected
	      , operator: operator
	    }, chai.expect.fail);
	  };
	};


/***/ },
/* 45 */
/***/ function(module, exports) {

	/*!
	 * chai
	 * Copyright(c) 2011-2014 Jake Luer <jake@alogicalparadox.com>
	 * MIT Licensed
	 */

	module.exports = function (chai, util) {
	  var Assertion = chai.Assertion;

	  function loadShould () {
	    // explicitly define this method as function as to have it's name to include as `ssfi`
	    function shouldGetter() {
	      if (this instanceof String || this instanceof Number || this instanceof Boolean ) {
	        return new Assertion(this.valueOf(), null, shouldGetter);
	      }
	      return new Assertion(this, null, shouldGetter);
	    }
	    function shouldSetter(value) {
	      // See https://github.com/chaijs/chai/issues/86: this makes
	      // `whatever.should = someValue` actually set `someValue`, which is
	      // especially useful for `global.should = require('chai').should()`.
	      //
	      // Note that we have to use [[DefineProperty]] instead of [[Put]]
	      // since otherwise we would trigger this very setter!
	      Object.defineProperty(this, 'should', {
	        value: value,
	        enumerable: true,
	        configurable: true,
	        writable: true
	      });
	    }
	    // modify Object.prototype to have `should`
	    Object.defineProperty(Object.prototype, 'should', {
	      set: shouldSetter
	      , get: shouldGetter
	      , configurable: true
	    });

	    var should = {};

	    /**
	     * ### .fail(actual, expected, [message], [operator])
	     *
	     * Throw a failure.
	     *
	     * @name fail
	     * @param {Mixed} actual
	     * @param {Mixed} expected
	     * @param {String} message
	     * @param {String} operator
	     * @api public
	     */

	    should.fail = function (actual, expected, message, operator) {
	      message = message || 'should.fail()';
	      throw new chai.AssertionError(message, {
	          actual: actual
	        , expected: expected
	        , operator: operator
	      }, should.fail);
	    };

	    should.equal = function (val1, val2, msg) {
	      new Assertion(val1, msg).to.equal(val2);
	    };

	    should.Throw = function (fn, errt, errs, msg) {
	      new Assertion(fn, msg).to.Throw(errt, errs);
	    };

	    should.exist = function (val, msg) {
	      new Assertion(val, msg).to.exist;
	    }

	    // negation
	    should.not = {}

	    should.not.equal = function (val1, val2, msg) {
	      new Assertion(val1, msg).to.not.equal(val2);
	    };

	    should.not.Throw = function (fn, errt, errs, msg) {
	      new Assertion(fn, msg).to.not.Throw(errt, errs);
	    };

	    should.not.exist = function (val, msg) {
	      new Assertion(val, msg).to.not.exist;
	    }

	    should['throw'] = should['Throw'];
	    should.not['throw'] = should.not['Throw'];

	    return should;
	  };

	  chai.should = loadShould;
	  chai.Should = loadShould;
	};


/***/ },
/* 46 */
/***/ function(module, exports) {

	/*!
	 * chai
	 * Copyright(c) 2011-2014 Jake Luer <jake@alogicalparadox.com>
	 * MIT Licensed
	 */


	module.exports = function (chai, util) {

	  /*!
	   * Chai dependencies.
	   */

	  var Assertion = chai.Assertion
	    , flag = util.flag;

	  /*!
	   * Module export.
	   */

	  /**
	   * ### assert(expression, message)
	   *
	   * Write your own test expressions.
	   *
	   *     assert('foo' !== 'bar', 'foo is not bar');
	   *     assert(Array.isArray([]), 'empty arrays are arrays');
	   *
	   * @param {Mixed} expression to test for truthiness
	   * @param {String} message to display on error
	   * @name assert
	   * @api public
	   */

	  var assert = chai.assert = function (express, errmsg) {
	    var test = new Assertion(null, null, chai.assert);
	    test.assert(
	        express
	      , errmsg
	      , '[ negation message unavailable ]'
	    );
	  };

	  /**
	   * ### .fail(actual, expected, [message], [operator])
	   *
	   * Throw a failure. Node.js `assert` module-compatible.
	   *
	   * @name fail
	   * @param {Mixed} actual
	   * @param {Mixed} expected
	   * @param {String} message
	   * @param {String} operator
	   * @api public
	   */

	  assert.fail = function (actual, expected, message, operator) {
	    message = message || 'assert.fail()';
	    throw new chai.AssertionError(message, {
	        actual: actual
	      , expected: expected
	      , operator: operator
	    }, assert.fail);
	  };

	  /**
	   * ### .ok(object, [message])
	   *
	   * Asserts that `object` is truthy.
	   *
	   *     assert.ok('everything', 'everything is ok');
	   *     assert.ok(false, 'this will fail');
	   *
	   * @name ok
	   * @param {Mixed} object to test
	   * @param {String} message
	   * @api public
	   */

	  assert.ok = function (val, msg) {
	    new Assertion(val, msg).is.ok;
	  };

	  /**
	   * ### .notOk(object, [message])
	   *
	   * Asserts that `object` is falsy.
	   *
	   *     assert.notOk('everything', 'this will fail');
	   *     assert.notOk(false, 'this will pass');
	   *
	   * @name notOk
	   * @param {Mixed} object to test
	   * @param {String} message
	   * @api public
	   */

	  assert.notOk = function (val, msg) {
	    new Assertion(val, msg).is.not.ok;
	  };

	  /**
	   * ### .equal(actual, expected, [message])
	   *
	   * Asserts non-strict equality (`==`) of `actual` and `expected`.
	   *
	   *     assert.equal(3, '3', '== coerces values to strings');
	   *
	   * @name equal
	   * @param {Mixed} actual
	   * @param {Mixed} expected
	   * @param {String} message
	   * @api public
	   */

	  assert.equal = function (act, exp, msg) {
	    var test = new Assertion(act, msg, assert.equal);

	    test.assert(
	        exp == flag(test, 'object')
	      , 'expected #{this} to equal #{exp}'
	      , 'expected #{this} to not equal #{act}'
	      , exp
	      , act
	    );
	  };

	  /**
	   * ### .notEqual(actual, expected, [message])
	   *
	   * Asserts non-strict inequality (`!=`) of `actual` and `expected`.
	   *
	   *     assert.notEqual(3, 4, 'these numbers are not equal');
	   *
	   * @name notEqual
	   * @param {Mixed} actual
	   * @param {Mixed} expected
	   * @param {String} message
	   * @api public
	   */

	  assert.notEqual = function (act, exp, msg) {
	    var test = new Assertion(act, msg, assert.notEqual);

	    test.assert(
	        exp != flag(test, 'object')
	      , 'expected #{this} to not equal #{exp}'
	      , 'expected #{this} to equal #{act}'
	      , exp
	      , act
	    );
	  };

	  /**
	   * ### .strictEqual(actual, expected, [message])
	   *
	   * Asserts strict equality (`===`) of `actual` and `expected`.
	   *
	   *     assert.strictEqual(true, true, 'these booleans are strictly equal');
	   *
	   * @name strictEqual
	   * @param {Mixed} actual
	   * @param {Mixed} expected
	   * @param {String} message
	   * @api public
	   */

	  assert.strictEqual = function (act, exp, msg) {
	    new Assertion(act, msg).to.equal(exp);
	  };

	  /**
	   * ### .notStrictEqual(actual, expected, [message])
	   *
	   * Asserts strict inequality (`!==`) of `actual` and `expected`.
	   *
	   *     assert.notStrictEqual(3, '3', 'no coercion for strict equality');
	   *
	   * @name notStrictEqual
	   * @param {Mixed} actual
	   * @param {Mixed} expected
	   * @param {String} message
	   * @api public
	   */

	  assert.notStrictEqual = function (act, exp, msg) {
	    new Assertion(act, msg).to.not.equal(exp);
	  };

	  /**
	   * ### .deepEqual(actual, expected, [message])
	   *
	   * Asserts that `actual` is deeply equal to `expected`.
	   *
	   *     assert.deepEqual({ tea: 'green' }, { tea: 'green' });
	   *
	   * @name deepEqual
	   * @param {Mixed} actual
	   * @param {Mixed} expected
	   * @param {String} message
	   * @api public
	   */

	  assert.deepEqual = function (act, exp, msg) {
	    new Assertion(act, msg).to.eql(exp);
	  };

	  /**
	   * ### .notDeepEqual(actual, expected, [message])
	   *
	   * Assert that `actual` is not deeply equal to `expected`.
	   *
	   *     assert.notDeepEqual({ tea: 'green' }, { tea: 'jasmine' });
	   *
	   * @name notDeepEqual
	   * @param {Mixed} actual
	   * @param {Mixed} expected
	   * @param {String} message
	   * @api public
	   */

	  assert.notDeepEqual = function (act, exp, msg) {
	    new Assertion(act, msg).to.not.eql(exp);
	  };

	  /**
	   * ### .isTrue(value, [message])
	   *
	   * Asserts that `value` is true.
	   *
	   *     var teaServed = true;
	   *     assert.isTrue(teaServed, 'the tea has been served');
	   *
	   * @name isTrue
	   * @param {Mixed} value
	   * @param {String} message
	   * @api public
	   */

	  assert.isAbove = function (val, abv, msg) {
	    new Assertion(val, msg).to.be.above(abv);
	  };

	   /**
	   * ### .isAbove(valueToCheck, valueToBeAbove, [message])
	   *
	   * Asserts `valueToCheck` is strictly greater than (>) `valueToBeAbove`
	   *
	   *     assert.isAbove(5, 2, '5 is strictly greater than 2');
	   *
	   * @name isAbove
	   * @param {Mixed} valueToCheck
	   * @param {Mixed} valueToBeAbove
	   * @param {String} message
	   * @api public
	   */

	  assert.isBelow = function (val, blw, msg) {
	    new Assertion(val, msg).to.be.below(blw);
	  };

	   /**
	   * ### .isBelow(valueToCheck, valueToBeBelow, [message])
	   *
	   * Asserts `valueToCheck` is strictly less than (<) `valueToBeBelow`
	   *
	   *     assert.isBelow(3, 6, '3 is strictly less than 6');
	   *
	   * @name isBelow
	   * @param {Mixed} valueToCheck
	   * @param {Mixed} valueToBeBelow
	   * @param {String} message
	   * @api public
	   */

	  assert.isTrue = function (val, msg) {
	    new Assertion(val, msg).is['true'];
	  };

	  /**
	   * ### .isFalse(value, [message])
	   *
	   * Asserts that `value` is false.
	   *
	   *     var teaServed = false;
	   *     assert.isFalse(teaServed, 'no tea yet? hmm...');
	   *
	   * @name isFalse
	   * @param {Mixed} value
	   * @param {String} message
	   * @api public
	   */

	  assert.isFalse = function (val, msg) {
	    new Assertion(val, msg).is['false'];
	  };

	  /**
	   * ### .isNull(value, [message])
	   *
	   * Asserts that `value` is null.
	   *
	   *     assert.isNull(err, 'there was no error');
	   *
	   * @name isNull
	   * @param {Mixed} value
	   * @param {String} message
	   * @api public
	   */

	  assert.isNull = function (val, msg) {
	    new Assertion(val, msg).to.equal(null);
	  };

	  /**
	   * ### .isNotNull(value, [message])
	   *
	   * Asserts that `value` is not null.
	   *
	   *     var tea = 'tasty chai';
	   *     assert.isNotNull(tea, 'great, time for tea!');
	   *
	   * @name isNotNull
	   * @param {Mixed} value
	   * @param {String} message
	   * @api public
	   */

	  assert.isNotNull = function (val, msg) {
	    new Assertion(val, msg).to.not.equal(null);
	  };

	  /**
	   * ### .isUndefined(value, [message])
	   *
	   * Asserts that `value` is `undefined`.
	   *
	   *     var tea;
	   *     assert.isUndefined(tea, 'no tea defined');
	   *
	   * @name isUndefined
	   * @param {Mixed} value
	   * @param {String} message
	   * @api public
	   */

	  assert.isUndefined = function (val, msg) {
	    new Assertion(val, msg).to.equal(undefined);
	  };

	  /**
	   * ### .isDefined(value, [message])
	   *
	   * Asserts that `value` is not `undefined`.
	   *
	   *     var tea = 'cup of chai';
	   *     assert.isDefined(tea, 'tea has been defined');
	   *
	   * @name isDefined
	   * @param {Mixed} value
	   * @param {String} message
	   * @api public
	   */

	  assert.isDefined = function (val, msg) {
	    new Assertion(val, msg).to.not.equal(undefined);
	  };

	  /**
	   * ### .isFunction(value, [message])
	   *
	   * Asserts that `value` is a function.
	   *
	   *     function serveTea() { return 'cup of tea'; };
	   *     assert.isFunction(serveTea, 'great, we can have tea now');
	   *
	   * @name isFunction
	   * @param {Mixed} value
	   * @param {String} message
	   * @api public
	   */

	  assert.isFunction = function (val, msg) {
	    new Assertion(val, msg).to.be.a('function');
	  };

	  /**
	   * ### .isNotFunction(value, [message])
	   *
	   * Asserts that `value` is _not_ a function.
	   *
	   *     var serveTea = [ 'heat', 'pour', 'sip' ];
	   *     assert.isNotFunction(serveTea, 'great, we have listed the steps');
	   *
	   * @name isNotFunction
	   * @param {Mixed} value
	   * @param {String} message
	   * @api public
	   */

	  assert.isNotFunction = function (val, msg) {
	    new Assertion(val, msg).to.not.be.a('function');
	  };

	  /**
	   * ### .isObject(value, [message])
	   *
	   * Asserts that `value` is an object (as revealed by
	   * `Object.prototype.toString`).
	   *
	   *     var selection = { name: 'Chai', serve: 'with spices' };
	   *     assert.isObject(selection, 'tea selection is an object');
	   *
	   * @name isObject
	   * @param {Mixed} value
	   * @param {String} message
	   * @api public
	   */

	  assert.isObject = function (val, msg) {
	    new Assertion(val, msg).to.be.a('object');
	  };

	  /**
	   * ### .isNotObject(value, [message])
	   *
	   * Asserts that `value` is _not_ an object.
	   *
	   *     var selection = 'chai'
	   *     assert.isNotObject(selection, 'tea selection is not an object');
	   *     assert.isNotObject(null, 'null is not an object');
	   *
	   * @name isNotObject
	   * @param {Mixed} value
	   * @param {String} message
	   * @api public
	   */

	  assert.isNotObject = function (val, msg) {
	    new Assertion(val, msg).to.not.be.a('object');
	  };

	  /**
	   * ### .isArray(value, [message])
	   *
	   * Asserts that `value` is an array.
	   *
	   *     var menu = [ 'green', 'chai', 'oolong' ];
	   *     assert.isArray(menu, 'what kind of tea do we want?');
	   *
	   * @name isArray
	   * @param {Mixed} value
	   * @param {String} message
	   * @api public
	   */

	  assert.isArray = function (val, msg) {
	    new Assertion(val, msg).to.be.an('array');
	  };

	  /**
	   * ### .isNotArray(value, [message])
	   *
	   * Asserts that `value` is _not_ an array.
	   *
	   *     var menu = 'green|chai|oolong';
	   *     assert.isNotArray(menu, 'what kind of tea do we want?');
	   *
	   * @name isNotArray
	   * @param {Mixed} value
	   * @param {String} message
	   * @api public
	   */

	  assert.isNotArray = function (val, msg) {
	    new Assertion(val, msg).to.not.be.an('array');
	  };

	  /**
	   * ### .isString(value, [message])
	   *
	   * Asserts that `value` is a string.
	   *
	   *     var teaOrder = 'chai';
	   *     assert.isString(teaOrder, 'order placed');
	   *
	   * @name isString
	   * @param {Mixed} value
	   * @param {String} message
	   * @api public
	   */

	  assert.isString = function (val, msg) {
	    new Assertion(val, msg).to.be.a('string');
	  };

	  /**
	   * ### .isNotString(value, [message])
	   *
	   * Asserts that `value` is _not_ a string.
	   *
	   *     var teaOrder = 4;
	   *     assert.isNotString(teaOrder, 'order placed');
	   *
	   * @name isNotString
	   * @param {Mixed} value
	   * @param {String} message
	   * @api public
	   */

	  assert.isNotString = function (val, msg) {
	    new Assertion(val, msg).to.not.be.a('string');
	  };

	  /**
	   * ### .isNumber(value, [message])
	   *
	   * Asserts that `value` is a number.
	   *
	   *     var cups = 2;
	   *     assert.isNumber(cups, 'how many cups');
	   *
	   * @name isNumber
	   * @param {Number} value
	   * @param {String} message
	   * @api public
	   */

	  assert.isNumber = function (val, msg) {
	    new Assertion(val, msg).to.be.a('number');
	  };

	  /**
	   * ### .isNotNumber(value, [message])
	   *
	   * Asserts that `value` is _not_ a number.
	   *
	   *     var cups = '2 cups please';
	   *     assert.isNotNumber(cups, 'how many cups');
	   *
	   * @name isNotNumber
	   * @param {Mixed} value
	   * @param {String} message
	   * @api public
	   */

	  assert.isNotNumber = function (val, msg) {
	    new Assertion(val, msg).to.not.be.a('number');
	  };

	  /**
	   * ### .isBoolean(value, [message])
	   *
	   * Asserts that `value` is a boolean.
	   *
	   *     var teaReady = true
	   *       , teaServed = false;
	   *
	   *     assert.isBoolean(teaReady, 'is the tea ready');
	   *     assert.isBoolean(teaServed, 'has tea been served');
	   *
	   * @name isBoolean
	   * @param {Mixed} value
	   * @param {String} message
	   * @api public
	   */

	  assert.isBoolean = function (val, msg) {
	    new Assertion(val, msg).to.be.a('boolean');
	  };

	  /**
	   * ### .isNotBoolean(value, [message])
	   *
	   * Asserts that `value` is _not_ a boolean.
	   *
	   *     var teaReady = 'yep'
	   *       , teaServed = 'nope';
	   *
	   *     assert.isNotBoolean(teaReady, 'is the tea ready');
	   *     assert.isNotBoolean(teaServed, 'has tea been served');
	   *
	   * @name isNotBoolean
	   * @param {Mixed} value
	   * @param {String} message
	   * @api public
	   */

	  assert.isNotBoolean = function (val, msg) {
	    new Assertion(val, msg).to.not.be.a('boolean');
	  };

	  /**
	   * ### .typeOf(value, name, [message])
	   *
	   * Asserts that `value`'s type is `name`, as determined by
	   * `Object.prototype.toString`.
	   *
	   *     assert.typeOf({ tea: 'chai' }, 'object', 'we have an object');
	   *     assert.typeOf(['chai', 'jasmine'], 'array', 'we have an array');
	   *     assert.typeOf('tea', 'string', 'we have a string');
	   *     assert.typeOf(/tea/, 'regexp', 'we have a regular expression');
	   *     assert.typeOf(null, 'null', 'we have a null');
	   *     assert.typeOf(undefined, 'undefined', 'we have an undefined');
	   *
	   * @name typeOf
	   * @param {Mixed} value
	   * @param {String} name
	   * @param {String} message
	   * @api public
	   */

	  assert.typeOf = function (val, type, msg) {
	    new Assertion(val, msg).to.be.a(type);
	  };

	  /**
	   * ### .notTypeOf(value, name, [message])
	   *
	   * Asserts that `value`'s type is _not_ `name`, as determined by
	   * `Object.prototype.toString`.
	   *
	   *     assert.notTypeOf('tea', 'number', 'strings are not numbers');
	   *
	   * @name notTypeOf
	   * @param {Mixed} value
	   * @param {String} typeof name
	   * @param {String} message
	   * @api public
	   */

	  assert.notTypeOf = function (val, type, msg) {
	    new Assertion(val, msg).to.not.be.a(type);
	  };

	  /**
	   * ### .instanceOf(object, constructor, [message])
	   *
	   * Asserts that `value` is an instance of `constructor`.
	   *
	   *     var Tea = function (name) { this.name = name; }
	   *       , chai = new Tea('chai');
	   *
	   *     assert.instanceOf(chai, Tea, 'chai is an instance of tea');
	   *
	   * @name instanceOf
	   * @param {Object} object
	   * @param {Constructor} constructor
	   * @param {String} message
	   * @api public
	   */

	  assert.instanceOf = function (val, type, msg) {
	    new Assertion(val, msg).to.be.instanceOf(type);
	  };

	  /**
	   * ### .notInstanceOf(object, constructor, [message])
	   *
	   * Asserts `value` is not an instance of `constructor`.
	   *
	   *     var Tea = function (name) { this.name = name; }
	   *       , chai = new String('chai');
	   *
	   *     assert.notInstanceOf(chai, Tea, 'chai is not an instance of tea');
	   *
	   * @name notInstanceOf
	   * @param {Object} object
	   * @param {Constructor} constructor
	   * @param {String} message
	   * @api public
	   */

	  assert.notInstanceOf = function (val, type, msg) {
	    new Assertion(val, msg).to.not.be.instanceOf(type);
	  };

	  /**
	   * ### .include(haystack, needle, [message])
	   *
	   * Asserts that `haystack` includes `needle`. Works
	   * for strings and arrays.
	   *
	   *     assert.include('foobar', 'bar', 'foobar contains string "bar"');
	   *     assert.include([ 1, 2, 3 ], 3, 'array contains value');
	   *
	   * @name include
	   * @param {Array|String} haystack
	   * @param {Mixed} needle
	   * @param {String} message
	   * @api public
	   */

	  assert.include = function (exp, inc, msg) {
	    new Assertion(exp, msg, assert.include).include(inc);
	  };

	  /**
	   * ### .notInclude(haystack, needle, [message])
	   *
	   * Asserts that `haystack` does not include `needle`. Works
	   * for strings and arrays.
	   *i
	   *     assert.notInclude('foobar', 'baz', 'string not include substring');
	   *     assert.notInclude([ 1, 2, 3 ], 4, 'array not include contain value');
	   *
	   * @name notInclude
	   * @param {Array|String} haystack
	   * @param {Mixed} needle
	   * @param {String} message
	   * @api public
	   */

	  assert.notInclude = function (exp, inc, msg) {
	    new Assertion(exp, msg, assert.notInclude).not.include(inc);
	  };

	  /**
	   * ### .match(value, regexp, [message])
	   *
	   * Asserts that `value` matches the regular expression `regexp`.
	   *
	   *     assert.match('foobar', /^foo/, 'regexp matches');
	   *
	   * @name match
	   * @param {Mixed} value
	   * @param {RegExp} regexp
	   * @param {String} message
	   * @api public
	   */

	  assert.match = function (exp, re, msg) {
	    new Assertion(exp, msg).to.match(re);
	  };

	  /**
	   * ### .notMatch(value, regexp, [message])
	   *
	   * Asserts that `value` does not match the regular expression `regexp`.
	   *
	   *     assert.notMatch('foobar', /^foo/, 'regexp does not match');
	   *
	   * @name notMatch
	   * @param {Mixed} value
	   * @param {RegExp} regexp
	   * @param {String} message
	   * @api public
	   */

	  assert.notMatch = function (exp, re, msg) {
	    new Assertion(exp, msg).to.not.match(re);
	  };

	  /**
	   * ### .property(object, property, [message])
	   *
	   * Asserts that `object` has a property named by `property`.
	   *
	   *     assert.property({ tea: { green: 'matcha' }}, 'tea');
	   *
	   * @name property
	   * @param {Object} object
	   * @param {String} property
	   * @param {String} message
	   * @api public
	   */

	  assert.property = function (obj, prop, msg) {
	    new Assertion(obj, msg).to.have.property(prop);
	  };

	  /**
	   * ### .notProperty(object, property, [message])
	   *
	   * Asserts that `object` does _not_ have a property named by `property`.
	   *
	   *     assert.notProperty({ tea: { green: 'matcha' }}, 'coffee');
	   *
	   * @name notProperty
	   * @param {Object} object
	   * @param {String} property
	   * @param {String} message
	   * @api public
	   */

	  assert.notProperty = function (obj, prop, msg) {
	    new Assertion(obj, msg).to.not.have.property(prop);
	  };

	  /**
	   * ### .deepProperty(object, property, [message])
	   *
	   * Asserts that `object` has a property named by `property`, which can be a
	   * string using dot- and bracket-notation for deep reference.
	   *
	   *     assert.deepProperty({ tea: { green: 'matcha' }}, 'tea.green');
	   *
	   * @name deepProperty
	   * @param {Object} object
	   * @param {String} property
	   * @param {String} message
	   * @api public
	   */

	  assert.deepProperty = function (obj, prop, msg) {
	    new Assertion(obj, msg).to.have.deep.property(prop);
	  };

	  /**
	   * ### .notDeepProperty(object, property, [message])
	   *
	   * Asserts that `object` does _not_ have a property named by `property`, which
	   * can be a string using dot- and bracket-notation for deep reference.
	   *
	   *     assert.notDeepProperty({ tea: { green: 'matcha' }}, 'tea.oolong');
	   *
	   * @name notDeepProperty
	   * @param {Object} object
	   * @param {String} property
	   * @param {String} message
	   * @api public
	   */

	  assert.notDeepProperty = function (obj, prop, msg) {
	    new Assertion(obj, msg).to.not.have.deep.property(prop);
	  };

	  /**
	   * ### .propertyVal(object, property, value, [message])
	   *
	   * Asserts that `object` has a property named by `property` with value given
	   * by `value`.
	   *
	   *     assert.propertyVal({ tea: 'is good' }, 'tea', 'is good');
	   *
	   * @name propertyVal
	   * @param {Object} object
	   * @param {String} property
	   * @param {Mixed} value
	   * @param {String} message
	   * @api public
	   */

	  assert.propertyVal = function (obj, prop, val, msg) {
	    new Assertion(obj, msg).to.have.property(prop, val);
	  };

	  /**
	   * ### .propertyNotVal(object, property, value, [message])
	   *
	   * Asserts that `object` has a property named by `property`, but with a value
	   * different from that given by `value`.
	   *
	   *     assert.propertyNotVal({ tea: 'is good' }, 'tea', 'is bad');
	   *
	   * @name propertyNotVal
	   * @param {Object} object
	   * @param {String} property
	   * @param {Mixed} value
	   * @param {String} message
	   * @api public
	   */

	  assert.propertyNotVal = function (obj, prop, val, msg) {
	    new Assertion(obj, msg).to.not.have.property(prop, val);
	  };

	  /**
	   * ### .deepPropertyVal(object, property, value, [message])
	   *
	   * Asserts that `object` has a property named by `property` with value given
	   * by `value`. `property` can use dot- and bracket-notation for deep
	   * reference.
	   *
	   *     assert.deepPropertyVal({ tea: { green: 'matcha' }}, 'tea.green', 'matcha');
	   *
	   * @name deepPropertyVal
	   * @param {Object} object
	   * @param {String} property
	   * @param {Mixed} value
	   * @param {String} message
	   * @api public
	   */

	  assert.deepPropertyVal = function (obj, prop, val, msg) {
	    new Assertion(obj, msg).to.have.deep.property(prop, val);
	  };

	  /**
	   * ### .deepPropertyNotVal(object, property, value, [message])
	   *
	   * Asserts that `object` has a property named by `property`, but with a value
	   * different from that given by `value`. `property` can use dot- and
	   * bracket-notation for deep reference.
	   *
	   *     assert.deepPropertyNotVal({ tea: { green: 'matcha' }}, 'tea.green', 'konacha');
	   *
	   * @name deepPropertyNotVal
	   * @param {Object} object
	   * @param {String} property
	   * @param {Mixed} value
	   * @param {String} message
	   * @api public
	   */

	  assert.deepPropertyNotVal = function (obj, prop, val, msg) {
	    new Assertion(obj, msg).to.not.have.deep.property(prop, val);
	  };

	  /**
	   * ### .lengthOf(object, length, [message])
	   *
	   * Asserts that `object` has a `length` property with the expected value.
	   *
	   *     assert.lengthOf([1,2,3], 3, 'array has length of 3');
	   *     assert.lengthOf('foobar', 5, 'string has length of 6');
	   *
	   * @name lengthOf
	   * @param {Mixed} object
	   * @param {Number} length
	   * @param {String} message
	   * @api public
	   */

	  assert.lengthOf = function (exp, len, msg) {
	    new Assertion(exp, msg).to.have.length(len);
	  };

	  /**
	   * ### .throws(function, [constructor/string/regexp], [string/regexp], [message])
	   *
	   * Asserts that `function` will throw an error that is an instance of
	   * `constructor`, or alternately that it will throw an error with message
	   * matching `regexp`.
	   *
	   *     assert.throw(fn, 'function throws a reference error');
	   *     assert.throw(fn, /function throws a reference error/);
	   *     assert.throw(fn, ReferenceError);
	   *     assert.throw(fn, ReferenceError, 'function throws a reference error');
	   *     assert.throw(fn, ReferenceError, /function throws a reference error/);
	   *
	   * @name throws
	   * @alias throw
	   * @alias Throw
	   * @param {Function} function
	   * @param {ErrorConstructor} constructor
	   * @param {RegExp} regexp
	   * @param {String} message
	   * @see https://developer.mozilla.org/en/JavaScript/Reference/Global_Objects/Error#Error_types
	   * @api public
	   */

	  assert.Throw = function (fn, errt, errs, msg) {
	    if ('string' === typeof errt || errt instanceof RegExp) {
	      errs = errt;
	      errt = null;
	    }

	    var assertErr = new Assertion(fn, msg).to.Throw(errt, errs);
	    return flag(assertErr, 'object');
	  };

	  /**
	   * ### .doesNotThrow(function, [constructor/regexp], [message])
	   *
	   * Asserts that `function` will _not_ throw an error that is an instance of
	   * `constructor`, or alternately that it will not throw an error with message
	   * matching `regexp`.
	   *
	   *     assert.doesNotThrow(fn, Error, 'function does not throw');
	   *
	   * @name doesNotThrow
	   * @param {Function} function
	   * @param {ErrorConstructor} constructor
	   * @param {RegExp} regexp
	   * @param {String} message
	   * @see https://developer.mozilla.org/en/JavaScript/Reference/Global_Objects/Error#Error_types
	   * @api public
	   */

	  assert.doesNotThrow = function (fn, type, msg) {
	    if ('string' === typeof type) {
	      msg = type;
	      type = null;
	    }

	    new Assertion(fn, msg).to.not.Throw(type);
	  };

	  /**
	   * ### .operator(val1, operator, val2, [message])
	   *
	   * Compares two values using `operator`.
	   *
	   *     assert.operator(1, '<', 2, 'everything is ok');
	   *     assert.operator(1, '>', 2, 'this will fail');
	   *
	   * @name operator
	   * @param {Mixed} val1
	   * @param {String} operator
	   * @param {Mixed} val2
	   * @param {String} message
	   * @api public
	   */

	  assert.operator = function (val, operator, val2, msg) {
	    var ok;
	    switch(operator) {
	      case '==':
	        ok = val == val2;
	        break;
	      case '===':
	        ok = val === val2;
	        break;
	      case '>':
	        ok = val > val2;
	        break;
	      case '>=':
	        ok = val >= val2;
	        break;
	      case '<':
	        ok = val < val2;
	        break;
	      case '<=':
	        ok = val <= val2;
	        break;
	      case '!=':
	        ok = val != val2;
	        break;
	      case '!==':
	        ok = val !== val2;
	        break;
	      default:
	        throw new Error('Invalid operator "' + operator + '"');
	    }
	    var test = new Assertion(ok, msg);
	    test.assert(
	        true === flag(test, 'object')
	      , 'expected ' + util.inspect(val) + ' to be ' + operator + ' ' + util.inspect(val2)
	      , 'expected ' + util.inspect(val) + ' to not be ' + operator + ' ' + util.inspect(val2) );
	  };

	  /**
	   * ### .closeTo(actual, expected, delta, [message])
	   *
	   * Asserts that the target is equal `expected`, to within a +/- `delta` range.
	   *
	   *     assert.closeTo(1.5, 1, 0.5, 'numbers are close');
	   *
	   * @name closeTo
	   * @param {Number} actual
	   * @param {Number} expected
	   * @param {Number} delta
	   * @param {String} message
	   * @api public
	   */

	  assert.closeTo = function (act, exp, delta, msg) {
	    new Assertion(act, msg).to.be.closeTo(exp, delta);
	  };

	  /**
	   * ### .sameMembers(set1, set2, [message])
	   *
	   * Asserts that `set1` and `set2` have the same members.
	   * Order is not taken into account.
	   *
	   *     assert.sameMembers([ 1, 2, 3 ], [ 2, 1, 3 ], 'same members');
	   *
	   * @name sameMembers
	   * @param {Array} set1
	   * @param {Array} set2
	   * @param {String} message
	   * @api public
	   */

	  assert.sameMembers = function (set1, set2, msg) {
	    new Assertion(set1, msg).to.have.same.members(set2);
	  }

	  /**
	   * ### .sameDeepMembers(set1, set2, [message])
	   *
	   * Asserts that `set1` and `set2` have the same members - using a deep equality checking.
	   * Order is not taken into account.
	   *
	   *     assert.sameDeepMembers([ {b: 3}, {a: 2}, {c: 5} ], [ {c: 5}, {b: 3}, {a: 2} ], 'same deep members');
	   *
	   * @name sameDeepMembers
	   * @param {Array} set1
	   * @param {Array} set2
	   * @param {String} message
	   * @api public
	   */

	  assert.sameDeepMembers = function (set1, set2, msg) {
	    new Assertion(set1, msg).to.have.same.deep.members(set2);
	  }

	  /**
	   * ### .includeMembers(superset, subset, [message])
	   *
	   * Asserts that `subset` is included in `superset`.
	   * Order is not taken into account.
	   *
	   *     assert.includeMembers([ 1, 2, 3 ], [ 2, 1 ], 'include members');
	   *
	   * @name includeMembers
	   * @param {Array} superset
	   * @param {Array} subset
	   * @param {String} message
	   * @api public
	   */

	  assert.includeMembers = function (superset, subset, msg) {
	    new Assertion(superset, msg).to.include.members(subset);
	  }

	   /**
	   * ### .changes(function, object, property)
	   *
	   * Asserts that a function changes the value of a property
	   *
	   *     var obj = { val: 10 };
	   *     var fn = function() { obj.val = 22 };
	   *     assert.changes(fn, obj, 'val');
	   *
	   * @name changes
	   * @param {Function} modifier function
	   * @param {Object} object
	   * @param {String} property name
	   * @param {String} message _optional_
	   * @api public
	   */

	  assert.changes = function (fn, obj, prop) {
	    new Assertion(fn).to.change(obj, prop);
	  }

	   /**
	   * ### .doesNotChange(function, object, property)
	   *
	   * Asserts that a function does not changes the value of a property
	   *
	   *     var obj = { val: 10 };
	   *     var fn = function() { console.log('foo'); };
	   *     assert.doesNotChange(fn, obj, 'val');
	   *
	   * @name doesNotChange
	   * @param {Function} modifier function
	   * @param {Object} object
	   * @param {String} property name
	   * @param {String} message _optional_
	   * @api public
	   */

	  assert.doesNotChange = function (fn, obj, prop) {
	    new Assertion(fn).to.not.change(obj, prop);
	  }

	   /**
	   * ### .increases(function, object, property)
	   *
	   * Asserts that a function increases an object property
	   *
	   *     var obj = { val: 10 };
	   *     var fn = function() { obj.val = 13 };
	   *     assert.increases(fn, obj, 'val');
	   *
	   * @name increases
	   * @param {Function} modifier function
	   * @param {Object} object
	   * @param {String} property name
	   * @param {String} message _optional_
	   * @api public
	   */

	  assert.increases = function (fn, obj, prop) {
	    new Assertion(fn).to.increase(obj, prop);
	  }

	   /**
	   * ### .doesNotIncrease(function, object, property)
	   *
	   * Asserts that a function does not increase object property
	   *
	   *     var obj = { val: 10 };
	   *     var fn = function() { obj.val = 8 };
	   *     assert.doesNotIncrease(fn, obj, 'val');
	   *
	   * @name doesNotIncrease
	   * @param {Function} modifier function
	   * @param {Object} object
	   * @param {String} property name
	   * @param {String} message _optional_
	   * @api public
	   */

	  assert.doesNotIncrease = function (fn, obj, prop) {
	    new Assertion(fn).to.not.increase(obj, prop);
	  }

	   /**
	   * ### .decreases(function, object, property)
	   *
	   * Asserts that a function decreases an object property
	   *
	   *     var obj = { val: 10 };
	   *     var fn = function() { obj.val = 5 };
	   *     assert.decreases(fn, obj, 'val');
	   *
	   * @name decreases
	   * @param {Function} modifier function
	   * @param {Object} object
	   * @param {String} property name
	   * @param {String} message _optional_
	   * @api public
	   */

	  assert.decreases = function (fn, obj, prop) {
	    new Assertion(fn).to.decrease(obj, prop);
	  }

	   /**
	   * ### .doesNotDecrease(function, object, property)
	   *
	   * Asserts that a function does not decreases an object property
	   *
	   *     var obj = { val: 10 };
	   *     var fn = function() { obj.val = 15 };
	   *     assert.doesNotDecrease(fn, obj, 'val');
	   *
	   * @name doesNotDecrease
	   * @param {Function} modifier function
	   * @param {Object} object
	   * @param {String} property name
	   * @param {String} message _optional_
	   * @api public
	   */

	  assert.doesNotDecrease = function (fn, obj, prop) {
	    new Assertion(fn).to.not.decrease(obj, prop);
	  }

	  /*!
	   * Undocumented / untested
	   */

	  assert.ifError = function (val, msg) {
	    new Assertion(val, msg).to.not.be.ok;
	  };

	  /*!
	   * Aliases.
	   */

	  (function alias(name, as){
	    assert[as] = assert[name];
	    return alias;
	  })
	  ('Throw', 'throw')
	  ('Throw', 'throws');
	};


/***/ },
/* 47 */
/***/ function(module, exports, __webpack_require__) {

	(function webpackUniversalModuleDefinition(root, factory) {
		if(true)
			module.exports = factory();
		else if(typeof define === 'function' && define.amd)
			define(factory);
		else if(typeof exports === 'object')
			exports["eventric"] = factory();
		else
			root["eventric"] = factory();
	})(this, function() {
	return /******/ (function(modules) { // webpackBootstrap
	/******/ 	// The module cache
	/******/ 	var installedModules = {};

	/******/ 	// The require function
	/******/ 	function __webpack_require__(moduleId) {

	/******/ 		// Check if module is in cache
	/******/ 		if(installedModules[moduleId])
	/******/ 			return installedModules[moduleId].exports;

	/******/ 		// Create a new module (and put it into the cache)
	/******/ 		var module = installedModules[moduleId] = {
	/******/ 			exports: {},
	/******/ 			id: moduleId,
	/******/ 			loaded: false
	/******/ 		};

	/******/ 		// Execute the module function
	/******/ 		modules[moduleId].call(module.exports, module, module.exports, __webpack_require__);

	/******/ 		// Flag the module as loaded
	/******/ 		module.loaded = true;

	/******/ 		// Return the exports of the module
	/******/ 		return module.exports;
	/******/ 	}


	/******/ 	// expose the modules object (__webpack_modules__)
	/******/ 	__webpack_require__.m = modules;

	/******/ 	// expose the module cache
	/******/ 	__webpack_require__.c = installedModules;

	/******/ 	// __webpack_public_path__
	/******/ 	__webpack_require__.p = "";

	/******/ 	// Load entry module and return exports
	/******/ 	return __webpack_require__(0);
	/******/ })
	/************************************************************************/
	/******/ ([
	/* 0 */
	/***/ function(module, exports, __webpack_require__) {

		module.exports = __webpack_require__(1);


	/***/ },
	/* 1 */
	/***/ function(module, exports, __webpack_require__) {

		var Context, Eventric, GlobalContext, Projection, Remote, StoreInMemory, remoteInmemory, uidGenerator,
		  bind = function(fn, me){ return function(){ return fn.apply(me, arguments); }; };

		remoteInmemory = __webpack_require__(2);

		GlobalContext = __webpack_require__(3);

		Remote = __webpack_require__(5);

		Projection = __webpack_require__(9);

		Context = __webpack_require__(13);

		StoreInMemory = __webpack_require__(24);

		uidGenerator = __webpack_require__(11);

		Eventric = (function() {
		  function Eventric() {
		    this._handleRemoteRPCRequest = bind(this._handleRemoteRPCRequest, this);
		    this._contexts = {};
		    this._params = {};
		    this._domainEventHandlers = {};
		    this._domainEventHandlersAll = [];
		    this._storeDefintion = null;
		    this._remoteEndpoints = [];
		    this._globalProjectionClasses = [];
		    this._globalContext = new GlobalContext;
		    this._projectionService = new Projection(this._globalContext);
		    this.setRemoteEndpoint(remoteInmemory.endpoint);
		    this.setStore(StoreInMemory, {});
		  }

		  Eventric.prototype.setStore = function(StoreClass, storeOptions) {
		    if (storeOptions == null) {
		      storeOptions = {};
		    }
		    return this._storeDefintion = {
		      Class: StoreClass,
		      options: storeOptions
		    };
		  };

		  Eventric.prototype.context = function(name) {
		    var context, error;
		    if (!name) {
		      error = 'Contexts must have a name';
		      this.log.error(error);
		      throw new Error(error);
		    }
		    context = new Context(name, this._storeDefintion);
		    this._delegateAllDomainEventsToRemoteEndpoint(context);
		    this._contexts[name] = context;
		    return context;
		  };

		  Eventric.prototype.initializeGlobalProjections = function() {
		    return Promise.all(this._globalProjectionClasses.map((function(_this) {
		      return function(GlobalProjectionClass) {
		        return _this._projectionService.initializeInstance('', new GlobalProjectionClass, {});
		      };
		    })(this)));
		  };

		  Eventric.prototype.addGlobalProjection = function(ProjectionClass) {
		    return this._globalProjectionClasses.push(ProjectionClass);
		  };

		  Eventric.prototype.getRegisteredContextNames = function() {
		    return Object.keys(this._contexts);
		  };

		  Eventric.prototype.getContext = function(name) {
		    return this._contexts[name];
		  };

		  Eventric.prototype.remote = function(contextName) {
		    var error;
		    if (!contextName) {
		      error = 'Missing context name';
		      this.log.error(error);
		      throw new Error(error);
		    }
		    return new Remote(contextName);
		  };

		  Eventric.prototype.setRemoteEndpoint = function(remoteEndpoint) {
		    this._remoteEndpoint = remoteEndpoint;
		    return this._remoteEndpoint.setRPCHandler(this._handleRemoteRPCRequest);
		  };

		  Eventric.prototype.generateUid = function() {
		    return uidGenerator.generateUid();
		  };

		  Eventric.prototype._handleRemoteRPCRequest = function(request, callback) {
		    var context, error;
		    context = this.getContext(request.contextName);
		    if (!context) {
		      error = new Error("Tried to handle Remote RPC with not registered context " + request.contextName);
		      this.log.error(error.stack);
		      callback(error, null);
		      return;
		    }
		    if (Remote.ALLOWED_RPC_OPERATIONS.indexOf(request.functionName) === -1) {
		      error = new Error("RPC operation '" + request.functionName + "' not allowed");
		      callback(error, null);
		      return;
		    }
		    if (!(request.functionName in context)) {
		      error = new Error("Remote RPC function " + request.functionName + " not found on Context " + request.contextName);
		      this.log.error(error.stack);
		      callback(error, null);
		      return;
		    }
		    return context[request.functionName].apply(context, request.args).then(function(result) {
		      return callback(null, result);
		    })["catch"](function(error) {
		      return callback(error);
		    });
		  };

		  Eventric.prototype._delegateAllDomainEventsToRemoteEndpoint = function(context) {
		    return context.subscribeToAllDomainEvents((function(_this) {
		      return function(domainEvent) {
		        _this._remoteEndpoint.publish(context.name, domainEvent.name, domainEvent);
		        if (domainEvent.aggregate) {
		          return _this._remoteEndpoint.publish(context.name, domainEvent.name, domainEvent.aggregate.id, domainEvent);
		        }
		      };
		    })(this));
		  };

		  return Eventric;

		})();

		module.exports = new Eventric;


	/***/ },
	/* 2 */
	/***/ function(module, exports, __webpack_require__) {

		(function webpackUniversalModuleDefinition(root, factory) {
			if(true)
				module.exports = factory();
			else if(typeof define === 'function' && define.amd)
				define(factory);
			else if(typeof exports === 'object')
				exports["eventric-remote-inmemory"] = factory();
			else
				root["eventric-remote-inmemory"] = factory();
		})(this, function() {
		return /******/ (function(modules) { // webpackBootstrap
		/******/ 	// The module cache
		/******/ 	var installedModules = {};

		/******/ 	// The require function
		/******/ 	function __webpack_require__(moduleId) {

		/******/ 		// Check if module is in cache
		/******/ 		if(installedModules[moduleId])
		/******/ 			return installedModules[moduleId].exports;

		/******/ 		// Create a new module (and put it into the cache)
		/******/ 		var module = installedModules[moduleId] = {
		/******/ 			exports: {},
		/******/ 			id: moduleId,
		/******/ 			loaded: false
		/******/ 		};

		/******/ 		// Execute the module function
		/******/ 		modules[moduleId].call(module.exports, module, module.exports, __webpack_require__);

		/******/ 		// Flag the module as loaded
		/******/ 		module.loaded = true;

		/******/ 		// Return the exports of the module
		/******/ 		return module.exports;
		/******/ 	}


		/******/ 	// expose the modules object (__webpack_modules__)
		/******/ 	__webpack_require__.m = modules;

		/******/ 	// expose the module cache
		/******/ 	__webpack_require__.c = installedModules;

		/******/ 	// __webpack_public_path__
		/******/ 	__webpack_require__.p = "";

		/******/ 	// Load entry module and return exports
		/******/ 	return __webpack_require__(0);
		/******/ })
		/************************************************************************/
		/******/ ([
		/* 0 */
		/***/ function(module, exports, __webpack_require__) {

			module.exports = {
			  endpoint: __webpack_require__(1),
			  client: __webpack_require__(3)
			};


		/***/ },
		/* 1 */
		/***/ function(module, exports, __webpack_require__) {

			var InMemoryRemoteEndpoint, pubSub,
			  slice = [].slice;

			pubSub = __webpack_require__(2);

			InMemoryRemoteEndpoint = (function() {
			  function InMemoryRemoteEndpoint() {}

			  InMemoryRemoteEndpoint.prototype.setRPCHandler = function(handleRPCRequest) {
			    this.handleRPCRequest = handleRPCRequest;
			  };

			  InMemoryRemoteEndpoint.prototype.publish = function() {
			    var aggregateId, arg, contextName, domainEventName, fullEventName, i, payload;
			    contextName = arguments[0], arg = 3 <= arguments.length ? slice.call(arguments, 1, i = arguments.length - 1) : (i = 1, []), payload = arguments[i++];
			    domainEventName = arg[0], aggregateId = arg[1];
			    fullEventName = pubSub.getFullEventName(contextName, domainEventName, aggregateId);
			    return pubSub.publish(fullEventName, payload);
			  };

			  return InMemoryRemoteEndpoint;

			})();

			module.exports = new InMemoryRemoteEndpoint;


		/***/ },
		/* 2 */
		/***/ function(module, exports) {

			var PubSub,
			  slice = [].slice;

			PubSub = (function() {
			  function PubSub() {
			    this._subscribers = [];
			    this._subscriberId = 0;
			  }

			  PubSub.prototype.subscribe = function(eventName, subscriberFunction) {
			    return new Promise((function(_this) {
			      return function(resolve) {
			        var subscriber;
			        subscriber = {
			          eventName: eventName,
			          subscriberFunction: subscriberFunction,
			          subscriberId: _this._getNextSubscriberId()
			        };
			        _this._subscribers.push(subscriber);
			        return resolve(subscriber.subscriberId);
			      };
			    })(this));
			  };

			  PubSub.prototype.publish = function(eventName, payload) {
			    var subscribers;
			    subscribers = this._getRelevantSubscribers(eventName);
			    return Promise.all(subscribers.map(function(subscriber) {
			      return subscriber.subscriberFunction(payload);
			    }));
			  };

			  PubSub.prototype._getRelevantSubscribers = function(eventName) {
			    if (eventName) {
			      return this._subscribers.filter(function(subscriber) {
			        return subscriber.eventName === eventName;
			      });
			    } else {
			      return this._subscribers;
			    }
			  };

			  PubSub.prototype.unsubscribe = function(subscriberId) {
			    return new Promise((function(_this) {
			      return function(resolve) {
			        _this._subscribers = _this._subscribers.filter(function(subscriber) {
			          return subscriber.subscriberId !== subscriberId;
			        });
			        return resolve();
			      };
			    })(this));
			  };

			  PubSub.prototype._getNextSubscriberId = function() {
			    return this._subscriberId++;
			  };

			  PubSub.prototype.getFullEventName = function() {
			    var eventParts;
			    eventParts = 1 <= arguments.length ? slice.call(arguments, 0) : [];
			    eventParts = eventParts.filter(function(eventPart) {
			      return eventPart != null;
			    });
			    return eventParts.join('/');
			  };

			  return PubSub;

			})();

			module.exports = new PubSub;


		/***/ },
		/* 3 */
		/***/ function(module, exports, __webpack_require__) {

			var InMemoryRemoteClient, endpoint, pubSub,
			  slice = [].slice;

			endpoint = __webpack_require__(1);

			pubSub = __webpack_require__(2);

			InMemoryRemoteClient = (function() {
			  function InMemoryRemoteClient() {}

			  InMemoryRemoteClient.prototype.rpc = function(rpcRequest) {
			    return new Promise((function(_this) {
			      return function(resolve, reject) {
			        return endpoint.handleRPCRequest(rpcRequest, function(error, result) {
			          if (error) {
			            return reject(error);
			          } else {
			            return resolve(result);
			          }
			        });
			      };
			    })(this));
			  };

			  InMemoryRemoteClient.prototype.subscribe = function() {
			    var aggregateId, arg, contextName, domainEventName, fullEventName, handlerFunction, i;
			    contextName = arguments[0], arg = 3 <= arguments.length ? slice.call(arguments, 1, i = arguments.length - 1) : (i = 1, []), handlerFunction = arguments[i++];
			    domainEventName = arg[0], aggregateId = arg[1];
			    fullEventName = pubSub.getFullEventName(contextName, domainEventName, aggregateId);
			    return pubSub.subscribe(fullEventName, handlerFunction);
			  };

			  InMemoryRemoteClient.prototype.unsubscribe = function(subscriberId) {
			    return pubSub.unsubscribe(subscriberId);
			  };

			  return InMemoryRemoteClient;

			})();

			module.exports = new InMemoryRemoteClient;


		/***/ }
		/******/ ])
		});
		;

	/***/ },
	/* 3 */
	/***/ function(module, exports, __webpack_require__) {

		module.exports = __webpack_require__(4);


	/***/ },
	/* 4 */
	/***/ function(module, exports, __webpack_require__) {

		var GlobalContext,
		  slice = [].slice;

		GlobalContext = (function() {
		  function GlobalContext() {
		    this.name = 'Global';
		  }

		  GlobalContext.prototype.findDomainEventsByName = function() {
		    var findArguments, findDomainEventsByName;
		    findArguments = 1 <= arguments.length ? slice.call(arguments, 0) : [];
		    findDomainEventsByName = this._getAllContexts().map(function(context) {
		      return context.findDomainEventsByName.apply(context, findArguments);
		    });
		    return Promise.all(findDomainEventsByName).then((function(_this) {
		      return function(domainEventsByContext) {
		        var domainEvents;
		        domainEvents = _this._combineDomainEventsByContext(domainEventsByContext);
		        _this._sortDomainEventsByTimestamp(domainEvents);
		        return domainEvents;
		      };
		    })(this));
		  };

		  GlobalContext.prototype.subscribeToDomainEvent = function(eventName, domainEventHandler) {
		    var subscribeToDomainEvents;
		    subscribeToDomainEvents = this._getAllContexts().map(function(context) {
		      return context.subscribeToDomainEvent(eventName, domainEventHandler);
		    });
		    return Promise.all(subscribeToDomainEvents);
		  };

		  GlobalContext.prototype._getAllContexts = function() {
		    var contextNames, eventric;
		    eventric = __webpack_require__(1);
		    contextNames = eventric.getRegisteredContextNames();
		    return contextNames.map((function(_this) {
		      return function(contextName) {
		        return eventric.remote(contextName);
		      };
		    })(this));
		  };

		  GlobalContext.prototype._combineDomainEventsByContext = function(domainEventsByContext) {
		    return domainEventsByContext.reduce(function(allDomainEvents, contextDomainEvents) {
		      return allDomainEvents.concat(contextDomainEvents);
		    }, []);
		  };

		  GlobalContext.prototype._sortDomainEventsByTimestamp = function(domainEvents) {
		    return domainEvents.sort(function(firstEvent, secondEvent) {
		      return firstEvent.timestamp - secondEvent.timestamp;
		    });
		  };

		  return GlobalContext;

		})();

		module.exports = GlobalContext;


	/***/ },
	/* 5 */
	/***/ function(module, exports, __webpack_require__) {

		module.exports = __webpack_require__(6);


	/***/ },
	/* 6 */
	/***/ function(module, exports, __webpack_require__) {

		var Projection, Remote, logger, remoteInmemory;

		remoteInmemory = __webpack_require__(2);

		logger = __webpack_require__(7);

		Projection = __webpack_require__(9);

		Remote = (function() {
		  Remote.ALLOWED_RPC_OPERATIONS = ['command', 'query', 'findDomainEventsByName', 'findDomainEventsByNameAndAggregateId'];

		  function Remote(_contextName) {
		    this._contextName = _contextName;
		    this.name = this._contextName;
		    this._params = {};
		    this._projectionClasses = {};
		    this._projectionInstances = {};
		    this._handlerFunctions = {};
		    this.projectionService = new Projection(this);
		    this.setClient(remoteInmemory.client);
		    this._exposeRpcOperationsAsMemberFunctions();
		  }

		  Remote.prototype._exposeRpcOperationsAsMemberFunctions = function() {
		    return Remote.ALLOWED_RPC_OPERATIONS.forEach((function(_this) {
		      return function(rpcOperation) {
		        return _this[rpcOperation] = function() {
		          return _this._rpc(rpcOperation, arguments);
		        };
		      };
		    })(this));
		  };

		  Remote.prototype.subscribeToAllDomainEvents = function(handlerFn) {
		    return this._client.subscribe(this._contextName, handlerFn);
		  };

		  Remote.prototype.subscribeToDomainEvent = function(domainEventName, handlerFn) {
		    return this._client.subscribe(this._contextName, domainEventName, handlerFn);
		  };

		  Remote.prototype.subscribeToDomainEventWithAggregateId = function(domainEventName, aggregateId, handlerFn) {
		    return this._client.subscribe(this._contextName, domainEventName, aggregateId, handlerFn);
		  };

		  Remote.prototype.unsubscribeFromDomainEvent = function(subscriberId) {
		    return this._client.unsubscribe(subscriberId);
		  };

		  Remote.prototype._rpc = function(functionName, args) {
		    return this._client.rpc({
		      contextName: this._contextName,
		      functionName: functionName,
		      args: Array.prototype.slice.call(args)
		    });
		  };

		  Remote.prototype.setClient = function(client) {
		    this._client = client;
		    return this;
		  };

		  Remote.prototype.addProjection = function(projectionName, projectionClass) {
		    this._projectionClasses[projectionName] = projectionClass;
		    return this;
		  };

		  Remote.prototype.initializeProjection = function(projectionObject, params) {
		    return this.projectionService.initializeInstance('', projectionObject, params);
		  };

		  Remote.prototype.initializeProjectionInstance = function(projectionName, params) {
		    if (!this._projectionClasses[projectionName]) {
		      return Promise.reject(new Error("Given projection " + projectionName + " not registered on remote"));
		    }
		    return this.projectionService.initializeInstance(projectionName, this._projectionClasses[projectionName], params);
		  };

		  Remote.prototype.getProjectionInstance = function(projectionId) {
		    return this.projectionService.getInstance(projectionId);
		  };

		  Remote.prototype.destroyProjectionInstance = function(projectionId) {
		    return this.projectionService.destroyInstance(projectionId, this);
		  };

		  return Remote;

		})();

		module.exports = Remote;


	/***/ },
	/* 7 */
	/***/ function(module, exports, __webpack_require__) {

		module.exports = __webpack_require__(8);


	/***/ },
	/* 8 */
	/***/ function(module, exports) {

		module.exports = {
		  _logLevel: 1,
		  setLogLevel: function(logLevel) {
		    return this._logLevel = (function() {
		      switch (logLevel) {
		        case 'debug':
		          return 0;
		        case 'warn':
		          return 1;
		        case 'info':
		          return 2;
		        case 'error':
		          return 3;
		      }
		    })();
		  },
		  debug: function() {
		    if (this._logLevel > 0) {
		      return;
		    }
		    return console.log.apply(console, arguments);
		  },
		  warn: function() {
		    if (this._logLevel > 1) {
		      return;
		    }
		    return console.log.apply(console, arguments);
		  },
		  info: function() {
		    if (this._logLevel > 2) {
		      return;
		    }
		    return console.log.apply(console, arguments);
		  },
		  error: function() {
		    if (this._logLevel > 3) {
		      return;
		    }
		    return console.log.apply(console, arguments);
		  }
		};


	/***/ },
	/* 9 */
	/***/ function(module, exports, __webpack_require__) {

		module.exports = __webpack_require__(10);


	/***/ },
	/* 10 */
	/***/ function(module, exports, __webpack_require__) {

		var Projection, logger, uidGenerator,
		  bind = function(fn, me){ return function(){ return fn.apply(me, arguments); }; };

		logger = __webpack_require__(7);

		uidGenerator = __webpack_require__(11);

		Projection = (function() {
		  function Projection(_context) {
		    this._context = _context;
		    this._applyDomainEventToProjection = bind(this._applyDomainEventToProjection, this);
		    this._handlerFunctions = {};
		    this._projectionInstances = {};
		    this._domainEventsApplied = {};
		  }

		  Projection.prototype.initializeInstance = function(projectionName, Projection, params) {
		    var aggregateId, diFn, diName, eventNames, projection, projectionId, ref;
		    if (typeof Projection === 'function') {
		      projection = new Projection;
		    } else {
		      projection = Projection;
		    }
		    if (this._context._di) {
		      ref = this._context._di;
		      for (diName in ref) {
		        diFn = ref[diName];
		        projection[diName] = diFn;
		      }
		    }
		    projectionId = uidGenerator.generateUid();
		    aggregateId = null;
		    projection.$subscribeHandlersWithAggregateId = function(_aggregateId) {
		      return aggregateId = _aggregateId;
		    };
		    eventNames = null;
		    return this._callInitializeOnProjection(projectionName, projection, params).then((function(_this) {
		      return function() {
		        return _this._parseEventNamesFromProjection(projection);
		      };
		    })(this)).then((function(_this) {
		      return function(_eventNames) {
		        eventNames = _eventNames;
		        return _this._applyDomainEventsFromStoreToProjection(projectionId, projection, eventNames, aggregateId);
		      };
		    })(this)).then((function(_this) {
		      return function() {
		        return _this._subscribeProjectionToDomainEvents(projectionId, projectionName, projection, eventNames, aggregateId);
		      };
		    })(this)).then((function(_this) {
		      return function() {
		        return _this._projectionInstances[projectionId] = projection;
		      };
		    })(this)).then(function() {
		      return projection.isInitialized = true;
		    }).then(function() {
		      return projectionId;
		    });
		  };

		  Projection.prototype._callInitializeOnProjection = function(projectionName, projection, params) {
		    return new Promise((function(_this) {
		      return function(resolve, reject) {
		        if (!projection.initialize) {
		          logger.debug("[" + _this._context.name + "] No initialize function on Projection " + projectionName + " given, skipping");
		          return resolve(projection);
		        }
		        logger.debug("[" + _this._context.name + "] Calling initialize on Projection " + projectionName);
		        return projection.initialize(params, function() {
		          logger.debug("[" + _this._context.name + "] Finished initialize call on Projection " + projectionName);
		          return resolve(projection);
		        });
		      };
		    })(this));
		  };

		  Projection.prototype._parseEventNamesFromProjection = function(projection) {
		    return new Promise(function(resolve, reject) {
		      var eventName, eventNames, key, value;
		      eventNames = [];
		      for (key in projection) {
		        value = projection[key];
		        if ((key.indexOf('handle')) === 0 && (typeof value === 'function')) {
		          eventName = key.replace(/^handle/, '');
		          eventNames.push(eventName);
		        }
		      }
		      return resolve(eventNames);
		    });
		  };

		  Projection.prototype._applyDomainEventsFromStoreToProjection = function(projectionId, projection, eventNames, aggregateId) {
		    var findEvents;
		    this._domainEventsApplied[projectionId] = {};
		    if (aggregateId) {
		      findEvents = this._context.findDomainEventsByNameAndAggregateId(eventNames, aggregateId);
		    } else {
		      findEvents = this._context.findDomainEventsByName(eventNames);
		    }
		    return findEvents.then((function(_this) {
		      return function(domainEvents) {
		        var applyDomainEventsToProjectionPromise;
		        if (!domainEvents || domainEvents.length === 0) {
		          return;
		        }
		        applyDomainEventsToProjectionPromise = Promise.resolve();
		        domainEvents.forEach(function(domainEvent) {
		          return applyDomainEventsToProjectionPromise = applyDomainEventsToProjectionPromise.then(function() {
		            return _this._applyDomainEventToProjection(domainEvent, projection);
		          }).then(function() {
		            return _this._domainEventsApplied[projectionId][domainEvent.id] = true;
		          });
		        });
		        return applyDomainEventsToProjectionPromise;
		      };
		    })(this));
		  };

		  Projection.prototype._subscribeProjectionToDomainEvents = function(projectionId, projectionName, projection, eventNames, aggregateId) {
		    var domainEventHandler, subscribeProjectionToDomainEventsPromise;
		    domainEventHandler = (function(_this) {
		      return function(domainEvent) {
		        if (_this._domainEventsApplied[projectionId][domainEvent.id]) {
		          return;
		        }
		        return _this._applyDomainEventToProjection(domainEvent, projection).then(function() {
		          _this._domainEventsApplied[projectionId][domainEvent.id] = true;
		        });
		      };
		    })(this);
		    subscribeProjectionToDomainEventsPromise = Promise.resolve();
		    eventNames.forEach((function(_this) {
		      return function(eventName) {
		        return subscribeProjectionToDomainEventsPromise = subscribeProjectionToDomainEventsPromise.then(function() {
		          if (aggregateId) {
		            return _this._context.subscribeToDomainEventWithAggregateId(eventName, aggregateId, domainEventHandler);
		          } else {
		            return _this._context.subscribeToDomainEvent(eventName, domainEventHandler);
		          }
		        }).then(function(subscriberId) {
		          var base;
		          if ((base = _this._handlerFunctions)[projectionId] == null) {
		            base[projectionId] = [];
		          }
		          return _this._handlerFunctions[projectionId].push(subscriberId);
		        });
		      };
		    })(this));
		    return subscribeProjectionToDomainEventsPromise;
		  };

		  Projection.prototype._applyDomainEventToProjection = function(domainEvent, projection) {
		    return Promise.resolve().then((function(_this) {
		      return function() {
		        if (!projection["handle" + domainEvent.name]) {
		          logger.debug("Tried to apply DomainEvent '" + domainEvent.name + "' to Projection without a matching handle method");
		          return;
		        }
		        return projection["handle" + domainEvent.name](domainEvent);
		      };
		    })(this));
		  };

		  Projection.prototype.getInstance = function(projectionId) {
		    return this._projectionInstances[projectionId];
		  };

		  Projection.prototype.destroyInstance = function(projectionId) {
		    var i, len, ref, subscriberId, unsubscribePromises;
		    if (!this._handlerFunctions[projectionId]) {
		      return Promise.reject(new Error('Missing attribute projectionId'));
		    }
		    unsubscribePromises = [];
		    ref = this._handlerFunctions[projectionId];
		    for (i = 0, len = ref.length; i < len; i++) {
		      subscriberId = ref[i];
		      unsubscribePromises.push(this._context.unsubscribeFromDomainEvent(subscriberId));
		    }
		    delete this._handlerFunctions[projectionId];
		    delete this._projectionInstances[projectionId];
		    return Promise.all(unsubscribePromises);
		  };

		  return Projection;

		})();

		module.exports = Projection;


	/***/ },
	/* 11 */
	/***/ function(module, exports, __webpack_require__) {

		module.exports = __webpack_require__(12);


	/***/ },
	/* 12 */
	/***/ function(module, exports) {

		var UidGenerator;

		UidGenerator = (function() {
		  function UidGenerator() {}

		  UidGenerator.prototype.generateUid = function(delimiter) {
		    if (delimiter == null) {
		      delimiter = "-";
		    }
		    return this._s4() + this._s4() + delimiter + this._s4() + delimiter + this._s4() + delimiter + this._s4() + delimiter + this._s4() + this._s4() + this._s4();
		  };

		  UidGenerator.prototype._s4 = function() {
		    return (((1 + Math.random()) * 0x10000) | 0).toString(16).substring(1);
		  };

		  return UidGenerator;

		})();

		module.exports = new UidGenerator;


	/***/ },
	/* 13 */
	/***/ function(module, exports, __webpack_require__) {

		module.exports = __webpack_require__(14);


	/***/ },
	/* 14 */
	/***/ function(module, exports, __webpack_require__) {

		var AggregateRepository, Context, DomainEvent, EventBus, Projection, logger, uidGenerator,
		  bind = function(fn, me){ return function(){ return fn.apply(me, arguments); }; },
		  slice = [].slice;

		EventBus = __webpack_require__(19);

		Projection = __webpack_require__(9);

		DomainEvent = __webpack_require__(22);

		AggregateRepository = __webpack_require__(15);

		logger = __webpack_require__(7);

		uidGenerator = __webpack_require__(11);

		Context = (function() {
		  function Context(name, _storeDefinition) {
		    this.name = name;
		    this._storeDefinition = _storeDefinition;
		    this._getAggregateRepository = bind(this._getAggregateRepository, this);
		    this._isInitialized = false;
		    this._isDestroyed = false;
		    this._di = {
		      $query: (function(_this) {
		        return function() {
		          return _this.query.apply(_this, arguments);
		        };
		      })(this)
		    };
		    this._aggregateClasses = {};
		    this._commandHandlers = {};
		    this._queryHandlers = {};
		    this._domainEventClasses = {};
		    this._domainEventHandlers = {};
		    this._projectionClasses = {};
		    this._repositoryInstances = {};
		    this._storeInstance = null;
		    this._pendingPromises = [];
		    this._eventBus = new EventBus;
		    this.projectionService = new Projection(this);
		  }

		  Context.prototype.defineDomainEvent = function(domainEventName, DomainEventClass) {
		    this._domainEventClasses[domainEventName] = DomainEventClass;
		    return this;
		  };

		  Context.prototype.defineDomainEvents = function(domainEventClassesObj) {
		    var DomainEventClass, domainEventName;
		    for (domainEventName in domainEventClassesObj) {
		      DomainEventClass = domainEventClassesObj[domainEventName];
		      this.defineDomainEvent(domainEventName, DomainEventClass);
		    }
		    return this;
		  };

		  Context.prototype.addCommandHandlers = function(commands) {
		    var commandFunction, commandHandlerName;
		    for (commandHandlerName in commands) {
		      commandFunction = commands[commandHandlerName];
		      this._commandHandlers[commandHandlerName] = commandFunction;
		    }
		    return this;
		  };

		  Context.prototype.addQueryHandlers = function(queries) {
		    var queryFunction, queryHandlerName;
		    for (queryHandlerName in queries) {
		      queryFunction = queries[queryHandlerName];
		      this._queryHandlers[queryHandlerName] = queryFunction;
		    }
		    return this;
		  };

		  Context.prototype.addAggregate = function(aggregateName, AggregateClass) {
		    this._aggregateClasses[aggregateName] = AggregateClass;
		    return this;
		  };

		  Context.prototype.subscribeToAllDomainEvents = function(handlerFn) {
		    var domainEventHandler;
		    domainEventHandler = (function(_this) {
		      return function() {
		        return handlerFn.apply(_this._di, arguments);
		      };
		    })(this);
		    return this._eventBus.subscribeToAllDomainEvents(domainEventHandler);
		  };

		  Context.prototype.subscribeToDomainEvent = function(domainEventName, handlerFn) {
		    var domainEventHandler;
		    domainEventHandler = (function(_this) {
		      return function() {
		        return handlerFn.apply(_this._di, arguments);
		      };
		    })(this);
		    return this._eventBus.subscribeToDomainEvent(domainEventName, domainEventHandler);
		  };

		  Context.prototype.subscribeToDomainEvents = function(domainEventHandlersObj) {
		    var domainEventName, handlerFn, results;
		    results = [];
		    for (domainEventName in domainEventHandlersObj) {
		      handlerFn = domainEventHandlersObj[domainEventName];
		      results.push(this.subscribeToDomainEvent(domainEventName, handlerFn));
		    }
		    return results;
		  };

		  Context.prototype.subscribeToDomainEventWithAggregateId = function(domainEventName, aggregateId, handlerFn) {
		    var domainEventHandler;
		    domainEventHandler = (function(_this) {
		      return function() {
		        return handlerFn.apply(_this._di, arguments);
		      };
		    })(this);
		    return this._eventBus.subscribeToDomainEventWithAggregateId(domainEventName, aggregateId, domainEventHandler);
		  };

		  Context.prototype.addProjection = function(projectionName, ProjectionClass) {
		    this._projectionClasses[projectionName] = ProjectionClass;
		    return this;
		  };

		  Context.prototype.addProjections = function(viewsObj) {
		    var ProjectionClass, projectionName;
		    for (projectionName in viewsObj) {
		      ProjectionClass = viewsObj[projectionName];
		      this.addProjection(projectionName, ProjectionClass);
		    }
		    return this;
		  };

		  Context.prototype.getProjectionInstance = function(projectionId) {
		    return this.projectionService.getInstance(projectionId);
		  };

		  Context.prototype.destroyProjectionInstance = function(projectionId) {
		    return this.projectionService.destroyInstance(projectionId, this);
		  };

		  Context.prototype.initialize = function() {
		    logger.debug("[" + this.name + "] Initializing");
		    logger.debug("[" + this.name + "] Initializing Store");
		    return this._initializeStore().then((function(_this) {
		      return function() {
		        logger.debug("[" + _this.name + "] Initializing Projections");
		        return _this._initializeProjections();
		      };
		    })(this)).then((function(_this) {
		      return function() {
		        return _this._isInitialized = true;
		      };
		    })(this));
		  };

		  Context.prototype._initializeStore = function() {
		    var initializeStorePromise;
		    this._storeInstance = new this._storeDefinition.Class;
		    initializeStorePromise = this._storeInstance.initialize(this, this._storeDefinition.options);
		    return initializeStorePromise;
		  };

		  Context.prototype._initializeProjections = function() {
		    var ProjectionClass, initializeProjectionsPromise, projectionName, ref;
		    initializeProjectionsPromise = Promise.resolve();
		    ref = this._projectionClasses;
		    for (projectionName in ref) {
		      ProjectionClass = ref[projectionName];
		      logger.debug("[" + this.name + "] Initializing Projection " + projectionName);
		      initializeProjectionsPromise = initializeProjectionsPromise.then((function(_this) {
		        return function() {
		          return _this.projectionService.initializeInstance(projectionName, ProjectionClass, {});
		        };
		      })(this)).then((function(_this) {
		        return function(projectionId) {
		          return logger.debug("[" + _this.name + "] Finished initializing Projection " + projectionName);
		        };
		      })(this));
		    }
		    return initializeProjectionsPromise;
		  };

		  Context.prototype.createDomainEvent = function(domainEventName, DomainEventClass, domainEventPayload, aggregate) {
		    var payload;
		    payload = {};
		    DomainEventClass.apply(payload, [domainEventPayload]);
		    return new DomainEvent({
		      id: uidGenerator.generateUid(),
		      name: domainEventName,
		      aggregate: aggregate,
		      context: this.name,
		      payload: payload
		    });
		  };

		  Context.prototype.initializeProjectionInstance = function(projectionName, params) {
		    if (!this._projectionClasses[projectionName]) {
		      return Promise.reject(new Error("Given projection " + projectionName + " not registered on context"));
		    }
		    return this.projectionService.initializeInstance(projectionName, this._projectionClasses[projectionName], params);
		  };

		  Context.prototype.getProjection = function(projectionId) {
		    return this.projectionService.getInstance(projectionId);
		  };

		  Context.prototype.getDomainEvent = function(domainEventName) {
		    return this._domainEventClasses[domainEventName];
		  };

		  Context.prototype.getDomainEventsStore = function() {
		    return this._storeInstance;
		  };

		  Context.prototype.getEventBus = function() {
		    return this._eventBus;
		  };

		  Context.prototype.findDomainEventsByName = function() {
		    var findArguments;
		    findArguments = 1 <= arguments.length ? slice.call(arguments, 0) : [];
		    return new Promise((function(_this) {
		      return function(resolve, reject) {
		        var ref;
		        return (ref = _this.getDomainEventsStore()).findDomainEventsByName.apply(ref, slice.call(findArguments).concat([function(err, events) {
		          if (err) {
		            return reject(err);
		          }
		          return resolve(events);
		        }]));
		      };
		    })(this));
		  };

		  Context.prototype.findDomainEventsByNameAndAggregateId = function() {
		    var findArguments;
		    findArguments = 1 <= arguments.length ? slice.call(arguments, 0) : [];
		    return new Promise((function(_this) {
		      return function(resolve, reject) {
		        var ref;
		        return (ref = _this.getDomainEventsStore()).findDomainEventsByNameAndAggregateId.apply(ref, slice.call(findArguments).concat([function(err, events) {
		          if (err) {
		            return reject(err);
		          }
		          return resolve(events);
		        }]));
		      };
		    })(this));
		  };

		  Context.prototype.command = function(commandName, params) {
		    var executingCommand;
		    if (this._isDestroyed) {
		      Promise.reject(new Error("Context " + this.name + " was destroyed, cannot execute command " + commandName + " with arguments " + (JSON.stringify(params))));
		      return;
		    }
		    executingCommand = new Promise((function(_this) {
		      return function(resolve, reject) {
		        var commandServicesToInject;
		        _this._verifyContextIsInitialized(commandName);
		        if (!_this._commandHandlers[commandName]) {
		          throw new Error("Given command " + commandName + " not registered on context");
		        }
		        commandServicesToInject = _this._getCommandServicesToInject();
		        return Promise.resolve(_this._commandHandlers[commandName].apply(commandServicesToInject, [params])).then(function(result) {
		          logger.debug('Completed Command', commandName);
		          return resolve(result);
		        })["catch"](reject);
		      };
		    })(this));
		    this._addPendingPromise(executingCommand);
		    return executingCommand;
		  };

		  Context.prototype._getCommandServicesToInject = function() {
		    var diFn, diFnName, ref, servicesToInject;
		    servicesToInject = {};
		    ref = this._di;
		    for (diFnName in ref) {
		      diFn = ref[diFnName];
		      servicesToInject[diFnName] = diFn;
		    }
		    servicesToInject.$aggregate = {
		      create: (function(_this) {
		        return function() {
		          var aggregateName, aggregateParams, aggregateRepository;
		          aggregateName = arguments[0], aggregateParams = 2 <= arguments.length ? slice.call(arguments, 1) : [];
		          aggregateRepository = _this._getAggregateRepository(aggregateName);
		          return aggregateRepository.create.apply(aggregateRepository, aggregateParams);
		        };
		      })(this),
		      load: (function(_this) {
		        return function(aggregateName, aggregateId) {
		          var aggregateRepository;
		          aggregateRepository = _this._getAggregateRepository(aggregateName);
		          return aggregateRepository.load(aggregateId);
		        };
		      })(this)
		    };
		    return servicesToInject;
		  };

		  Context.prototype._getAggregateRepository = function(aggregateName) {
		    var AggregateClass, aggregateRepositoriesCache, aggregateRepository;
		    if (!aggregateRepositoriesCache) {
		      aggregateRepositoriesCache = {};
		    }
		    if (!aggregateRepositoriesCache[aggregateName]) {
		      AggregateClass = this._aggregateClasses[aggregateName];
		      aggregateRepository = new AggregateRepository({
		        aggregateName: aggregateName,
		        AggregateClass: AggregateClass,
		        context: this
		      });
		      aggregateRepositoriesCache[aggregateName] = aggregateRepository;
		    }
		    return aggregateRepositoriesCache[aggregateName];
		  };

		  Context.prototype._addPendingPromise = function(pendingPromise) {
		    var alwaysResolvingPromise;
		    alwaysResolvingPromise = pendingPromise["catch"](function() {});
		    this._pendingPromises.push(alwaysResolvingPromise);
		    return alwaysResolvingPromise.then((function(_this) {
		      return function() {
		        return _this._pendingPromises.splice(_this._pendingPromises.indexOf(alwaysResolvingPromise), 1);
		      };
		    })(this));
		  };

		  Context.prototype.query = function(queryName, params) {
		    return new Promise((function(_this) {
		      return function(resolve, reject) {
		        logger.debug('Got Query', queryName);
		        _this._verifyContextIsInitialized(queryName);
		        if (!_this._queryHandlers[queryName]) {
		          reject(new Error("Given query " + queryName + " not registered on context"));
		          return;
		        }
		        return Promise.resolve(_this._queryHandlers[queryName].apply(_this._di, [params])).then(function(result) {
		          logger.debug("Completed Query " + queryName + " with Result " + result);
		          return resolve(result);
		        })["catch"](reject);
		      };
		    })(this));
		  };

		  Context.prototype._verifyContextIsInitialized = function(methodName) {
		    if (!this._isInitialized) {
		      throw new Error("Context " + this.name + " not initialized yet, cannot execute " + methodName);
		    }
		  };

		  Context.prototype.destroy = function() {
		    return Promise.all(this._pendingPromises).then((function(_this) {
		      return function() {
		        return _this._eventBus.destroy().then(function() {
		          return _this._isDestroyed = true;
		        });
		      };
		    })(this));
		  };

		  return Context;

		})();

		module.exports = Context;


	/***/ },
	/* 15 */
	/***/ function(module, exports, __webpack_require__) {

		module.exports = __webpack_require__(16);


	/***/ },
	/* 16 */
	/***/ function(module, exports, __webpack_require__) {

		var Aggregate, AggregateRepository, logger, uidGenerator,
		  bind = function(fn, me){ return function(){ return fn.apply(me, arguments); }; };

		Aggregate = __webpack_require__(17);

		logger = __webpack_require__(7);

		uidGenerator = __webpack_require__(11);

		AggregateRepository = (function() {
		  function AggregateRepository(params) {
		    this.save = bind(this.save, this);
		    this.create = bind(this.create, this);
		    this.load = bind(this.load, this);
		    this._aggregateName = params.aggregateName;
		    this._AggregateClass = params.AggregateClass;
		    this._context = params.context;
		    this._store = this._context.getDomainEventsStore();
		  }

		  AggregateRepository.prototype.load = function(aggregateId) {
		    return new Promise((function(_this) {
		      return function(resolve, reject) {
		        return _this._store.findDomainEventsByAggregateId(aggregateId, function(error, domainEvents) {
		          var aggregate;
		          if (error) {
		            reject(error);
		            return;
		          }
		          if (!domainEvents.length) {
		            reject(new Error("No domainEvents for " + _this._aggregateName + " Aggregate with " + aggregateId + " available"));
		            return;
		          }
		          aggregate = new Aggregate(_this._context, _this._aggregateName, _this._AggregateClass);
		          aggregate.applyDomainEvents(domainEvents);
		          aggregate.id = aggregate.instance.$id = aggregateId;
		          aggregate.instance.$save = function() {
		            return _this.save(aggregate);
		          };
		          return resolve(aggregate.instance);
		        });
		      };
		    })(this));
		  };

		  AggregateRepository.prototype.create = function(params) {
		    return new Promise((function(_this) {
		      return function(resolve, reject) {
		        var aggregate;
		        aggregate = new Aggregate(_this._context, _this._aggregateName, _this._AggregateClass);
		        if (typeof aggregate.instance.create !== 'function') {
		          throw new Error("No create function on aggregate");
		        }
		        aggregate.id = aggregate.instance.$id = uidGenerator.generateUid();
		        aggregate.instance.$save = function() {
		          return _this.save(aggregate);
		        };
		        return Promise.resolve(aggregate.instance.create(params)).then(function() {
		          return resolve(aggregate.instance);
		        })["catch"](reject);
		      };
		    })(this));
		  };

		  AggregateRepository.prototype.save = function(aggregate) {
		    return new Promise((function(_this) {
		      return function(resolve, reject) {
		        var domainEvents, saveDomainEventQueue;
		        if (!aggregate) {
		          throw new Error("Tried to save unknown aggregate " + _this._aggregateName);
		        }
		        domainEvents = aggregate.getDomainEvents();
		        if (domainEvents.length < 1) {
		          throw new Error("Tried to save 0 DomainEvents from Aggregate " + _this._aggregateName);
		        }
		        logger.debug("Going to Save and Publish " + domainEvents.length + " DomainEvents from Aggregate " + _this._aggregateName);
		        saveDomainEventQueue = Promise.resolve();
		        domainEvents.forEach(function(domainEvent) {
		          return saveDomainEventQueue = saveDomainEventQueue.then(function() {
		            return _this._store.saveDomainEvent(domainEvent);
		          }).then(function() {
		            return logger.debug("Saved DomainEvent", domainEvent);
		          });
		        });
		        return saveDomainEventQueue.then(function() {
		          return domainEvents.forEach(function(domainEvent) {
		            logger.debug("Publishing DomainEvent", domainEvent);
		            return _this._context.getEventBus().publishDomainEvent(domainEvent)["catch"](function(error) {
		              return logger.error(error.stack || error);
		            });
		          });
		        }).then(function() {
		          return resolve(aggregate.id);
		        })["catch"](reject);
		      };
		    })(this));
		  };

		  return AggregateRepository;

		})();

		module.exports = AggregateRepository;


	/***/ },
	/* 17 */
	/***/ function(module, exports, __webpack_require__) {

		module.exports = __webpack_require__(18);


	/***/ },
	/* 18 */
	/***/ function(module, exports, __webpack_require__) {

		var Aggregate, logger,
		  bind = function(fn, me){ return function(){ return fn.apply(me, arguments); }; };

		logger = __webpack_require__(7);

		Aggregate = (function() {
		  function Aggregate(_context, _name, AggregateClass) {
		    this._context = _context;
		    this._name = _name;
		    this.getDomainEvents = bind(this.getDomainEvents, this);
		    this.emitDomainEvent = bind(this.emitDomainEvent, this);
		    this._domainEvents = [];
		    this.instance = new AggregateClass;
		    this.instance.$emitDomainEvent = this.emitDomainEvent;
		  }

		  Aggregate.prototype.emitDomainEvent = function(domainEventName, domainEventPayload) {
		    var DomainEventClass, aggregate, domainEvent;
		    DomainEventClass = this._context.getDomainEvent(domainEventName);
		    if (!DomainEventClass) {
		      throw new Error("Tried to emitDomainEvent '" + domainEventName + "' which is not defined");
		    }
		    aggregate = {
		      id: this.id,
		      name: this._name
		    };
		    domainEvent = this._context.createDomainEvent(domainEventName, DomainEventClass, domainEventPayload, aggregate);
		    this._domainEvents.push(domainEvent);
		    this._handleDomainEvent(domainEventName, domainEvent);
		    return logger.debug("Created and Handled DomainEvent in Aggregate", domainEvent);
		  };

		  Aggregate.prototype._handleDomainEvent = function(domainEventName, domainEvent) {
		    if (this.instance["handle" + domainEventName]) {
		      return this.instance["handle" + domainEventName](domainEvent);
		    } else {
		      return logger.debug("Tried to handle the DomainEvent '" + domainEventName + "' without a matching handle method");
		    }
		  };

		  Aggregate.prototype.getDomainEvents = function() {
		    return this._domainEvents;
		  };

		  Aggregate.prototype.applyDomainEvents = function(domainEvents) {
		    var domainEvent, i, len, results;
		    results = [];
		    for (i = 0, len = domainEvents.length; i < len; i++) {
		      domainEvent = domainEvents[i];
		      results.push(this._applyDomainEvent(domainEvent));
		    }
		    return results;
		  };

		  Aggregate.prototype._applyDomainEvent = function(domainEvent) {
		    return this._handleDomainEvent(domainEvent.name, domainEvent);
		  };

		  return Aggregate;

		})();

		module.exports = Aggregate;


	/***/ },
	/* 19 */
	/***/ function(module, exports, __webpack_require__) {

		module.exports = __webpack_require__(20);


	/***/ },
	/* 20 */
	/***/ function(module, exports, __webpack_require__) {

		var EventBus, Subscriber;

		Subscriber = __webpack_require__(21);

		EventBus = (function() {
		  function EventBus() {
		    this._subscribers = [];
		    this._subscriberId = 0;
		    this._eventPublishQueue = Promise.resolve();
		    this._isDestroyed = false;
		  }

		  EventBus.prototype.subscribeToAllDomainEvents = function(subscriberFunction) {
		    return this._subscribe('*', subscriberFunction);
		  };

		  EventBus.prototype.subscribeToDomainEvent = function(eventName, subscriberFunction) {
		    return this._subscribe(eventName, subscriberFunction);
		  };

		  EventBus.prototype.subscribeToDomainEventWithAggregateId = function(eventName, aggregateId, subscriberFunction) {
		    return this._subscribe(eventName + "/" + aggregateId, subscriberFunction);
		  };

		  EventBus.prototype._subscribe = function(eventName, subscriberFunction) {
		    return new Promise((function(_this) {
		      return function(resolve) {
		        var subscriber;
		        subscriber = new Subscriber({
		          eventName: eventName,
		          subscriberFunction: subscriberFunction,
		          subscriberId: _this._getNextSubscriberId()
		        });
		        _this._subscribers.push(subscriber);
		        return resolve(subscriber.subscriberId);
		      };
		    })(this));
		  };

		  EventBus.prototype._getNextSubscriberId = function() {
		    return this._subscriberId++;
		  };

		  EventBus.prototype.publishDomainEvent = function(domainEvent) {
		    return new Promise((function(_this) {
		      return function(resolve, reject) {
		        var publishOperation;
		        _this._verifyPublishIsPossible(domainEvent);
		        publishOperation = function() {
		          return _this._notifySubscribers(domainEvent).then(resolve)["catch"](reject);
		        };
		        return _this._enqueueEventPublishing(publishOperation);
		      };
		    })(this));
		  };

		  EventBus.prototype._verifyPublishIsPossible = function(domainEvent) {
		    var errorMessage, ref;
		    if (this._isDestroyed) {
		      errorMessage = "Event Bus was destroyed, cannot publish " + domainEvent.name + "\nwith payload " + (JSON.stringify(domainEvent.payload));
		      if ((ref = domainEvent.aggregate) != null ? ref.id : void 0) {
		        errorMessage += " and aggregate id " + domainEvent.aggregate.id;
		      }
		      throw new Error(errorMessage);
		    }
		  };

		  EventBus.prototype._notifySubscribers = function(domainEvent) {
		    return Promise.resolve().then((function(_this) {
		      return function() {
		        var subscribers;
		        subscribers = _this._getSubscribersForDomainEvent(domainEvent);
		        return Promise.all(subscribers.map(function(subscriber) {
		          return subscriber.subscriberFunction(domainEvent);
		        }));
		      };
		    })(this));
		  };

		  EventBus.prototype._getSubscribersForDomainEvent = function(domainEvent) {
		    var ref, subscribers;
		    subscribers = this._subscribers.filter(function(subscriber) {
		      return subscriber.eventName === '*';
		    });
		    subscribers = subscribers.concat(this._subscribers.filter(function(subscriber) {
		      return subscriber.eventName === domainEvent.name;
		    }));
		    if ((ref = domainEvent.aggregate) != null ? ref.id : void 0) {
		      subscribers = subscribers.concat(this._subscribers.filter(function(subscriber) {
		        return subscriber.eventName === (domainEvent.name + "/" + domainEvent.aggregate.id);
		      }));
		    }
		    return subscribers;
		  };

		  EventBus.prototype._enqueueEventPublishing = function(publishOperation) {
		    return this._eventPublishQueue = this._eventPublishQueue.then(publishOperation);
		  };

		  EventBus.prototype.unsubscribe = function(subscriberId) {
		    return Promise.resolve().then((function(_this) {
		      return function() {
		        return _this._subscribers = _this._subscribers.filter(function(subscriber) {
		          return subscriber.subscriberId !== subscriberId;
		        });
		      };
		    })(this));
		  };

		  EventBus.prototype.destroy = function() {
		    return this._waitForEventPublishQueue().then((function(_this) {
		      return function() {
		        return _this._isDestroyed = true;
		      };
		    })(this));
		  };

		  EventBus.prototype._waitForEventPublishQueue = function() {
		    var currentEventPublishQueue;
		    currentEventPublishQueue = this._eventPublishQueue;
		    return currentEventPublishQueue.then((function(_this) {
		      return function() {
		        if (_this._eventPublishQueue !== currentEventPublishQueue) {
		          return _this._waitForEventPublishQueue();
		        }
		      };
		    })(this));
		  };

		  return EventBus;

		})();

		module.exports = EventBus;


	/***/ },
	/* 21 */
	/***/ function(module, exports) {

		var Subscriber;

		Subscriber = (function() {
		  function Subscriber(arg) {
		    this.eventName = arg.eventName, this.subscriberFunction = arg.subscriberFunction, this.subscriberId = arg.subscriberId;
		  }

		  return Subscriber;

		})();

		module.exports = Subscriber;


	/***/ },
	/* 22 */
	/***/ function(module, exports, __webpack_require__) {

		module.exports = __webpack_require__(23);


	/***/ },
	/* 23 */
	/***/ function(module, exports) {

		var DomainEvent;

		DomainEvent = (function() {
		  function DomainEvent(params) {
		    this.id = params.id;
		    this.name = params.name;
		    this.payload = params.payload;
		    this.aggregate = params.aggregate;
		    this.context = params.context;
		    this.timestamp = new Date().getTime();
		  }

		  return DomainEvent;

		})();

		module.exports = DomainEvent;


	/***/ },
	/* 24 */
	/***/ function(module, exports, __webpack_require__) {

		module.exports = __webpack_require__(25);


	/***/ },
	/* 25 */
	/***/ function(module, exports) {

		var InMemoryStore,
		  slice = [].slice;

		InMemoryStore = (function() {
		  function InMemoryStore() {}

		  InMemoryStore.prototype._domainEvents = {};

		  InMemoryStore.prototype._projections = {};

		  InMemoryStore.prototype.initialize = function() {
		    var _context, arg, options;
		    _context = arguments[0], arg = 2 <= arguments.length ? slice.call(arguments, 1) : [];
		    this._context = _context;
		    options = arg[0];
		    return new Promise((function(_this) {
		      return function(resolve, reject) {
		        _this._domainEventsCollectionName = _this._context.name + ".DomainEvents";
		        _this._projectionCollectionName = _this._context.name + ".Projections";
		        _this._domainEvents[_this._domainEventsCollectionName] = [];
		        return resolve();
		      };
		    })(this));
		  };

		  InMemoryStore.prototype.saveDomainEvent = function(domainEvent, callback) {
		    return new Promise((function(_this) {
		      return function(resolve, reject) {
		        _this._domainEvents[_this._domainEventsCollectionName].push(domainEvent);
		        return resolve(domainEvent);
		      };
		    })(this));
		  };

		  InMemoryStore.prototype.findDomainEventsByName = function(name, callback) {
		    var checkFn, events;
		    if (name instanceof Array) {
		      checkFn = function(eventName) {
		        return (name.indexOf(eventName)) > -1;
		      };
		    } else {
		      checkFn = function(eventName) {
		        return eventName === name;
		      };
		    }
		    events = this._domainEvents[this._domainEventsCollectionName].filter(function(event) {
		      return checkFn(event.name);
		    });
		    return callback(null, events);
		  };

		  InMemoryStore.prototype.findDomainEventsByNameAndAggregateId = function(name, aggregateId, callback) {
		    var checkAggregateIdFn, checkNameFn, events;
		    if (name instanceof Array) {
		      checkNameFn = function(eventName) {
		        return (name.indexOf(eventName)) > -1;
		      };
		    } else {
		      checkNameFn = function(eventName) {
		        return eventName === name;
		      };
		    }
		    if (aggregateId instanceof Array) {
		      checkAggregateIdFn = function(eventAggregateId) {
		        return (aggregateId.indexOf(eventAggregateId)) > -1;
		      };
		    } else {
		      checkAggregateIdFn = function(eventAggregateId) {
		        return eventAggregateId === aggregateId;
		      };
		    }
		    events = this._domainEvents[this._domainEventsCollectionName].filter(function(event) {
		      var ref;
		      return (checkNameFn(event.name)) && (checkAggregateIdFn((ref = event.aggregate) != null ? ref.id : void 0));
		    });
		    return callback(null, events);
		  };

		  InMemoryStore.prototype.findDomainEventsByAggregateId = function(aggregateId, callback) {
		    var checkFn, events;
		    if (aggregateId instanceof Array) {
		      checkFn = function(eventAggregateId) {
		        return (aggregateId.indexOf(eventAggregateId)) > -1;
		      };
		    } else {
		      checkFn = function(eventAggregateId) {
		        return eventAggregateId === aggregateId;
		      };
		    }
		    events = this._domainEvents[this._domainEventsCollectionName].filter(function(event) {
		      var ref;
		      return checkFn((ref = event.aggregate) != null ? ref.id : void 0);
		    });
		    return callback(null, events);
		  };

		  return InMemoryStore;

		})();

		module.exports = InMemoryStore;


	/***/ }
	/******/ ])
	});
	;

/***/ },
/* 48 */
/***/ function(module, exports, __webpack_require__) {

	"use strict";
	exports.spy = __webpack_require__(49);
	exports.stub = __webpack_require__(62);
	exports.spyCall = __webpack_require__(54);
	exports.mock = __webpack_require__(64);
	exports.expectation = __webpack_require__(65);
	exports.collection = __webpack_require__(66);
	exports.sandbox = __webpack_require__(67);
	exports.createStubInstance = __webpack_require__(70);
	exports.match = __webpack_require__(55);
	var deepEqual = __webpack_require__(57);
	exports.match.equal = deepEqual;
	var log = __webpack_require__(71);
	exports.log = log.log;
	exports.logError = log.logError;
	exports.restore = __webpack_require__(72);
	exports.format = __webpack_require__(58);

	// Should probably be split out as optional addons
	exports.assert = __webpack_require__(73);
	exports.test = __webpack_require__(74);
	exports.testCase = __webpack_require__(76);

	// Should probably no longer be exposed publicly
	var fn = __webpack_require__(52);
	exports.wrapMethod = __webpack_require__(51);
	exports.deepEqual = __webpack_require__(57);
	exports.extend = __webpack_require__(53);
	exports.functionToString = fn.toString;
	exports.create = fn.create;
	var config = __webpack_require__(75);
	exports.getConfig = config.getConfig;
	exports.defaultConfig = config.defaultConfig;
	exports.timesInWords = __webpack_require__(50);
	exports.typeOf = __webpack_require__(56);


/***/ },
/* 49 */
/***/ function(module, exports, __webpack_require__) {

	"use strict";
	var timesInWords = __webpack_require__(50);
	var wrapMethod = __webpack_require__(51);
	var fn = __webpack_require__(52);
	var extend = __webpack_require__(53);
	var spyCall = __webpack_require__(54);
	var deepEqual = __webpack_require__(57);
	var format = __webpack_require__(58);

	var push = Array.prototype.push;
	var slice = Array.prototype.slice;
	var callId = 0;

	function spy(object, property) {
	    if (!property && typeof object === "function") {
	        return spy.create(object);
	    }

	    if (!object && !property) {
	        return spy.create(function () { });
	    }

	    var method = object[property];
	    return wrapMethod(object, property, spy.create(method));
	}

	function matchingFake(fakes, args, strict) {
	    if (!fakes) {
	        return;
	    }

	    for (var i = 0, l = fakes.length; i < l; i++) {
	        if (fakes[i].matches(args, strict)) {
	            return fakes[i];
	        }
	    }
	}

	function incrementCallCount() {
	    this.called = true;
	    this.callCount += 1;
	    this.notCalled = false;
	    this.calledOnce = this.callCount == 1;
	    this.calledTwice = this.callCount == 2;
	    this.calledThrice = this.callCount == 3;
	}

	function createCallProperties() {
	    this.firstCall = this.getCall(0);
	    this.secondCall = this.getCall(1);
	    this.thirdCall = this.getCall(2);
	    this.lastCall = this.getCall(this.callCount - 1);
	    this.calledWithNew = !!(this.calledWithNew ||
	                            (this.lastCall && this.lastCall.calledWithNew()));
	}

	var vars = "a,b,c,d,e,f,g,h,i,j,k,l";
	function createProxy(func) {
	    // Retain the function length:
	    var p;
	    if (func.length) {
	        eval("p = (function proxy(" + vars.substring(0, func.length * 2 - 1) +
	             ") { return p.invoke(func, this, slice.call(arguments)); });");
	    } else {
	        p = function proxy() {
	            return p.invoke(func, this, slice.call(arguments));
	        };
	    }
	    return p;
	}

	var uuid = 0;

	// Public API
	var spyApi = {
	    reset: function () {
	        if (this.invoking) {
	            var err = new Error("Cannot reset Sinon function while invoking it. " +
	                                "Move the call to .reset outside of the callback.");
	            err.name = "InvalidResetException";
	            throw err;
	        }

	        this.called = false;
	        this.notCalled = true;
	        this.calledOnce = false;
	        this.calledTwice = false;
	        this.calledThrice = false;
	        this.callCount = 0;
	        this.firstCall = null;
	        this.secondCall = null;
	        this.thirdCall = null;
	        this.lastCall = null;
	        this.calledWithNew = false;
	        this.args = [];
	        this.returnValues = [];
	        this.thisValues = [];
	        this.exceptions = [];
	        this.callIds = [];
	        if (this.fakes) {
	            for (var i = 0; i < this.fakes.length; i++) {
	                this.fakes[i].reset();
	            }
	        }
	    },

	    create: function create(func) {
	        var name;

	        if (typeof func != "function") {
	            func = function () { };
	        } else {
	            name = fn.getName(func);
	        }

	        var proxy = createProxy(func);

	        extend(proxy, spy);
	        delete proxy.create;
	        extend(proxy, func);

	        proxy.reset();
	        proxy.prototype = func.prototype;
	        proxy.displayName = name || "spy";
	        proxy.toString = fn.toString;
	        proxy.instantiateFake = spy.create;
	        proxy.id = "spy#" + uuid++;

	        return proxy;
	    },

	    invoke: function invoke(func, thisValue, args) {
	        var matching = matchingFake(this.fakes, args);
	        var exception, returnValue;

	        incrementCallCount.call(this);
	        push.call(this.thisValues, thisValue);
	        push.call(this.args, args);
	        push.call(this.callIds, callId++);

	        // Make call properties available from within the spied function:
	        createCallProperties.call(this);

	        try {
	            this.invoking = true;

	            if (matching) {
	                returnValue = matching.invoke(func, thisValue, args);
	            } else {
	                returnValue = (this.func || func).apply(thisValue, args);
	            }

	            var thisCall = this.getCall(this.callCount - 1);
	            if (thisCall.calledWithNew() && typeof returnValue !== "object") {
	                returnValue = thisValue;
	            }
	        } catch (e) {
	            exception = e;
	        } finally {
	            delete this.invoking;
	        }

	        push.call(this.exceptions, exception);
	        push.call(this.returnValues, returnValue);

	        // Make return value and exception available in the calls:
	        createCallProperties.call(this);

	        if (exception !== undefined) {
	            throw exception;
	        }

	        return returnValue;
	    },

	    named: function named(name) {
	        this.displayName = name;
	        return this;
	    },

	    getCall: function getCall(i) {
	        if (i < 0 || i >= this.callCount) {
	            return null;
	        }

	        return spyCall(this, this.thisValues[i], this.args[i],
	                       this.returnValues[i], this.exceptions[i],
	                       this.callIds[i]);
	    },

	    getCalls: function () {
	        var calls = [];
	        var i;

	        for (i = 0; i < this.callCount; i++) {
	            calls.push(this.getCall(i));
	        }

	        return calls;
	    },

	    calledBefore: function calledBefore(spyFn) {
	        if (!this.called) {
	            return false;
	        }

	        if (!spyFn.called) {
	            return true;
	        }

	        return this.callIds[0] < spyFn.callIds[spyFn.callIds.length - 1];
	    },

	    calledAfter: function calledAfter(spyFn) {
	        if (!this.called || !spyFn.called) {
	            return false;
	        }

	        return this.callIds[this.callCount - 1] > spyFn.callIds[spyFn.callCount - 1];
	    },

	    withArgs: function () {
	        var args = slice.call(arguments);

	        if (this.fakes) {
	            var match = matchingFake(this.fakes, args, true);

	            if (match) {
	                return match;
	            }
	        } else {
	            this.fakes = [];
	        }

	        var original = this;
	        var fake = this.instantiateFake();
	        fake.matchingAguments = args;
	        fake.parent = this;
	        push.call(this.fakes, fake);

	        fake.withArgs = function () {
	            return original.withArgs.apply(original, arguments);
	        };

	        for (var i = 0; i < this.args.length; i++) {
	            if (fake.matches(this.args[i])) {
	                incrementCallCount.call(fake);
	                push.call(fake.thisValues, this.thisValues[i]);
	                push.call(fake.args, this.args[i]);
	                push.call(fake.returnValues, this.returnValues[i]);
	                push.call(fake.exceptions, this.exceptions[i]);
	                push.call(fake.callIds, this.callIds[i]);
	            }
	        }
	        createCallProperties.call(fake);

	        return fake;
	    },

	    matches: function (args, strict) {
	        var margs = this.matchingAguments;

	        if (margs.length <= args.length &&
	            deepEqual(margs, args.slice(0, margs.length))) {
	            return !strict || margs.length == args.length;
	        }
	    },

	    printf: function (fmt) {
	        var spy = this;
	        var args = slice.call(arguments, 1);
	        var formatter;

	        return (fmt || "").replace(/%(.)/g, function (match, specifyer) {
	            formatter = spyApi.formatters[specifyer];

	            if (typeof formatter == "function") {
	                return formatter.call(null, spy, args);
	            } else if (!isNaN(parseInt(specifyer, 10))) {
	                var a = args[specifyer - 1];
	                return format(a);
	            }
	            return "%" + specifyer;
	        });
	    }
	};

	function delegateToCalls(method, matchAny, actual, notCalled) {
	    spyApi[method] = function () {
	        if (!this.called) {
	            if (notCalled) {
	                return notCalled.apply(this, arguments);
	            }
	            return false;
	        }

	        var currentCall;
	        var matches = 0;

	        for (var i = 0, l = this.callCount; i < l; i += 1) {
	            currentCall = this.getCall(i);

	            if (currentCall[actual || method].apply(currentCall, arguments)) {
	                matches += 1;

	                if (matchAny) {
	                    return true;
	                }
	            }
	        }

	        return matches === this.callCount;
	    };
	}

	delegateToCalls("calledOn", true);
	delegateToCalls("alwaysCalledOn", false, "calledOn");
	delegateToCalls("calledWith", true);
	delegateToCalls("calledWithMatch", true);
	delegateToCalls("alwaysCalledWith", false, "calledWith");
	delegateToCalls("alwaysCalledWithMatch", false, "calledWithMatch");
	delegateToCalls("calledWithExactly", true);
	delegateToCalls("alwaysCalledWithExactly", false, "calledWithExactly");
	delegateToCalls("neverCalledWith", false, "notCalledWith",
	                function () { return true; });
	delegateToCalls("neverCalledWithMatch", false, "notCalledWithMatch",
	                function () { return true; });
	delegateToCalls("threw", true);
	delegateToCalls("alwaysThrew", false, "threw");
	delegateToCalls("returned", true);
	delegateToCalls("alwaysReturned", false, "returned");
	delegateToCalls("alwaysCalledWithNew", false, "calledWithNew");
	delegateToCalls("callArg", false, "callArgWith", function () {
	    throw new Error(this.toString() + " cannot call arg since it was not yet invoked.");
	});
	spyApi.callArgWith = spyApi.callArg;
	delegateToCalls("callArgOn", false, "callArgOnWith", function () {
	    throw new Error(this.toString() + " cannot call arg since it was not yet invoked.");
	});
	spyApi.callArgOnWith = spyApi.callArgOn;
	delegateToCalls("yield", false, "yield", function () {
	    throw new Error(this.toString() + " cannot yield since it was not yet invoked.");
	});
	// "invokeCallback" is an alias for "yield" since "yield" is invalid in strict mode.
	spyApi.invokeCallback = spyApi.yield;
	delegateToCalls("yieldOn", false, "yieldOn", function () {
	    throw new Error(this.toString() + " cannot yield since it was not yet invoked.");
	});
	delegateToCalls("yieldTo", false, "yieldTo", function (property) {
	    throw new Error(this.toString() + " cannot yield to '" + property +
	                    "' since it was not yet invoked.");
	});
	delegateToCalls("yieldToOn", false, "yieldToOn", function (property) {
	    throw new Error(this.toString() + " cannot yield to '" + property +
	                    "' since it was not yet invoked.");
	});

	spyApi.formatters = {
	    c: function (spy) {
	        return timesInWords(spy.callCount);
	    },

	    n: function (spy) {
	        return spy.toString();
	    },

	    C: function (spy) {
	        var calls = [];

	        for (var i = 0, l = spy.callCount; i < l; ++i) {
	            var stringifiedCall = "    " + spy.getCall(i).toString();
	            if (/\n/.test(calls[i - 1])) {
	                stringifiedCall = "\n" + stringifiedCall;
	            }
	            push.call(calls, stringifiedCall);
	        }

	        return calls.length > 0 ? "\n" + calls.join("\n") : "";
	    },

	    t: function (spy) {
	        var objects = [];

	        for (var i = 0, l = spy.callCount; i < l; ++i) {
	            push.call(objects, format(spy.thisValues[i]));
	        }

	        return objects.join(", ");
	    },

	    "*": function (spy, args) {
	        var formatted = [];

	        for (var i = 0, l = args.length; i < l; ++i) {
	            push.call(formatted, format(args[i]));
	        }

	        return formatted.join(", ");
	    }
	};

	extend(spy, spyApi);
	module.exports = spy;


/***/ },
/* 50 */
/***/ function(module, exports) {

	"use strict";
	module.exports = function timesInWords(count) {
	    switch (count) {
	    case 1:
	        return "once";
	    case 2:
	        return "twice";
	    case 3:
	        return "thrice";
	    default:
	        return (count || 0) + " times";
	    }
	};


/***/ },
/* 51 */
/***/ function(module, exports) {

	"use strict";
	var hasOwn = Object.prototype.hasOwnProperty;

	function mirrorProperties(target, source) {
	    for (var prop in source) {
	        if (!hasOwn.call(target, prop)) {
	            target[prop] = source[prop];
	        }
	    }
	}

	function isFunction(obj) {
	    return typeof obj === "function" || !!(obj && obj.constructor && obj.call && obj.apply);
	}

	module.exports = function wrapMethod(object, property, method) {
	    if (!object) {
	        throw new TypeError("Should wrap property of object");
	    }

	    if (typeof method !== "function") {
	        throw new TypeError("Method wrapper should be function");
	    }

	    var wrappedMethod = object[property],
	        error;

	    if (!isFunction(wrappedMethod)) {
	        error = new TypeError("Attempted to wrap " + (typeof wrappedMethod) + " property " +
	                              property + " as function");
	    } else if (wrappedMethod.restore && wrappedMethod.restore.sinon) {
	        error = new TypeError("Attempted to wrap " + property + " which is already wrapped");
	    } else if (wrappedMethod.calledBefore) {
	        var verb = !!wrappedMethod.returns ? "stubbed" : "spied on";
	        error = new TypeError("Attempted to wrap " + property + " which is already " + verb);
	    }

	    if (error) {
	        if (wrappedMethod && wrappedMethod.stackTrace) {
	            error.stack += "\n--------------\n" + wrappedMethod.stackTrace;
	        }
	        throw error;
	    }

	    // IE 8 does not support hasOwnProperty on the window object and Firefox has a problem
	    // when using hasOwn.call on objects from other frames.
	    var owned = object.hasOwnProperty ? object.hasOwnProperty(property) : hasOwn.call(object, property);
	    object[property] = method;
	    method.displayName = property;
	    // Set up a stack trace which can be used later to find what line of
	    // code the original method was created on.
	    method.stackTrace = (new Error("Stack Trace for original")).stack;

	    method.restore = function () {
	        // For prototype properties try to reset by delete first.
	        // If this fails (ex: localStorage on mobile safari) then force a reset
	        // via direct assignment.
	        if (!owned) {
	            delete object[property];
	        }
	        if (object[property] === method) {
	            object[property] = wrappedMethod;
	        }
	    };

	    method.restore.sinon = true;
	    mirrorProperties(method, wrappedMethod);

	    return method;
	};


/***/ },
/* 52 */
/***/ function(module, exports) {

	"use strict";
	exports.getName = function functionName(func) {
	    var name = func.displayName || func.name;

	    // Use function decomposition as a last resort to get function
	    // name. Does not rely on function decomposition to work - if it
	    // doesn't debugging will be slightly less informative
	    // (i.e. toString will say 'spy' rather than 'myFunc').
	    if (!name) {
	        var matches = func.toString().match(/function ([^\s\(]+)/);
	        name = matches && matches[1];
	    }

	    return name;
	};

	exports.toString = function toString() {
	    if (this.getCall && this.callCount) {
	        var thisValue, prop, i = this.callCount;

	        while (i--) {
	            thisValue = this.getCall(i).thisValue;

	            for (prop in thisValue) {
	                if (thisValue[prop] === this) {
	                    return prop;
	                }
	            }
	        }
	    }

	    return this.displayName || "sinon fake";
	};

	exports.create = function create(proto) {
	    var F = function () {};
	    F.prototype = proto;
	    return new F();
	};


/***/ },
/* 53 */
/***/ function(module, exports) {

	"use strict";
	// Adapted from https://developer.mozilla.org/en/docs/ECMAScript_DontEnum_attribute#JScript_DontEnum_Bug
	var hasDontEnumBug = (function () {
	    var obj = {
	        constructor: function () {
	            return "0";
	        },
	        toString: function () {
	            return "1";
	        },
	        valueOf: function () {
	            return "2";
	        },
	        toLocaleString: function () {
	            return "3";
	        },
	        prototype: function () {
	            return "4";
	        },
	        isPrototypeOf: function () {
	            return "5";
	        },
	        propertyIsEnumerable: function () {
	            return "6";
	        },
	        hasOwnProperty: function () {
	            return "7";
	        },
	        length: function () {
	            return "8";
	        },
	        unique: function () {
	            return "9"
	        }
	    };

	    var result = [];
	    for (var prop in obj) {
	        result.push(obj[prop]());
	    }
	    return result.join("") !== "0123456789";
	})();

	/* Public: Extend target in place with all (own) properties from sources in-order. Thus, last source will
	 *         override properties in previous sources.
	 *
	 * target - The Object to extend
	 * sources - Objects to copy properties from.
	 *
	 * Returns the extended target
	 */
	module.exports = function extend(target /*, sources */) {
	    var sources = Array.prototype.slice.call(arguments, 1),
	        source, i, prop;

	    for (i = 0; i < sources.length; i++) {
	        source = sources[i];

	        for (prop in source) {
	            if (source.hasOwnProperty(prop)) {
	                target[prop] = source[prop];
	            }
	        }

	        // Make sure we copy (own) toString method even when in JScript with DontEnum bug
	        // See https://developer.mozilla.org/en/docs/ECMAScript_DontEnum_attribute#JScript_DontEnum_Bug
	        if (hasDontEnumBug && source.hasOwnProperty("toString") && source.toString !== target.toString) {
	            target.toString = source.toString;
	        }
	    }

	    return target;
	};


/***/ },
/* 54 */
/***/ function(module, exports, __webpack_require__) {

	"use strict";
	var fn = __webpack_require__(52);
	var match = __webpack_require__(55);
	var deepEqual = __webpack_require__(57);
	var format = __webpack_require__(58);

	var slice = Array.prototype.slice;

	function throwYieldError(proxy, text, args) {
	    var msg = fn.getName(proxy) + text;
	    if (args.length) {
	        msg += " Received [" + slice.call(args).join(", ") + "]";
	    }
	    throw new Error(msg);
	}

	var callProto = {
	    calledOn: function calledOn(thisValue) {
	        if (match.isMatcher(thisValue)) {
	            return thisValue.test(this.thisValue);
	        }
	        return this.thisValue === thisValue;
	    },

	    calledWith: function calledWith() {
	        for (var i = 0, l = arguments.length; i < l; i += 1) {
	            if (!deepEqual(arguments[i], this.args[i])) {
	                return false;
	            }
	        }

	        return true;
	    },

	    calledWithMatch: function calledWithMatch() {
	        for (var i = 0, l = arguments.length; i < l; i += 1) {
	            var actual = this.args[i];
	            var expectation = arguments[i];
	            if (!match(expectation).test(actual)) {
	                return false;
	            }
	        }
	        return true;
	    },

	    calledWithExactly: function calledWithExactly() {
	        return arguments.length == this.args.length &&
	            this.calledWith.apply(this, arguments);
	    },

	    notCalledWith: function notCalledWith() {
	        return !this.calledWith.apply(this, arguments);
	    },

	    notCalledWithMatch: function notCalledWithMatch() {
	        return !this.calledWithMatch.apply(this, arguments);
	    },

	    returned: function returned(value) {
	        return deepEqual(value, this.returnValue);
	    },

	    threw: function threw(error) {
	        if (typeof error === "undefined" || !this.exception) {
	            return !!this.exception;
	        }

	        return this.exception === error || this.exception.name === error;
	    },

	    calledWithNew: function calledWithNew() {
	        return this.proxy.prototype && this.thisValue instanceof this.proxy;
	    },

	    calledBefore: function (other) {
	        return this.callId < other.callId;
	    },

	    calledAfter: function (other) {
	        return this.callId > other.callId;
	    },

	    callArg: function (pos) {
	        this.args[pos]();
	    },

	    callArgOn: function (pos, thisValue) {
	        this.args[pos].apply(thisValue);
	    },

	    callArgWith: function (pos) {
	        this.callArgOnWith.apply(this, [pos, null].concat(slice.call(arguments, 1)));
	    },

	    callArgOnWith: function (pos, thisValue) {
	        var args = slice.call(arguments, 2);
	        this.args[pos].apply(thisValue, args);
	    },

	    yield: function () {
	        this.yieldOn.apply(this, [null].concat(slice.call(arguments, 0)));
	    },

	    yieldOn: function (thisValue) {
	        var args = this.args;
	        for (var i = 0, l = args.length; i < l; ++i) {
	            if (typeof args[i] === "function") {
	                args[i].apply(thisValue, slice.call(arguments, 1));
	                return;
	            }
	        }
	        throwYieldError(this.proxy, " cannot yield since no callback was passed.", args);
	    },

	    yieldTo: function (prop) {
	        this.yieldToOn.apply(this, [prop, null].concat(slice.call(arguments, 1)));
	    },

	    yieldToOn: function (prop, thisValue) {
	        var args = this.args;
	        for (var i = 0, l = args.length; i < l; ++i) {
	            if (args[i] && typeof args[i][prop] === "function") {
	                args[i][prop].apply(thisValue, slice.call(arguments, 2));
	                return;
	            }
	        }
	        throwYieldError(this.proxy, " cannot yield to '" + prop +
	                        "' since no callback was passed.", args);
	    },

	    toString: function () {
	        var callStr = this.proxy.toString() + "(";
	        var args = [];

	        for (var i = 0, l = this.args.length; i < l; ++i) {
	            args.push(format(this.args[i]));
	        }

	        callStr = callStr + args.join(", ") + ")";

	        if (typeof this.returnValue != "undefined") {
	            callStr += " => " + format(this.returnValue);
	        }

	        if (this.exception) {
	            callStr += " !" + this.exception.name;

	            if (this.exception.message) {
	                callStr += "(" + this.exception.message + ")";
	            }
	        }

	        return callStr;
	    }
	};

	callProto.invokeCallback = callProto.yield;

	function createSpyCall(spy, thisValue, args, returnValue, exception, id) {
	    if (typeof id !== "number") {
	        throw new TypeError("Call id is not a number");
	    }
	    var proxyCall = fn.create(callProto);
	    proxyCall.proxy = spy;
	    proxyCall.thisValue = thisValue;
	    proxyCall.args = args;
	    proxyCall.returnValue = returnValue;
	    proxyCall.exception = exception;
	    proxyCall.callId = id;

	    return proxyCall;
	}
	createSpyCall.toString = callProto.toString; // used by mocks

	module.exports = createSpyCall;


/***/ },
/* 55 */
/***/ function(module, exports, __webpack_require__) {

	"use strict";
	var typeOf = __webpack_require__(56);
	var fn = __webpack_require__(52);

	function assertType(value, type, name) {
	    var actual = typeOf(value);
	    if (actual !== type) {
	        throw new TypeError("Expected type of " + name + " to be " +
	                            type + ", but was " + actual);
	    }
	}

	var matcher = {
	    toString: function () {
	        return this.message;
	    }
	};

	function isMatcher(object) {
	    return matcher.isPrototypeOf(object);
	}

	function matchObject(expectation, actual) {
	    if (actual === null || actual === undefined) {
	        return false;
	    }
	    for (var key in expectation) {
	        if (expectation.hasOwnProperty(key)) {
	            var exp = expectation[key];
	            var act = actual[key];
	            if (match.isMatcher(exp)) {
	                if (!exp.test(act)) {
	                    return false;
	                }
	            } else if (typeOf(exp) === "object") {
	                if (!matchObject(exp, act)) {
	                    return false;
	                }
	            } else if (!match.equal(exp, act)) {
	                return false;
	            }
	        }
	    }
	    return true;
	}

	matcher.or = function (m2) {
	    if (!arguments.length) {
	        throw new TypeError("Matcher expected");
	    } else if (!isMatcher(m2)) {
	        m2 = match(m2);
	    }
	    var m1 = this;
	    var or = fn.create(matcher);
	    or.test = function (actual) {
	        return m1.test(actual) || m2.test(actual);
	    };
	    or.message = m1.message + ".or(" + m2.message + ")";
	    return or;
	};

	matcher.and = function (m2) {
	    if (!arguments.length) {
	        throw new TypeError("Matcher expected");
	    } else if (!isMatcher(m2)) {
	        m2 = match(m2);
	    }
	    var m1 = this;
	    var and = fn.create(matcher);
	    and.test = function (actual) {
	        return m1.test(actual) && m2.test(actual);
	    };
	    and.message = m1.message + ".and(" + m2.message + ")";
	    return and;
	};

	var match = function (expectation, message) {
	    var m = fn.create(matcher);
	    var type = typeOf(expectation);
	    switch (type) {
	    case "object":
	        if (typeof expectation.test === "function") {
	            m.test = function (actual) {
	                return expectation.test(actual) === true;
	            };
	            m.message = "match(" + fn.getName(expectation.test) + ")";
	            return m;
	        }
	        var str = [];
	        for (var key in expectation) {
	            if (expectation.hasOwnProperty(key)) {
	                str.push(key + ": " + expectation[key]);
	            }
	        }
	        m.test = function (actual) {
	            return matchObject(expectation, actual);
	        };
	        m.message = "match(" + str.join(", ") + ")";
	        break;
	    case "number":
	        m.test = function (actual) {
	            return expectation == actual;
	        };
	        break;
	    case "string":
	        m.test = function (actual) {
	            if (typeof actual !== "string") {
	                return false;
	            }
	            return actual.indexOf(expectation) !== -1;
	        };
	        m.message = "match(\"" + expectation + "\")";
	        break;
	    case "regexp":
	        m.test = function (actual) {
	            if (typeof actual !== "string") {
	                return false;
	            }
	            return expectation.test(actual);
	        };
	        break;
	    case "function":
	        m.test = expectation;
	        if (message) {
	            m.message = message;
	        } else {
	            m.message = "match(" + fn.getName(expectation) + ")";
	        }
	        break;
	    default:
	        m.test = function (actual) {
	            return match.equal(expectation, actual);
	        };
	    }
	    if (!m.message) {
	        m.message = "match(" + expectation + ")";
	    }
	    return m;
	};

	match.isMatcher = isMatcher;

	match.any = match(function () {
	    return true;
	}, "any");

	match.defined = match(function (actual) {
	    return actual !== null && actual !== undefined;
	}, "defined");

	match.truthy = match(function (actual) {
	    return !!actual;
	}, "truthy");

	match.falsy = match(function (actual) {
	    return !actual;
	}, "falsy");

	match.same = function (expectation) {
	    return match(function (actual) {
	        return expectation === actual;
	    }, "same(" + expectation + ")");
	};

	match.typeOf = function (type) {
	    assertType(type, "string", "type");
	    return match(function (actual) {
	        return typeOf(actual) === type;
	    }, "typeOf(\"" + type + "\")");
	};

	match.instanceOf = function (type) {
	    assertType(type, "function", "type");
	    return match(function (actual) {
	        return actual instanceof type;
	    }, "instanceOf(" + fn.getName(type) + ")");
	};

	function createPropertyMatcher(propertyTest, messagePrefix) {
	    return function (property, value) {
	        assertType(property, "string", "property");
	        var onlyProperty = arguments.length === 1;
	        var message = messagePrefix + "(\"" + property + "\"";
	        if (!onlyProperty) {
	            message += ", " + value;
	        }
	        message += ")";
	        return match(function (actual) {
	            if (actual === undefined || actual === null ||
	                !propertyTest(actual, property)) {
	                return false;
	            }
	            return onlyProperty || match.equal(value, actual[property]);
	        }, message);
	    };
	}

	match.has = createPropertyMatcher(function (actual, property) {
	    if (typeof actual === "object") {
	        return property in actual;
	    }
	    return actual[property] !== undefined;
	}, "has");

	match.hasOwn = createPropertyMatcher(function (actual, property) {
	    return actual.hasOwnProperty(property);
	}, "hasOwn");

	match.bool = match.typeOf("boolean");
	match.number = match.typeOf("number");
	match.string = match.typeOf("string");
	match.object = match.typeOf("object");
	match.func = match.typeOf("function");
	match.array = match.typeOf("array");
	match.regexp = match.typeOf("regexp");
	match.date = match.typeOf("date");

	match.equal = function (a, b) {
	    return a == b;
	};

	module.exports = match;


/***/ },
/* 56 */
/***/ function(module, exports) {

	"use strict";
	module.exports = function typeOf(value) {
	    if (value === null) {
	        return "null";
	    }
	    if (value === undefined) {
	        return "undefined";
	    }
	    var string = Object.prototype.toString.call(value);
	    return string.substring(8, string.length - 1).toLowerCase();
	};


/***/ },
/* 57 */
/***/ function(module, exports, __webpack_require__) {

	"use strict";
	var match = __webpack_require__(55);

	var div = typeof document !== "undefined" && document.createElement("div");

	function isDOMNode(obj) {
	    var success = false;

	    try {
	        obj.appendChild(div);
	        success = div.parentNode == obj;
	    } catch (e) {
	        return false;
	    } finally {
	        try {
	            obj.removeChild(div);
	        } catch (e) {
	            // Remove failed, not much we can do about that
	        }
	    }

	    return success;
	}

	function isReallyNaN(val) {
	    return typeof val === "number" && isNaN(val);
	}

	function isElement(obj) {
	    return div && obj && obj.nodeType === 1 && isDOMNode(obj);
	}

	module.exports = function deepEqual(a, b) {
	    if (match.isMatcher(a)) {
	        return a.test(b);
	    }

	    if (typeof a !== "object" || typeof b !== "object") {
	        if (isReallyNaN(a) && isReallyNaN(b)) {
	            return true;
	        }
	        return a === b;
	    }

	    if (isElement(a) || isElement(b)) {
	        return a === b;
	    }

	    if (a === b) {
	        return true;
	    }

	    if ((a === null && b !== null) || (a !== null && b === null)) {
	        return false;
	    }

	    if (a instanceof RegExp && b instanceof RegExp) {
	        return (a.source === b.source) && (a.global === b.global) &&
	            (a.ignoreCase === b.ignoreCase) && (a.multiline === b.multiline);
	    }

	    var aString = Object.prototype.toString.call(a);
	    if (aString !== Object.prototype.toString.call(b)) {
	        return false;
	    }

	    if (aString === "[object Date]") {
	        return a.valueOf() === b.valueOf();
	    }

	    var prop, aLength = 0, bLength = 0;

	    if (aString == "[object Array]" && a.length !== b.length) {
	        return false;
	    }

	    for (prop in a) {
	        aLength += 1;

	        if (!(prop in b)) {
	            return false;
	        }

	        if (!deepEqual(a[prop], b[prop])) {
	            return false;
	        }
	    }

	    for (prop in b) {
	        bLength += 1;
	    }

	    return aLength == bLength;
	};


/***/ },
/* 58 */
/***/ function(module, exports, __webpack_require__) {

	"use strict";
	var formatio = __webpack_require__(59);

	var formatter = formatio.configure({
	    quoteStrings: false,
	    limitChildrenCount: 250
	});

	module.exports = function format() {
	    return formatter.ascii.apply(formatter, arguments);
	};


/***/ },
/* 59 */
/***/ function(module, exports, __webpack_require__) {

	var __WEBPACK_AMD_DEFINE_FACTORY__, __WEBPACK_AMD_DEFINE_ARRAY__, __WEBPACK_AMD_DEFINE_RESULT__;/* WEBPACK VAR INJECTION */(function(global) {(("function" === "function" && __webpack_require__(60) && function (m) {
	    !(__WEBPACK_AMD_DEFINE_ARRAY__ = [__webpack_require__(61)], __WEBPACK_AMD_DEFINE_FACTORY__ = (m), __WEBPACK_AMD_DEFINE_RESULT__ = (typeof __WEBPACK_AMD_DEFINE_FACTORY__ === 'function' ? (__WEBPACK_AMD_DEFINE_FACTORY__.apply(exports, __WEBPACK_AMD_DEFINE_ARRAY__)) : __WEBPACK_AMD_DEFINE_FACTORY__), __WEBPACK_AMD_DEFINE_RESULT__ !== undefined && (module.exports = __WEBPACK_AMD_DEFINE_RESULT__));
	}) || (typeof module === "object" && function (m) {
	    module.exports = m(__webpack_require__(61));
	}) || function (m) { this.formatio = m(this.samsam); }
	)(function (samsam) {
	    "use strict";

	    var formatio = {
	        excludeConstructors: ["Object", /^.$/],
	        quoteStrings: true,
	        limitChildrenCount: 0
	    };

	    var hasOwn = Object.prototype.hasOwnProperty;

	    var specialObjects = [];
	    if (typeof global !== "undefined") {
	        specialObjects.push({ object: global, value: "[object global]" });
	    }
	    if (typeof document !== "undefined") {
	        specialObjects.push({
	            object: document,
	            value: "[object HTMLDocument]"
	        });
	    }
	    if (typeof window !== "undefined") {
	        specialObjects.push({ object: window, value: "[object Window]" });
	    }

	    function functionName(func) {
	        if (!func) { return ""; }
	        if (func.displayName) { return func.displayName; }
	        if (func.name) { return func.name; }
	        var matches = func.toString().match(/function\s+([^\(]+)/m);
	        return (matches && matches[1]) || "";
	    }

	    function constructorName(f, object) {
	        var name = functionName(object && object.constructor);
	        var excludes = f.excludeConstructors ||
	                formatio.excludeConstructors || [];

	        var i, l;
	        for (i = 0, l = excludes.length; i < l; ++i) {
	            if (typeof excludes[i] === "string" && excludes[i] === name) {
	                return "";
	            } else if (excludes[i].test && excludes[i].test(name)) {
	                return "";
	            }
	        }

	        return name;
	    }

	    function isCircular(object, objects) {
	        if (typeof object !== "object") { return false; }
	        var i, l;
	        for (i = 0, l = objects.length; i < l; ++i) {
	            if (objects[i] === object) { return true; }
	        }
	        return false;
	    }

	    function ascii(f, object, processed, indent) {
	        if (typeof object === "string") {
	            if (object.length === 0) { return "(empty string)"; }
	            var qs = f.quoteStrings;
	            var quote = typeof qs !== "boolean" || qs;
	            return processed || quote ? '"' + object + '"' : object;
	        }

	        if (typeof object === "function" && !(object instanceof RegExp)) {
	            return ascii.func(object);
	        }

	        processed = processed || [];

	        if (isCircular(object, processed)) { return "[Circular]"; }

	        if (Object.prototype.toString.call(object) === "[object Array]") {
	            return ascii.array.call(f, object, processed);
	        }

	        if (!object) { return String((1/object) === -Infinity ? "-0" : object); }
	        if (samsam.isElement(object)) { return ascii.element(object); }

	        if (typeof object.toString === "function" &&
	                object.toString !== Object.prototype.toString) {
	            return object.toString();
	        }

	        var i, l;
	        for (i = 0, l = specialObjects.length; i < l; i++) {
	            if (object === specialObjects[i].object) {
	                return specialObjects[i].value;
	            }
	        }

	        return ascii.object.call(f, object, processed, indent);
	    }

	    ascii.func = function (func) {
	        return "function " + functionName(func) + "() {}";
	    };

	    ascii.array = function (array, processed) {
	        processed = processed || [];
	        processed.push(array);
	        var pieces = [];
	        var i, l;
	        l = (this.limitChildrenCount > 0) ? 
	            Math.min(this.limitChildrenCount, array.length) : array.length;

	        for (i = 0; i < l; ++i) {
	            pieces.push(ascii(this, array[i], processed));
	        }

	        if(l < array.length)
	            pieces.push("[... " + (array.length - l) + " more elements]");

	        return "[" + pieces.join(", ") + "]";
	    };

	    ascii.object = function (object, processed, indent) {
	        processed = processed || [];
	        processed.push(object);
	        indent = indent || 0;
	        var pieces = [], properties = samsam.keys(object).sort();
	        var length = 3;
	        var prop, str, obj, i, k, l;
	        l = (this.limitChildrenCount > 0) ? 
	            Math.min(this.limitChildrenCount, properties.length) : properties.length;

	        for (i = 0; i < l; ++i) {
	            prop = properties[i];
	            obj = object[prop];

	            if (isCircular(obj, processed)) {
	                str = "[Circular]";
	            } else {
	                str = ascii(this, obj, processed, indent + 2);
	            }

	            str = (/\s/.test(prop) ? '"' + prop + '"' : prop) + ": " + str;
	            length += str.length;
	            pieces.push(str);
	        }

	        var cons = constructorName(this, object);
	        var prefix = cons ? "[" + cons + "] " : "";
	        var is = "";
	        for (i = 0, k = indent; i < k; ++i) { is += " "; }

	        if(l < properties.length)
	            pieces.push("[... " + (properties.length - l) + " more elements]");

	        if (length + indent > 80) {
	            return prefix + "{\n  " + is + pieces.join(",\n  " + is) + "\n" +
	                is + "}";
	        }
	        return prefix + "{ " + pieces.join(", ") + " }";
	    };

	    ascii.element = function (element) {
	        var tagName = element.tagName.toLowerCase();
	        var attrs = element.attributes, attr, pairs = [], attrName, i, l, val;

	        for (i = 0, l = attrs.length; i < l; ++i) {
	            attr = attrs.item(i);
	            attrName = attr.nodeName.toLowerCase().replace("html:", "");
	            val = attr.nodeValue;
	            if (attrName !== "contenteditable" || val !== "inherit") {
	                if (!!val) { pairs.push(attrName + "=\"" + val + "\""); }
	            }
	        }

	        var formatted = "<" + tagName + (pairs.length > 0 ? " " : "");
	        // SVG elements have undefined innerHTML
	        var content = element.innerHTML || '';

	        if (content.length > 20) {
	            content = content.substr(0, 20) + "[...]";
	        }

	        var res = formatted + pairs.join(" ") + ">" + content +
	                "</" + tagName + ">";

	        return res.replace(/ contentEditable="inherit"/, "");
	    };

	    function Formatio(options) {
	        for (var opt in options) {
	            this[opt] = options[opt];
	        }
	    }

	    Formatio.prototype = {
	        functionName: functionName,

	        configure: function (options) {
	            return new Formatio(options);
	        },

	        constructorName: function (object) {
	            return constructorName(this, object);
	        },

	        ascii: function (object, processed, indent) {
	            return ascii(this, object, processed, indent);
	        }
	    };

	    return Formatio.prototype;
	});

	/* WEBPACK VAR INJECTION */}.call(exports, (function() { return this; }())))

/***/ },
/* 60 */
/***/ function(module, exports) {

	/* WEBPACK VAR INJECTION */(function(__webpack_amd_options__) {module.exports = __webpack_amd_options__;

	/* WEBPACK VAR INJECTION */}.call(exports, {}))

/***/ },
/* 61 */
/***/ function(module, exports, __webpack_require__) {

	var __WEBPACK_AMD_DEFINE_FACTORY__, __WEBPACK_AMD_DEFINE_RESULT__;(("function" === "function" && __webpack_require__(60) && function (m) { !(__WEBPACK_AMD_DEFINE_FACTORY__ = (m), __WEBPACK_AMD_DEFINE_RESULT__ = (typeof __WEBPACK_AMD_DEFINE_FACTORY__ === 'function' ? (__WEBPACK_AMD_DEFINE_FACTORY__.call(exports, __webpack_require__, exports, module)) : __WEBPACK_AMD_DEFINE_FACTORY__), __WEBPACK_AMD_DEFINE_RESULT__ !== undefined && (module.exports = __WEBPACK_AMD_DEFINE_RESULT__)); }) ||
	 (typeof module === "object" &&
	      function (m) { module.exports = m(); }) || // Node
	 function (m) { this.samsam = m(); } // Browser globals
	)(function () {
	    var o = Object.prototype;
	    var div = typeof document !== "undefined" && document.createElement("div");

	    function isNaN(value) {
	        // Unlike global isNaN, this avoids type coercion
	        // typeof check avoids IE host object issues, hat tip to
	        // lodash
	        var val = value; // JsLint thinks value !== value is "weird"
	        return typeof value === "number" && value !== val;
	    }

	    function getClass(value) {
	        // Returns the internal [[Class]] by calling Object.prototype.toString
	        // with the provided value as this. Return value is a string, naming the
	        // internal class, e.g. "Array"
	        return o.toString.call(value).split(/[ \]]/)[1];
	    }

	    /**
	     * @name samsam.isArguments
	     * @param Object object
	     *
	     * Returns ``true`` if ``object`` is an ``arguments`` object,
	     * ``false`` otherwise.
	     */
	    function isArguments(object) {
	        if (getClass(object) === 'Arguments') { return true; }
	        if (typeof object !== "object" || typeof object.length !== "number" ||
	                getClass(object) === "Array") {
	            return false;
	        }
	        if (typeof object.callee == "function") { return true; }
	        try {
	            object[object.length] = 6;
	            delete object[object.length];
	        } catch (e) {
	            return true;
	        }
	        return false;
	    }

	    /**
	     * @name samsam.isElement
	     * @param Object object
	     *
	     * Returns ``true`` if ``object`` is a DOM element node. Unlike
	     * Underscore.js/lodash, this function will return ``false`` if ``object``
	     * is an *element-like* object, i.e. a regular object with a ``nodeType``
	     * property that holds the value ``1``.
	     */
	    function isElement(object) {
	        if (!object || object.nodeType !== 1 || !div) { return false; }
	        try {
	            object.appendChild(div);
	            object.removeChild(div);
	        } catch (e) {
	            return false;
	        }
	        return true;
	    }

	    /**
	     * @name samsam.keys
	     * @param Object object
	     *
	     * Return an array of own property names.
	     */
	    function keys(object) {
	        var ks = [], prop;
	        for (prop in object) {
	            if (o.hasOwnProperty.call(object, prop)) { ks.push(prop); }
	        }
	        return ks;
	    }

	    /**
	     * @name samsam.isDate
	     * @param Object value
	     *
	     * Returns true if the object is a ``Date``, or *date-like*. Duck typing
	     * of date objects work by checking that the object has a ``getTime``
	     * function whose return value equals the return value from the object's
	     * ``valueOf``.
	     */
	    function isDate(value) {
	        return typeof value.getTime == "function" &&
	            value.getTime() == value.valueOf();
	    }

	    /**
	     * @name samsam.isNegZero
	     * @param Object value
	     *
	     * Returns ``true`` if ``value`` is ``-0``.
	     */
	    function isNegZero(value) {
	        return value === 0 && 1 / value === -Infinity;
	    }

	    /**
	     * @name samsam.equal
	     * @param Object obj1
	     * @param Object obj2
	     *
	     * Returns ``true`` if two objects are strictly equal. Compared to
	     * ``===`` there are two exceptions:
	     *
	     *   - NaN is considered equal to NaN
	     *   - -0 and +0 are not considered equal
	     */
	    function identical(obj1, obj2) {
	        if (obj1 === obj2 || (isNaN(obj1) && isNaN(obj2))) {
	            return obj1 !== 0 || isNegZero(obj1) === isNegZero(obj2);
	        }
	    }


	    /**
	     * @name samsam.deepEqual
	     * @param Object obj1
	     * @param Object obj2
	     *
	     * Deep equal comparison. Two values are "deep equal" if:
	     *
	     *   - They are equal, according to samsam.identical
	     *   - They are both date objects representing the same time
	     *   - They are both arrays containing elements that are all deepEqual
	     *   - They are objects with the same set of properties, and each property
	     *     in ``obj1`` is deepEqual to the corresponding property in ``obj2``
	     *
	     * Supports cyclic objects.
	     */
	    function deepEqualCyclic(obj1, obj2) {

	        // used for cyclic comparison
	        // contain already visited objects
	        var objects1 = [],
	            objects2 = [],
	        // contain pathes (position in the object structure)
	        // of the already visited objects
	        // indexes same as in objects arrays
	            paths1 = [],
	            paths2 = [],
	        // contains combinations of already compared objects
	        // in the manner: { "$1['ref']$2['ref']": true }
	            compared = {};

	        /**
	         * used to check, if the value of a property is an object
	         * (cyclic logic is only needed for objects)
	         * only needed for cyclic logic
	         */
	        function isObject(value) {

	            if (typeof value === 'object' && value !== null &&
	                    !(value instanceof Boolean) &&
	                    !(value instanceof Date)    &&
	                    !(value instanceof Number)  &&
	                    !(value instanceof RegExp)  &&
	                    !(value instanceof String)) {

	                return true;
	            }

	            return false;
	        }

	        /**
	         * returns the index of the given object in the
	         * given objects array, -1 if not contained
	         * only needed for cyclic logic
	         */
	        function getIndex(objects, obj) {

	            var i;
	            for (i = 0; i < objects.length; i++) {
	                if (objects[i] === obj) {
	                    return i;
	                }
	            }

	            return -1;
	        }

	        // does the recursion for the deep equal check
	        return (function deepEqual(obj1, obj2, path1, path2) {
	            var type1 = typeof obj1;
	            var type2 = typeof obj2;

	            // == null also matches undefined
	            if (obj1 === obj2 ||
	                    isNaN(obj1) || isNaN(obj2) ||
	                    obj1 == null || obj2 == null ||
	                    type1 !== "object" || type2 !== "object") {

	                return identical(obj1, obj2);
	            }

	            // Elements are only equal if identical(expected, actual)
	            if (isElement(obj1) || isElement(obj2)) { return false; }

	            var isDate1 = isDate(obj1), isDate2 = isDate(obj2);
	            if (isDate1 || isDate2) {
	                if (!isDate1 || !isDate2 || obj1.getTime() !== obj2.getTime()) {
	                    return false;
	                }
	            }

	            if (obj1 instanceof RegExp && obj2 instanceof RegExp) {
	                if (obj1.toString() !== obj2.toString()) { return false; }
	            }

	            var class1 = getClass(obj1);
	            var class2 = getClass(obj2);
	            var keys1 = keys(obj1);
	            var keys2 = keys(obj2);

	            if (isArguments(obj1) || isArguments(obj2)) {
	                if (obj1.length !== obj2.length) { return false; }
	            } else {
	                if (type1 !== type2 || class1 !== class2 ||
	                        keys1.length !== keys2.length) {
	                    return false;
	                }
	            }

	            var key, i, l,
	                // following vars are used for the cyclic logic
	                value1, value2,
	                isObject1, isObject2,
	                index1, index2,
	                newPath1, newPath2;

	            for (i = 0, l = keys1.length; i < l; i++) {
	                key = keys1[i];
	                if (!o.hasOwnProperty.call(obj2, key)) {
	                    return false;
	                }

	                // Start of the cyclic logic

	                value1 = obj1[key];
	                value2 = obj2[key];

	                isObject1 = isObject(value1);
	                isObject2 = isObject(value2);

	                // determine, if the objects were already visited
	                // (it's faster to check for isObject first, than to
	                // get -1 from getIndex for non objects)
	                index1 = isObject1 ? getIndex(objects1, value1) : -1;
	                index2 = isObject2 ? getIndex(objects2, value2) : -1;

	                // determine the new pathes of the objects
	                // - for non cyclic objects the current path will be extended
	                //   by current property name
	                // - for cyclic objects the stored path is taken
	                newPath1 = index1 !== -1
	                    ? paths1[index1]
	                    : path1 + '[' + JSON.stringify(key) + ']';
	                newPath2 = index2 !== -1
	                    ? paths2[index2]
	                    : path2 + '[' + JSON.stringify(key) + ']';

	                // stop recursion if current objects are already compared
	                if (compared[newPath1 + newPath2]) {
	                    return true;
	                }

	                // remember the current objects and their pathes
	                if (index1 === -1 && isObject1) {
	                    objects1.push(value1);
	                    paths1.push(newPath1);
	                }
	                if (index2 === -1 && isObject2) {
	                    objects2.push(value2);
	                    paths2.push(newPath2);
	                }

	                // remember that the current objects are already compared
	                if (isObject1 && isObject2) {
	                    compared[newPath1 + newPath2] = true;
	                }

	                // End of cyclic logic

	                // neither value1 nor value2 is a cycle
	                // continue with next level
	                if (!deepEqual(value1, value2, newPath1, newPath2)) {
	                    return false;
	                }
	            }

	            return true;

	        }(obj1, obj2, '$1', '$2'));
	    }

	    var match;

	    function arrayContains(array, subset) {
	        if (subset.length === 0) { return true; }
	        var i, l, j, k;
	        for (i = 0, l = array.length; i < l; ++i) {
	            if (match(array[i], subset[0])) {
	                for (j = 0, k = subset.length; j < k; ++j) {
	                    if (!match(array[i + j], subset[j])) { return false; }
	                }
	                return true;
	            }
	        }
	        return false;
	    }

	    /**
	     * @name samsam.match
	     * @param Object object
	     * @param Object matcher
	     *
	     * Compare arbitrary value ``object`` with matcher.
	     */
	    match = function match(object, matcher) {
	        if (matcher && typeof matcher.test === "function") {
	            return matcher.test(object);
	        }

	        if (typeof matcher === "function") {
	            return matcher(object) === true;
	        }

	        if (typeof matcher === "string") {
	            matcher = matcher.toLowerCase();
	            var notNull = typeof object === "string" || !!object;
	            return notNull &&
	                (String(object)).toLowerCase().indexOf(matcher) >= 0;
	        }

	        if (typeof matcher === "number") {
	            return matcher === object;
	        }

	        if (typeof matcher === "boolean") {
	            return matcher === object;
	        }

	        if (typeof(matcher) === "undefined") {
	            return typeof(object) === "undefined";
	        }

	        if (matcher === null) {
	            return object === null;
	        }

	        if (getClass(object) === "Array" && getClass(matcher) === "Array") {
	            return arrayContains(object, matcher);
	        }

	        if (matcher && typeof matcher === "object") {
	            if (matcher === object) {
	                return true;
	            }
	            var prop;
	            for (prop in matcher) {
	                var value = object[prop];
	                if (typeof value === "undefined" &&
	                        typeof object.getAttribute === "function") {
	                    value = object.getAttribute(prop);
	                }
	                if (matcher[prop] === null || typeof matcher[prop] === 'undefined') {
	                    if (value !== matcher[prop]) {
	                        return false;
	                    }
	                } else if (typeof  value === "undefined" || !match(value, matcher[prop])) {
	                    return false;
	                }
	            }
	            return true;
	        }

	        throw new Error("Matcher was not a string, a number, a " +
	                        "function, a boolean or an object");
	    };

	    return {
	        isArguments: isArguments,
	        isElement: isElement,
	        isDate: isDate,
	        isNegZero: isNegZero,
	        identical: identical,
	        deepEqual: deepEqualCyclic,
	        match: match,
	        keys: keys
	    };
	});


/***/ },
/* 62 */
/***/ function(module, exports, __webpack_require__) {

	"use strict";
	var spy = __webpack_require__(49);
	var wrapMethod = __webpack_require__(51);
	var behavior = __webpack_require__(63);
	var extend = __webpack_require__(53);
	var fn = __webpack_require__(52);

	function stub(object, property, func) {
	    if (!!func && typeof func !== "function") {
	        throw new TypeError("Custom stub should be function");
	    }

	    var wrapper;

	    if (func) {
	        wrapper = spy(func);
	    } else {
	        wrapper = stub.create();
	    }

	    if (!object && property === undefined) {
	        return stub.create();
	    }

	    if (property === undefined && typeof object === "object") {
	        for (var prop in object) {
	            if (typeof object[prop] === "function") {
	                stub(object, prop);
	            }
	        }

	        return object;
	    }

	    return wrapMethod(object, property, wrapper);
	}

	function getDefaultBehavior(stub) {
	    return stub.defaultBehavior || getParentBehaviour(stub) || behavior.create(stub);
	}

	function getParentBehaviour(stub) {
	    return (stub.parent && getCurrentBehavior(stub.parent));
	}

	function getCurrentBehavior(stub) {
	    var behavior = stub.behaviors[stub.callCount - 1];
	    return behavior && behavior.isPresent() ? behavior : getDefaultBehavior(stub);
	}

	var uuid = 0;

	var proto = {
	    create: function create() {
	        var functionStub = function () {
	            return getCurrentBehavior(functionStub).invoke(this, arguments);
	        };

	        functionStub.id = "stub#" + uuid++;
	        var orig = functionStub;
	        functionStub = spy(functionStub);
	        functionStub.func = orig;

	        extend(functionStub, stub);
	        functionStub.instantiateFake = stub.create;
	        functionStub.displayName = "stub";
	        functionStub.toString = fn.toString;

	        functionStub.defaultBehavior = null;
	        functionStub.behaviors = [];

	        return functionStub;
	    },

	    resetBehavior: function () {
	        var i;

	        this.defaultBehavior = null;
	        this.behaviors = [];

	        delete this.returnValue;
	        delete this.returnArgAt;
	        this.returnThis = false;

	        if (this.fakes) {
	            for (i = 0; i < this.fakes.length; i++) {
	                this.fakes[i].resetBehavior();
	            }
	        }
	    },

	    onCall: function onCall(index) {
	        if (!this.behaviors[index]) {
	            this.behaviors[index] = behavior.create(this);
	        }

	        return this.behaviors[index];
	    },

	    onFirstCall: function onFirstCall() {
	        return this.onCall(0);
	    },

	    onSecondCall: function onSecondCall() {
	        return this.onCall(1);
	    },

	    onThirdCall: function onThirdCall() {
	        return this.onCall(2);
	    }
	};

	for (var method in behavior) {
	    if (behavior.hasOwnProperty(method) &&
	        !proto.hasOwnProperty(method) &&
	        method != "create" &&
	        method != "withArgs" &&
	        method != "invoke") {
	        proto[method] = (function (behaviorMethod) {
	            return function () {
	                this.defaultBehavior = this.defaultBehavior || behavior.create(this);
	                this.defaultBehavior[behaviorMethod].apply(this.defaultBehavior, arguments);
	                return this;
	            };
	        }(method));
	    }
	}

	extend(stub, proto);
	module.exports = stub;


/***/ },
/* 63 */
/***/ function(module, exports, __webpack_require__) {

	/* WEBPACK VAR INJECTION */(function(process, setImmediate) {"use strict";
	var fn = __webpack_require__(52);
	var extend = __webpack_require__(53);

	var slice = Array.prototype.slice;
	var join = Array.prototype.join;

	var nextTick = (function () {
	    if (typeof process === "object" && typeof process.nextTick === "function") {
	        return process.nextTick;
	    }
	    if (typeof setImmediate === "function") {
	        return setImmediate;
	    }
	    return function (callback) {
	        setTimeout(callback, 0);
	    };
	}());

	function throwsException(error, message) {
	    if (typeof error === "string") {
	        this.exception = new Error(message || "");
	        this.exception.name = error;
	    } else if (!error) {
	        this.exception = new Error("Error");
	    } else {
	        this.exception = error;
	    }

	    return this;
	}

	function getCallback(behavior, args) {
	    var callArgAt = behavior.callArgAt;

	    if (callArgAt < 0) {
	        var callArgProp = behavior.callArgProp;

	        for (var i = 0, l = args.length; i < l; ++i) {
	            if (!callArgProp && typeof args[i] == "function") {
	                return args[i];
	            }

	            if (callArgProp && args[i] &&
	                typeof args[i][callArgProp] == "function") {
	                return args[i][callArgProp];
	            }
	        }

	        return null;
	    }

	    return args[callArgAt];
	}

	function getCallbackError(behavior, func, args) {
	    if (behavior.callArgAt < 0) {
	        var msg;

	        if (behavior.callArgProp) {
	            msg = fn.getName(behavior.stub) +
	                " expected to yield to '" + behavior.callArgProp +
	                "', but no object with such a property was passed.";
	        } else {
	            msg = fn.getName(behavior.stub) +
	                " expected to yield, but no callback was passed.";
	        }

	        if (args.length > 0) {
	            msg += " Received [" + join.call(args, ", ") + "]";
	        }

	        return msg;
	    }

	    return "argument at index " + behavior.callArgAt + " is not a function: " + func;
	}

	function callCallback(behavior, args) {
	    if (typeof behavior.callArgAt == "number") {
	        var func = getCallback(behavior, args);

	        if (typeof func != "function") {
	            throw new TypeError(getCallbackError(behavior, func, args));
	        }

	        if (behavior.callbackAsync) {
	            nextTick(function () {
	                func.apply(behavior.callbackContext, behavior.callbackArguments);
	            });
	        } else {
	            func.apply(behavior.callbackContext, behavior.callbackArguments);
	        }
	    }
	}

	var behavior = {
	    create: function create(stub) {
	        var instance = extend({}, behavior);
	        delete instance.create;
	        instance.stub = stub;

	        return instance;
	    },

	    isPresent: function isPresent() {
	        return (typeof this.callArgAt == "number" ||
	                this.exception ||
	                typeof this.returnArgAt == "number" ||
	                this.returnThis ||
	                this.returnValueDefined);
	    },

	    invoke: function invoke(context, args) {
	        callCallback(this, args);

	        if (this.exception) {
	            throw this.exception;
	        } else if (typeof this.returnArgAt == "number") {
	            return args[this.returnArgAt];
	        } else if (this.returnThis) {
	            return context;
	        }

	        return this.returnValue;
	    },

	    onCall: function onCall(index) {
	        return this.stub.onCall(index);
	    },

	    onFirstCall: function onFirstCall() {
	        return this.stub.onFirstCall();
	    },

	    onSecondCall: function onSecondCall() {
	        return this.stub.onSecondCall();
	    },

	    onThirdCall: function onThirdCall() {
	        return this.stub.onThirdCall();
	    },

	    withArgs: function withArgs(/* arguments */) {
	        throw new Error("Defining a stub by invoking \"stub.onCall(...).withArgs(...)\" is not supported. " +
	                        "Use \"stub.withArgs(...).onCall(...)\" to define sequential behavior for calls with certain arguments.");
	    },

	    callsArg: function callsArg(pos) {
	        if (typeof pos != "number") {
	            throw new TypeError("argument index is not number");
	        }

	        this.callArgAt = pos;
	        this.callbackArguments = [];
	        this.callbackContext = undefined;
	        this.callArgProp = undefined;
	        this.callbackAsync = false;

	        return this;
	    },

	    callsArgOn: function callsArgOn(pos, context) {
	        if (typeof pos != "number") {
	            throw new TypeError("argument index is not number");
	        }
	        if (typeof context != "object") {
	            throw new TypeError("argument context is not an object");
	        }

	        this.callArgAt = pos;
	        this.callbackArguments = [];
	        this.callbackContext = context;
	        this.callArgProp = undefined;
	        this.callbackAsync = false;

	        return this;
	    },

	    callsArgWith: function callsArgWith(pos) {
	        if (typeof pos != "number") {
	            throw new TypeError("argument index is not number");
	        }

	        this.callArgAt = pos;
	        this.callbackArguments = slice.call(arguments, 1);
	        this.callbackContext = undefined;
	        this.callArgProp = undefined;
	        this.callbackAsync = false;

	        return this;
	    },

	    callsArgOnWith: function callsArgWith(pos, context) {
	        if (typeof pos != "number") {
	            throw new TypeError("argument index is not number");
	        }
	        if (typeof context != "object") {
	            throw new TypeError("argument context is not an object");
	        }

	        this.callArgAt = pos;
	        this.callbackArguments = slice.call(arguments, 2);
	        this.callbackContext = context;
	        this.callArgProp = undefined;
	        this.callbackAsync = false;

	        return this;
	    },

	    yields: function () {
	        this.callArgAt = -1;
	        this.callbackArguments = slice.call(arguments, 0);
	        this.callbackContext = undefined;
	        this.callArgProp = undefined;
	        this.callbackAsync = false;

	        return this;
	    },

	    yieldsOn: function (context) {
	        if (typeof context != "object") {
	            throw new TypeError("argument context is not an object");
	        }

	        this.callArgAt = -1;
	        this.callbackArguments = slice.call(arguments, 1);
	        this.callbackContext = context;
	        this.callArgProp = undefined;
	        this.callbackAsync = false;

	        return this;
	    },

	    yieldsTo: function (prop) {
	        this.callArgAt = -1;
	        this.callbackArguments = slice.call(arguments, 1);
	        this.callbackContext = undefined;
	        this.callArgProp = prop;
	        this.callbackAsync = false;

	        return this;
	    },

	    yieldsToOn: function (prop, context) {
	        if (typeof context != "object") {
	            throw new TypeError("argument context is not an object");
	        }

	        this.callArgAt = -1;
	        this.callbackArguments = slice.call(arguments, 2);
	        this.callbackContext = context;
	        this.callArgProp = prop;
	        this.callbackAsync = false;

	        return this;
	    },

	    throws: throwsException,
	    throwsException: throwsException,

	    returns: function returns(value) {
	        this.returnValue = value;
	        this.returnValueDefined = true;

	        return this;
	    },

	    returnsArg: function returnsArg(pos) {
	        if (typeof pos != "number") {
	            throw new TypeError("argument index is not number");
	        }

	        this.returnArgAt = pos;

	        return this;
	    },

	    returnsThis: function returnsThis() {
	        this.returnThis = true;

	        return this;
	    }
	};

	// create asynchronous versions of callsArg* and yields* methods
	for (var method in behavior) {
	    // need to avoid creating anotherasync versions of the newly added async methods
	    if (behavior.hasOwnProperty(method) &&
	        method.match(/^(callsArg|yields)/) &&
	        !method.match(/Async/)) {
	        behavior[method + "Async"] = (function (syncFnName) {
	            return function () {
	                var result = this[syncFnName].apply(this, arguments);
	                this.callbackAsync = true;
	                return result;
	            };
	        })(method);
	    }
	}

	module.exports = behavior;

	/* WEBPACK VAR INJECTION */}.call(exports, __webpack_require__(4), __webpack_require__(5).setImmediate))

/***/ },
/* 64 */
/***/ function(module, exports, __webpack_require__) {

	"use strict";
	var mockExpectation = __webpack_require__(65);
	var extend = __webpack_require__(53);
	var wrapMethod = __webpack_require__(51);
	var spyCall = __webpack_require__(54);
	var push = Array.prototype.push;

	function mock(object) {
	    if (!object) {
	        return mockExpectation.create("Anonymous mock");
	    }

	    return mock.create(object);
	}

	function each(collection, callback) {
	    if (!collection) {
	        return;
	    }

	    for (var i = 0, l = collection.length; i < l; i += 1) {
	        callback(collection[i]);
	    }
	}

	module.exports = extend(mock, {
	    create: function create(object) {
	        if (!object) {
	            throw new TypeError("object is null");
	        }

	        var mockObject = extend({}, mock);
	        mockObject.object = object;
	        delete mockObject.create;

	        return mockObject;
	    },

	    expects: function expects(method) {
	        if (!method) {
	            throw new TypeError("method is falsy");
	        }

	        if (!this.expectations) {
	            this.expectations = {};
	            this.proxies = [];
	        }

	        if (!this.expectations[method]) {
	            this.expectations[method] = [];
	            var mockObject = this;

	            wrapMethod(this.object, method, function () {
	                return mockObject.invokeMethod(method, this, arguments);
	            });

	            push.call(this.proxies, method);
	        }

	        var expectation = mockExpectation.create(method);
	        push.call(this.expectations[method], expectation);

	        return expectation;
	    },

	    restore: function restore() {
	        var object = this.object;

	        each(this.proxies, function (proxy) {
	            if (typeof object[proxy].restore == "function") {
	                object[proxy].restore();
	            }
	        });
	    },

	    verify: function verify() {
	        var expectations = this.expectations || {};
	        var messages = [], met = [];

	        each(this.proxies, function (proxy) {
	            each(expectations[proxy], function (expectation) {
	                if (!expectation.met()) {
	                    push.call(messages, expectation.toString());
	                } else {
	                    push.call(met, expectation.toString());
	                }
	            });
	        });

	        this.restore();

	        if (messages.length > 0) {
	            mockExpectation.fail(messages.concat(met).join("\n"));
	        } else if (met.length > 0) {
	            mockExpectation.pass(messages.concat(met).join("\n"));
	        }

	        return true;
	    },

	    invokeMethod: function invokeMethod(method, thisValue, args) {
	        var expectations = this.expectations && this.expectations[method];
	        var length = expectations && expectations.length || 0, i;

	        for (i = 0; i < length; i += 1) {
	            if (!expectations[i].met() &&
	                expectations[i].allowsCall(thisValue, args)) {
	                return expectations[i].apply(thisValue, args);
	            }
	        }

	        var messages = [], available, exhausted = 0;

	        for (i = 0; i < length; i += 1) {
	            if (expectations[i].allowsCall(thisValue, args)) {
	                available = available || expectations[i];
	            } else {
	                exhausted += 1;
	            }
	            push.call(messages, "    " + expectations[i].toString());
	        }

	        if (exhausted === 0) {
	            return available.apply(thisValue, args);
	        }

	        messages.unshift("Unexpected call: " + spyCall.toString.call({
	            proxy: method,
	            args: args
	        }));

	        mockExpectation.fail(messages.join("\n"));
	    }
	});


/***/ },
/* 65 */
/***/ function(module, exports, __webpack_require__) {

	"use strict";
	var extend = __webpack_require__(53);
	var stub = __webpack_require__(62);
	var spy = __webpack_require__(49);
	var format = __webpack_require__(58);
	var deepEqual = __webpack_require__(57);
	var spyCall = __webpack_require__(54);
	var match = __webpack_require__(55);
	var times = __webpack_require__(50);

	var push = Array.prototype.push;
	var slice = Array.prototype.slice;

	function receivedMinCalls(expectation) {
	    var hasMinLimit = typeof expectation.minCalls === "number";
	    return !hasMinLimit || expectation.callCount >= expectation.minCalls;
	}

	function receivedMaxCalls(expectation) {
	    if (typeof expectation.maxCalls !== "number") {
	        return false;
	    }

	    return expectation.callCount === expectation.maxCalls;
	}

	function verifyMatcher(possibleMatcher, arg) {
	    if (match && match.isMatcher(possibleMatcher)) {
	        return possibleMatcher.test(arg);
	    }
	    return true;
	}

	function callCountInWords(callCount) {
	    if (callCount == 0) {
	        return "never called";
	    }
	    return "called " + times(callCount);
	}

	function expectedCallCountInWords(expectation) {
	    var min = expectation.minCalls;
	    var max = expectation.maxCalls;

	    if (typeof min === "number" && typeof max === "number") {
	        var str = times(min);

	        if (min !== max) {
	            str = "at least " + str + " and at most " + times(max);
	        }

	        return str;
	    }

	    if (typeof min === "number") {
	        return "at least " + times(min);
	    }

	    return "at most " + times(max);
	}

	module.exports = {
	    minCalls: 1,
	    maxCalls: 1,

	    create: function create(methodName) {
	        var expectation = extend(stub(), module.exports);
	        delete expectation.create;
	        expectation.method = methodName;

	        return expectation;
	    },

	    invoke: function invoke(func, thisValue, args) {
	        this.verifyCallAllowed(thisValue, args);

	        return spy.invoke.apply(this, arguments);
	    },

	    atLeast: function atLeast(num) {
	        if (typeof num !== "number") {
	            throw new TypeError("'" + num + "' is not number");
	        }

	        if (!this.limitsSet) {
	            this.maxCalls = null;
	            this.limitsSet = true;
	        }

	        this.minCalls = num;

	        return this;
	    },

	    atMost: function atMost(num) {
	        if (typeof num !== "number") {
	            throw new TypeError("'" + num + "' is not number");
	        }

	        if (!this.limitsSet) {
	            this.minCalls = null;
	            this.limitsSet = true;
	        }

	        this.maxCalls = num;

	        return this;
	    },

	    never: function never() {
	        return this.exactly(0);
	    },

	    once: function once() {
	        return this.exactly(1);
	    },

	    twice: function twice() {
	        return this.exactly(2);
	    },

	    thrice: function thrice() {
	        return this.exactly(3);
	    },

	    exactly: function exactly(num) {
	        if (typeof num !== "number") {
	            throw new TypeError("'" + num + "' is not a number");
	        }

	        this.atLeast(num);
	        return this.atMost(num);
	    },

	    met: function met() {
	        return !this.failed && receivedMinCalls(this);
	    },

	    verifyCallAllowed: function verifyCallAllowed(thisValue, args) {
	        if (receivedMaxCalls(this)) {
	            this.failed = true;
	            module.exports.fail(this.method + " already called " + times(this.maxCalls));
	        }

	        if ("expectedThis" in this && this.expectedThis !== thisValue) {
	            module.exports.fail(this.method + " called with " + thisValue + " as thisValue, expected " +
	                                   this.expectedThis);
	        }

	        if (!("expectedArguments" in this)) {
	            return;
	        }

	        if (!args) {
	            module.exports.fail(this.method + " received no arguments, expected " +
	                                   format(this.expectedArguments));
	        }

	        if (args.length < this.expectedArguments.length) {
	            module.exports.fail(this.method + " received too few arguments (" + format(args) +
	                                   "), expected " + format(this.expectedArguments));
	        }

	        if (this.expectsExactArgCount &&
	                args.length !== this.expectedArguments.length) {
	            module.exports.fail(this.method + " received too many arguments (" + format(args) +
	                                   "), expected " + format(this.expectedArguments));
	        }

	        for (var i = 0, l = this.expectedArguments.length; i < l; i += 1) {

	            if (!verifyMatcher(this.expectedArguments[i], args[i])) {
	                module.exports.fail(this.method + " received wrong arguments " + format(args) +
	                                       ", didn't match " + this.expectedArguments.toString());
	            }

	            if (!deepEqual(this.expectedArguments[i], args[i])) {
	                module.exports.fail(this.method + " received wrong arguments " + format(args) +
	                                       ", expected " + format(this.expectedArguments));
	            }
	        }
	    },

	    allowsCall: function allowsCall(thisValue, args) {
	        if (this.met() && receivedMaxCalls(this)) {
	            return false;
	        }

	        if ("expectedThis" in this && this.expectedThis !== thisValue) {
	            return false;
	        }

	        if (!("expectedArguments" in this)) {
	            return true;
	        }

	        args = args || [];

	        if (args.length < this.expectedArguments.length) {
	            return false;
	        }

	        if (this.expectsExactArgCount &&
	            args.length != this.expectedArguments.length) {
	            return false;
	        }

	        for (var i = 0, l = this.expectedArguments.length; i < l; i += 1) {
	            if (!verifyMatcher(this.expectedArguments[i], args[i])) {
	                return false;
	            }

	            if (!deepEqual(this.expectedArguments[i], args[i])) {
	                return false;
	            }
	        }

	        return true;
	    },

	    withArgs: function withArgs() {
	        this.expectedArguments = slice.call(arguments);
	        return this;
	    },

	    withExactArgs: function withExactArgs() {
	        this.withArgs.apply(this, arguments);
	        this.expectsExactArgCount = true;
	        return this;
	    },

	    on: function on(thisValue) {
	        this.expectedThis = thisValue;
	        return this;
	    },

	    toString: function () {
	        var args = (this.expectedArguments || []).slice();

	        if (!this.expectsExactArgCount) {
	            push.call(args, "[...]");
	        }

	        var callStr = spyCall.toString.call({
	            proxy: this.method || "anonymous mock expectation",
	            args: args
	        });

	        var message = callStr.replace(", [...", "[, ...") + " " +
	                expectedCallCountInWords(this);

	        if (this.met()) {
	            return "Expectation met: " + message;
	        }

	        return "Expected " + message + " (" +
	            callCountInWords(this.callCount) + ")";
	    },

	    verify: function verify() {
	        if (!this.met()) {
	            module.exports.fail(this.toString());
	        } else {
	            module.exports.pass(this.toString());
	        }

	        return true;
	    },

	    pass: function pass(message) {
	        // TODO
	        // assert.pass(message);
	    },

	    fail: function fail(message) {
	        var exception = new Error(message);
	        exception.name = "ExpectationError";

	        throw exception;
	    }
	};


/***/ },
/* 66 */
/***/ function(module, exports, __webpack_require__) {

	"use strict";
	var spy = __webpack_require__(49);
	var stub = __webpack_require__(62);
	var mock = __webpack_require__(64);
	var push = [].push;
	var hasOwn = Object.prototype.hasOwnProperty;

	function getFakes(fakeCollection) {
	    if (!fakeCollection.fakes) {
	        fakeCollection.fakes = [];
	    }

	    return fakeCollection.fakes;
	}

	function each(fakeCollection, method) {
	    var fakes = getFakes(fakeCollection);

	    for (var i = 0, l = fakes.length; i < l; i += 1) {
	        if (typeof fakes[i][method] === "function") {
	            fakes[i][method]();
	        }
	    }
	}

	function compact(fakeCollection) {
	    var fakes = getFakes(fakeCollection);
	    var i = 0;
	    while (i < fakes.length) {
	        fakes.splice(i, 1);
	    }
	}

	module.exports = {
	    verify: function resolve() {
	        each(this, "verify");
	    },

	    restore: function restore() {
	        each(this, "restore");
	        compact(this);
	    },

	    reset: function restore() {
	        each(this, "reset");
	    },

	    verifyAndRestore: function verifyAndRestore() {
	        var exception;

	        try {
	            this.verify();
	        } catch (e) {
	            exception = e;
	        }

	        this.restore();

	        if (exception) {
	            throw exception;
	        }
	    },

	    add: function add(fake) {
	        push.call(getFakes(this), fake);
	        return fake;
	    },

	    spy: function () {
	        return this.add(spy.apply(null, arguments));
	    },

	    stub: function (object, property, value) {
	        if (property) {
	            var original = object[property];

	            if (typeof original != "function") {
	                if (!hasOwn.call(object, property)) {
	                    throw new TypeError("Cannot stub non-existent own property " + property);
	                }

	                object[property] = value;

	                return this.add({
	                    restore: function () {
	                        object[property] = original;
	                    }
	                });
	            }
	        }
	        if (!property && !!object && typeof object == "object") {
	            var stubbedObj = stub.apply(null, arguments);

	            for (var prop in stubbedObj) {
	                if (typeof stubbedObj[prop] === "function") {
	                    this.add(stubbedObj[prop]);
	                }
	            }

	            return stubbedObj;
	        }

	        return this.add(stub.apply(null, arguments));
	    },

	    mock: function () {
	        return this.add(mock.apply(null, arguments));
	    },

	    inject: function inject(obj) {
	        var col = this;

	        obj.spy = function () {
	            return col.spy.apply(col, arguments);
	        };

	        obj.stub = function () {
	            return col.stub.apply(col, arguments);
	        };

	        obj.mock = function () {
	            return col.mock.apply(col, arguments);
	        };

	        return obj;
	    }
	};


/***/ },
/* 67 */
/***/ function(module, exports, __webpack_require__) {

	"use strict";
	var fn = __webpack_require__(52);
	var extend = __webpack_require__(53);
	var collection = __webpack_require__(66);
	var useFakeTimers = __webpack_require__(68);
	var match = __webpack_require__(55);

	var push = [].push;

	function exposeValue(sandbox, config, key, value) {
	    if (!value) {
	        return;
	    }

	    if (config.injectInto && !(key in config.injectInto)) {
	        config.injectInto[key] = value;
	        sandbox.injectedKeys.push(key);
	    } else {
	        push.call(sandbox.args, value);
	    }
	}

	function prepareSandboxFromConfig(config) {
	    var sandbox = fn.create(module.exports);

	    if (config.useFakeServer) {
	        if (typeof config.useFakeServer === "object") {
	            sandbox.serverPrototype = config.useFakeServer;
	        }

	        sandbox.useFakeServer();
	    }

	    if (config.useFakeTimers) {
	        if (typeof config.useFakeTimers === "object") {
	            sandbox.useFakeTimers.apply(sandbox, config.useFakeTimers);
	        } else {
	            sandbox.useFakeTimers();
	        }
	    }

	    return sandbox;
	}

	module.exports = extend(fn.create(collection), {
	    useFakeTimers: function () {
	        this.clock = useFakeTimers.apply(null, arguments);

	        return this.add(this.clock);
	    },

	    serverPrototype: {}, // TODO: sinon.fakeServer,

	    useFakeServer: function useFakeServer() {
	        var proto = this.serverPrototype || sinon.fakeServer;

	        if (!proto || !proto.create) {
	            return null;
	        }

	        this.server = proto.create();
	        return this.add(this.server);
	    },

	    inject: function (obj) {
	        collection.inject.call(this, obj);

	        if (this.clock) {
	            obj.clock = this.clock;
	        }

	        if (this.server) {
	            obj.server = this.server;
	            obj.requests = this.server.requests;
	        }

	        obj.match = match;

	        return obj;
	    },

	    restore: function () {
	        collection.restore.apply(this, arguments);
	        this.restoreContext();
	    },

	    restoreContext: function () {
	        if (this.injectedKeys) {
	            for (var i = 0, j = this.injectedKeys.length; i < j; i++) {
	                delete this.injectInto[this.injectedKeys[i]];
	            }
	            this.injectedKeys = [];
	        }
	    },

	    create: function (config) {
	        if (!config) {
	            return fn.create(module.exports);
	        }

	        var sandbox = prepareSandboxFromConfig(config);
	        sandbox.args = sandbox.args || [];
	        sandbox.injectedKeys = [];
	        sandbox.injectInto = config.injectInto;
	        var prop, value, exposed = sandbox.inject({});

	        if (config.properties) {
	            for (var i = 0, l = config.properties.length; i < l; i++) {
	                prop = config.properties[i];
	                value = exposed[prop] || prop == "sandbox" && sandbox;
	                exposeValue(sandbox, config, prop, value);
	            }
	        } else {
	            exposeValue(sandbox, config, "sandbox", value);
	        }

	        return sandbox;
	    },

	    match: match
	});

	// WHAAAA?
	// sinon.sandbox.useFakeXMLHttpRequest = sinon.sandbox.useFakeServer;


/***/ },
/* 68 */
/***/ function(module, exports, __webpack_require__) {

	"use strict";
	var lolex = __webpack_require__(69);

	module.exports = function () {
	    var now, methods = Array.prototype.slice.call(arguments);

	    if (typeof methods[0] === "string") {
	        now = 0;
	    } else {
	        now = methods.shift();
	    }

	    var clock = lolex.install(now || 0, methods);
	    clock.restore = clock.uninstall;
	    return clock;
	};


/***/ },
/* 69 */
/***/ function(module, exports, __webpack_require__) {

	/* WEBPACK VAR INJECTION */(function(setImmediate, clearImmediate, global) {/*jslint eqeqeq: false, plusplus: false, evil: true, onevar: false, browser: true, forin: false*/
	/*global global*/
	/**
	 * @author Christian Johansen (christian@cjohansen.no) and contributors
	 * @license BSD
	 *
	 * Copyright (c) 2010-2014 Christian Johansen
	 */
	"use strict";

	// node expects setTimeout/setInterval to return a fn object w/ .ref()/.unref()
	// browsers, a number.
	// see https://github.com/cjohansen/Sinon.JS/pull/436
	var timeoutResult = setTimeout(function() {}, 0);
	var addTimerReturnsObject = typeof timeoutResult === "object";
	clearTimeout(timeoutResult);

	var NativeDate = Date;
	var id = 1;

	/**
	 * Parse strings like "01:10:00" (meaning 1 hour, 10 minutes, 0 seconds) into
	 * number of milliseconds. This is used to support human-readable strings passed
	 * to clock.tick()
	 */
	function parseTime(str) {
	    if (!str) {
	        return 0;
	    }

	    var strings = str.split(":");
	    var l = strings.length, i = l;
	    var ms = 0, parsed;

	    if (l > 3 || !/^(\d\d:){0,2}\d\d?$/.test(str)) {
	        throw new Error("tick only understands numbers and 'h:m:s'");
	    }

	    while (i--) {
	        parsed = parseInt(strings[i], 10);

	        if (parsed >= 60) {
	            throw new Error("Invalid time " + str);
	        }

	        ms += parsed * Math.pow(60, (l - i - 1));
	    }

	    return ms * 1000;
	}

	/**
	 * Used to grok the `now` parameter to createClock.
	 */
	function getEpoch(epoch) {
	    if (!epoch) { return 0; }
	    if (typeof epoch.getTime === "function") { return epoch.getTime(); }
	    if (typeof epoch === "number") { return epoch; }
	    throw new TypeError("now should be milliseconds since UNIX epoch");
	}

	function inRange(from, to, timer) {
	    return timer && timer.callAt >= from && timer.callAt <= to;
	}

	function mirrorDateProperties(target, source) {
	    if (source.now) {
	        target.now = function now() {
	            return target.clock.now;
	        };
	    } else {
	        delete target.now;
	    }

	    if (source.toSource) {
	        target.toSource = function toSource() {
	            return source.toSource();
	        };
	    } else {
	        delete target.toSource;
	    }

	    target.toString = function toString() {
	        return source.toString();
	    };

	    target.prototype = source.prototype;
	    target.parse = source.parse;
	    target.UTC = source.UTC;
	    target.prototype.toUTCString = source.prototype.toUTCString;

	    for (var prop in source) {
	        if (source.hasOwnProperty(prop)) {
	            target[prop] = source[prop];
	        }
	    }

	    return target;
	}

	function createDate() {
	    function ClockDate(year, month, date, hour, minute, second, ms) {
	        // Defensive and verbose to avoid potential harm in passing
	        // explicit undefined when user does not pass argument
	        switch (arguments.length) {
	        case 0:
	            return new NativeDate(ClockDate.clock.now);
	        case 1:
	            return new NativeDate(year);
	        case 2:
	            return new NativeDate(year, month);
	        case 3:
	            return new NativeDate(year, month, date);
	        case 4:
	            return new NativeDate(year, month, date, hour);
	        case 5:
	            return new NativeDate(year, month, date, hour, minute);
	        case 6:
	            return new NativeDate(year, month, date, hour, minute, second);
	        default:
	            return new NativeDate(year, month, date, hour, minute, second, ms);
	        }
	    }

	    return mirrorDateProperties(ClockDate, NativeDate);
	}

	function addTimer(clock, timer) {
	    if (typeof timer.func === "undefined") {
	        throw new Error("Callback must be provided to timer calls");
	    }

	    if (!clock.timers) {
	        clock.timers = {};
	    }

	    timer.id = id++;
	    timer.createdAt = clock.now;
	    timer.callAt = clock.now + (timer.delay || 0);

	    clock.timers[timer.id] = timer;

	    if (addTimerReturnsObject) {
	        return {
	            id: timer.id,
	            ref: function() {},
	            unref: function() {}
	        };
	    }
	    else {
	        return timer.id;
	    }
	}

	function firstTimerInRange(clock, from, to) {
	    var timers = clock.timers, timer = null;

	    for (var id in timers) {
	        if (!inRange(from, to, timers[id])) {
	            continue;
	        }

	        if (!timer || ~compareTimers(timer, timers[id])) {
	            timer = timers[id];
	        }
	    }

	    return timer;
	}

	function compareTimers(a, b) {
	    // Sort first by absolute timing
	    if (a.callAt < b.callAt) {
	        return -1;
	    }
	    if (a.callAt > b.callAt) {
	        return 1;
	    }

	    // Sort next by immediate, immediate timers take precedence
	    if (a.immediate && !b.immediate) {
	        return -1;
	    }
	    if (!a.immediate && b.immediate) {
	        return 1;
	    }

	    // Sort next by creation time, earlier-created timers take precedence
	    if (a.createdAt < b.createdAt) {
	        return -1;
	    }
	    if (a.createdAt > b.createdAt) {
	        return 1;
	    }

	    // Sort next by id, lower-id timers take precedence
	    if (a.id < b.id) {
	        return -1;
	    }
	    if (a.id > b.id) {
	        return 1;
	    }

	    // As timer ids are unique, no fallback `0` is necessary
	}

	function callTimer(clock, timer) {
	    if (typeof timer.interval == "number") {
	        clock.timers[timer.id].callAt += timer.interval;
	    } else {
	        delete clock.timers[timer.id];
	    }

	    try {
	        if (typeof timer.func == "function") {
	            timer.func.apply(null, timer.args);
	        } else {
	            eval(timer.func);
	        }
	    } catch (e) {
	        var exception = e;
	    }

	    if (!clock.timers[timer.id]) {
	        if (exception) {
	            throw exception;
	        }
	        return;
	    }

	    if (exception) {
	        throw exception;
	    }
	}

	function uninstall(clock, target) {
	    var method;

	    for (var i = 0, l = clock.methods.length; i < l; i++) {
	        method = clock.methods[i];

	        if (target[method].hadOwnProperty) {
	            target[method] = clock["_" + method];
	        } else {
	            try {
	                delete target[method];
	            } catch (e) {}
	        }
	    }

	    // Prevent multiple executions which will completely remove these props
	    clock.methods = [];
	}

	function hijackMethod(target, method, clock) {
	    clock[method].hadOwnProperty = Object.prototype.hasOwnProperty.call(target, method);
	    clock["_" + method] = target[method];

	    if (method == "Date") {
	        var date = mirrorDateProperties(clock[method], target[method]);
	        target[method] = date;
	    } else {
	        target[method] = function () {
	            return clock[method].apply(clock, arguments);
	        };

	        for (var prop in clock[method]) {
	            if (clock[method].hasOwnProperty(prop)) {
	                target[method][prop] = clock[method][prop];
	            }
	        }
	    }

	    target[method].clock = clock;
	}

	var timers = {
	    setTimeout: setTimeout,
	    clearTimeout: clearTimeout,
	    setImmediate: (typeof setImmediate !== "undefined" ? setImmediate : undefined),
	    clearImmediate: (typeof clearImmediate !== "undefined" ? clearImmediate: undefined),
	    setInterval: setInterval,
	    clearInterval: clearInterval,
	    Date: Date
	};

	var keys = Object.keys || function (obj) {
	    var ks = [];
	    for (var key in obj) {
	        ks.push(key);
	    }
	    return ks;
	};

	exports.timers = timers;

	var createClock = exports.createClock = function (now) {
	    var clock = {
	        now: getEpoch(now),
	        timeouts: {},
	        Date: createDate()
	    };

	    clock.Date.clock = clock;

	    clock.setTimeout = function setTimeout(func, timeout) {
	        return addTimer(clock, {
	            func: func,
	            args: Array.prototype.slice.call(arguments, 2),
	            delay: timeout
	        });
	    };

	    clock.clearTimeout = function clearTimeout(timerId) {
	        if (!timerId) {
	            // null appears to be allowed in most browsers, and appears to be
	            // relied upon by some libraries, like Bootstrap carousel
	            return;
	        }
	        if (!clock.timers) {
	            clock.timers = [];
	        }
	        // in Node, timerId is an object with .ref()/.unref(), and
	        // its .id field is the actual timer id.
	        if (typeof timerId === "object") {
	            timerId = timerId.id
	        }
	        if (timerId in clock.timers) {
	            delete clock.timers[timerId];
	        }
	    };

	    clock.setInterval = function setInterval(func, timeout) {
	        return addTimer(clock, {
	            func: func,
	            args: Array.prototype.slice.call(arguments, 2),
	            delay: timeout,
	            interval: timeout
	        });
	    };

	    clock.clearInterval = function clearInterval(timerId) {
	        clock.clearTimeout(timerId);
	    };

	    clock.setImmediate = function setImmediate(func) {
	        return addTimer(clock, {
	            func: func,
	            args: Array.prototype.slice.call(arguments, 1),
	            immediate: true
	        });
	    };

	    clock.clearImmediate = function clearImmediate(timerId) {
	        clock.clearTimeout(timerId);
	    };

	    clock.tick = function tick(ms) {
	        ms = typeof ms == "number" ? ms : parseTime(ms);
	        var tickFrom = clock.now, tickTo = clock.now + ms, previous = clock.now;
	        var timer = firstTimerInRange(clock, tickFrom, tickTo);

	        var firstException;
	        while (timer && tickFrom <= tickTo) {
	            if (clock.timers[timer.id]) {
	                tickFrom = clock.now = timer.callAt;
	                try {
	                    callTimer(clock, timer);
	                } catch (e) {
	                    firstException = firstException || e;
	                }
	            }

	            timer = firstTimerInRange(clock, previous, tickTo);
	            previous = tickFrom;
	        }

	        clock.now = tickTo;

	        if (firstException) {
	            throw firstException;
	        }

	        return clock.now;
	    };

	    clock.reset = function reset() {
	        clock.timers = {};
	    };

	    return clock;
	};

	exports.install = function install(target, now, toFake) {
	    if (typeof target === "number") {
	        toFake = now;
	        now = target;
	        target = null;
	    }

	    if (!target) {
	        target = global;
	    }

	    var clock = createClock(now);

	    clock.uninstall = function () {
	        uninstall(clock, target);
	    };

	    clock.methods = toFake || [];

	    if (clock.methods.length === 0) {
	        clock.methods = keys(timers);
	    }

	    for (var i = 0, l = clock.methods.length; i < l; i++) {
	        hijackMethod(target, clock.methods[i], clock);
	    }

	    return clock;
	};

	/* WEBPACK VAR INJECTION */}.call(exports, __webpack_require__(5).setImmediate, __webpack_require__(5).clearImmediate, (function() { return this; }())))

/***/ },
/* 70 */
/***/ function(module, exports, __webpack_require__) {

	"use strict";
	var fn = __webpack_require__(52);
	var stub = __webpack_require__(62);

	module.exports = function (constructor) {
	    if (typeof constructor !== "function") {
	        throw new TypeError("The constructor should be a function.");
	    }
	    return stub(fn.create(constructor.prototype));
	};


/***/ },
/* 71 */
/***/ function(module, exports) {

	"use strict";
	// cache a reference to setTimeout, so that our reference won't be stubbed out
	// when using fake timers and errors will still get logged
	// https://github.com/cjohansen/Sinon.JS/issues/381
	var realSetTimeout = setTimeout;

	function log() {}

	function logError(label, err) {
	    var msg = label + " threw exception: ";

	    log(msg + "[" + err.name + "] " + err.message);

	    if (err.stack) {
	        log(err.stack);
	    }

	    logError.setTimeout(function () {
	        err.message = msg + err.message;
	        throw err;
	    }, 0);
	}

	// wrap realSetTimeout with something we can stub in tests
	logError.setTimeout = function (func, timeout) {
	    realSetTimeout(func, timeout);
	};

	exports.log = log;
	exports.logError = logError;


/***/ },
/* 72 */
/***/ function(module, exports) {

	"use strict";
	function isRestorable(obj) {
	    return typeof obj === "function" && typeof obj.restore === "function" && obj.restore.sinon;
	}

	module.exports = function (object) {
	    if (object !== null && typeof object === "object") {
	        for (var prop in object) {
	            if (isRestorable(object[prop])) {
	                object[prop].restore();
	            }
	        }
	    } else if (isRestorable(object)) {
	        object.restore();
	    }
	};


/***/ },
/* 73 */
/***/ function(module, exports, __webpack_require__) {

	/* WEBPACK VAR INJECTION */(function(global) {/*global global, window*/
	"use strict";
	var timesInWords = __webpack_require__(50);
	var match = __webpack_require__(55);
	var format = __webpack_require__(58);
	var slice = Array.prototype.slice;
	var g = typeof global === "undefined" ? window : global;
	var assert;

	function calledInOrder(spies) {
	    for (var i = 1, l = spies.length; i < l; i++) {
	        if (!spies[i - 1].calledBefore(spies[i]) || !spies[i].called) {
	            return false;
	        }
	    }
	    return true;
	}

	function orderByFirstCall(spies) {
	    return spies.sort(function (a, b) {
	        // uuid, won't ever be equal
	        var aCall = a.getCall(0);
	        var bCall = b.getCall(0);
	        var aId = aCall && aCall.callId || -1;
	        var bId = bCall && bCall.callId || -1;

	        return aId < bId ? -1 : 1;
	    });
	}

	function verifyIsStub() {
	    var method;

	    for (var i = 0, l = arguments.length; i < l; ++i) {
	        method = arguments[i];

	        if (!method) {
	            assert.fail("fake is not a spy");
	        }

	        if (typeof method != "function") {
	            assert.fail(method + " is not a function");
	        }

	        if (typeof method.getCall != "function") {
	            assert.fail(method + " is not stubbed");
	        }
	    }
	}

	function failAssertion(object, msg) {
	    object = object || g;
	    var failMethod = object.fail || assert.fail;
	    failMethod.call(object, msg);
	}

	function mirrorPropAsAssertion(name, method, message) {
	    if (arguments.length == 2) {
	        message = method;
	        method = name;
	    }

	    assert[name] = function (fake) {
	        verifyIsStub(fake);

	        var args = slice.call(arguments, 1);
	        var failed = false;

	        if (typeof method == "function") {
	            failed = !method(fake);
	        } else {
	            failed = typeof fake[method] == "function" ?
	                !fake[method].apply(fake, args) : !fake[method];
	        }

	        if (failed) {
	            failAssertion(this, fake.printf.apply(fake, [message].concat(args)));
	        } else {
	            assert.pass(name);
	        }
	    };
	}

	function exposedName(prefix, prop) {
	    return !prefix || /^fail/.test(prop) ? prop :
	        prefix + prop.slice(0, 1).toUpperCase() + prop.slice(1);
	}

	assert = {
	    failException: "AssertError",

	    fail: function fail(message) {
	        var error = new Error(message);
	        error.name = this.failException || assert.failException;

	        throw error;
	    },

	    pass: function pass(assertion) {},

	    callOrder: function assertCallOrder() {
	        verifyIsStub.apply(null, arguments);
	        var expected = "", actual = "";

	        if (!calledInOrder(arguments)) {
	            try {
	                expected = [].join.call(arguments, ", ");
	                var calls = slice.call(arguments);
	                var i = calls.length;
	                while (i) {
	                    if (!calls[--i].called) {
	                        calls.splice(i, 1);
	                    }
	                }
	                actual = orderByFirstCall(calls).join(", ");
	            } catch (e) {
	                // If this fails, we'll just fall back to the blank string
	            }

	            failAssertion(this, "expected " + expected + " to be " +
	                          "called in order but were called as " + actual);
	        } else {
	            assert.pass("callOrder");
	        }
	    },

	    callCount: function assertCallCount(method, count) {
	        verifyIsStub(method);

	        if (method.callCount != count) {
	            var msg = "expected %n to be called " + timesInWords(count) +
	                    " but was called %c%C";
	            failAssertion(this, method.printf(msg));
	        } else {
	            assert.pass("callCount");
	        }
	    },

	    expose: function expose(target, options) {
	        if (!target) {
	            throw new TypeError("target is null or undefined");
	        }

	        var o = options || {};
	        var prefix = typeof o.prefix == "undefined" && "assert" || o.prefix;
	        var includeFail = typeof o.includeFail == "undefined" || !!o.includeFail;

	        for (var method in this) {
	            if (method != "expose" && (includeFail || !/^(fail)/.test(method))) {
	                target[exposedName(prefix, method)] = this[method];
	            }
	        }

	        return target;
	    },

	    match: function (actual, expectation) {
	        var matcher = match(expectation);
	        if (matcher.test(actual)) {
	            assert.pass("match");
	        } else {
	            var formatted = [
	                "expected value to match",
	                "    expected = " + format(expectation),
	                "    actual = " + format(actual)
	            ]
	            failAssertion(this, formatted.join("\n"));
	        }
	    }
	};

	mirrorPropAsAssertion("called", "expected %n to have been called at least once but was never called");
	mirrorPropAsAssertion("notCalled", function (spy) { return !spy.called; },
	                      "expected %n to not have been called but was called %c%C");
	mirrorPropAsAssertion("calledOnce", "expected %n to be called once but was called %c%C");
	mirrorPropAsAssertion("calledTwice", "expected %n to be called twice but was called %c%C");
	mirrorPropAsAssertion("calledThrice", "expected %n to be called thrice but was called %c%C");
	mirrorPropAsAssertion("calledOn", "expected %n to be called with %1 as this but was called with %t");
	mirrorPropAsAssertion("alwaysCalledOn", "expected %n to always be called with %1 as this but was called with %t");
	mirrorPropAsAssertion("calledWithNew", "expected %n to be called with new");
	mirrorPropAsAssertion("alwaysCalledWithNew", "expected %n to always be called with new");
	mirrorPropAsAssertion("calledWith", "expected %n to be called with arguments %*%C");
	mirrorPropAsAssertion("calledWithMatch", "expected %n to be called with match %*%C");
	mirrorPropAsAssertion("alwaysCalledWith", "expected %n to always be called with arguments %*%C");
	mirrorPropAsAssertion("alwaysCalledWithMatch", "expected %n to always be called with match %*%C");
	mirrorPropAsAssertion("calledWithExactly", "expected %n to be called with exact arguments %*%C");
	mirrorPropAsAssertion("alwaysCalledWithExactly", "expected %n to always be called with exact arguments %*%C");
	mirrorPropAsAssertion("neverCalledWith", "expected %n to never be called with arguments %*%C");
	mirrorPropAsAssertion("neverCalledWithMatch", "expected %n to never be called with match %*%C");
	mirrorPropAsAssertion("threw", "%n did not throw exception%C");
	mirrorPropAsAssertion("alwaysThrew", "%n did not always throw exception%C");

	module.exports = assert;

	/* WEBPACK VAR INJECTION */}.call(exports, (function() { return this; }())))

/***/ },
/* 74 */
/***/ function(module, exports, __webpack_require__) {

	"use strict";
	var sinonConfig = __webpack_require__(75);
	var createSandbox = __webpack_require__(67).create;

	function test(callback) {
	    var type = typeof callback;

	    if (type !== "function") {
	        throw new TypeError("sinon.test needs to wrap a test function, got " + type);
	    }

	    function sinonSandboxedTest() {
	        // TODO: Fix this atrocity
	        var config = sinonConfig.getConfig(sinonConfig.config); // Was: sinon.config
	        config.injectInto = config.injectIntoThis && this || config.injectInto;
	        var sandbox = createSandbox(config);
	        var exception, result;
	        var doneIsWrapped = false;
	        var argumentsCopy = Array.prototype.slice.call(arguments);
	        if (argumentsCopy.length > 0 && typeof argumentsCopy[arguments.length - 1] === "function") {
	            var oldDone = argumentsCopy[arguments.length - 1];
	            argumentsCopy[arguments.length - 1] = function done(result) {
	                if (result) {
	                    sandbox.restore();
	                    throw exception;
	                }
	                sandbox.verifyAndRestore();
	                oldDone(result);
	            }
	            doneIsWrapped = true;
	        }

	        var args = argumentsCopy.concat(sandbox.args);

	        try {
	            result = callback.apply(this, args);
	        } catch (e) {
	            exception = e;
	        }

	        if (!doneIsWrapped) {
	            if (typeof exception !== "undefined") {
	                sandbox.restore();
	                throw exception;
	            } else {
	                sandbox.verifyAndRestore();
	            }
	        }

	        return result;
	    };

	    if (callback.length) {
	        return function sinonAsyncSandboxedTest(callback) {
	            return sinonSandboxedTest.apply(this, arguments);
	        };
	    }

	    return sinonSandboxedTest;
	}

	test.config = {
	    injectIntoThis: true,
	    injectInto: null,
	    properties: ["spy", "stub", "mock", "clock", "server", "requests"],
	    useFakeTimers: true,
	    useFakeServer: true
	};

	module.exports = test;


/***/ },
/* 75 */
/***/ function(module, exports) {

	"use strict";
	var hasOwn = Object.prototype.hasOwnProperty;

	exports.defaultConfig = {
	    injectIntoThis: true,
	    injectInto: null,
	    properties: ["spy", "stub", "mock", "clock", "server", "requests"],
	    useFakeTimers: true,
	    useFakeServer: true
	};

	exports.getConfig = function (custom) {
	    var config = {};
	    custom = custom || {};
	    var defaults = exports.defaultConfig;

	    for (var prop in defaults) {
	        if (hasOwn.call(defaults, prop)) {
	            config[prop] = hasOwn.call(custom, prop) ? custom[prop] : defaults[prop];
	        }
	    }

	    return config;
	};


/***/ },
/* 76 */
/***/ function(module, exports, __webpack_require__) {

	"use strict";
	var test = __webpack_require__(74);

	function createTest(property, setUp, tearDown) {
	    return function () {
	        if (setUp) {
	            setUp.apply(this, arguments);
	        }

	        var exception, result;

	        try {
	            result = property.apply(this, arguments);
	        } catch (e) {
	            exception = e;
	        }

	        if (tearDown) {
	            tearDown.apply(this, arguments);
	        }

	        if (exception) {
	            throw exception;
	        }

	        return result;
	    };
	}

	function testCase(tests, prefix) {
	    /*jsl:ignore*/
	    if (!tests || typeof tests != "object") {
	        throw new TypeError("sinon.testCase needs an object with test functions");
	    }
	    /*jsl:end*/

	    prefix = prefix || "test";
	    var rPrefix = new RegExp("^" + prefix);
	    var methods = {}, testName, property, method;
	    var setUp = tests.setUp;
	    var tearDown = tests.tearDown;

	    for (testName in tests) {
	        if (tests.hasOwnProperty(testName)) {
	            property = tests[testName];

	            if (/^(setUp|tearDown)$/.test(testName)) {
	                continue;
	            }

	            if (typeof property == "function" && rPrefix.test(testName)) {
	                method = property;

	                if (setUp || tearDown) {
	                    method = createTest(property, setUp, tearDown);
	                }

	                methods[testName] = test(method);
	            } else {
	                methods[testName] = tests[testName];
	            }
	        }
	    }

	    return methods;
	}

	module.exports = testCase;


/***/ }
/******/ ]);