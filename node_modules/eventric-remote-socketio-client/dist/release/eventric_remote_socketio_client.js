(function webpackUniversalModuleDefinition(root, factory) {
	if(typeof exports === 'object' && typeof module === 'object')
		module.exports = factory();
	else if(typeof define === 'function' && define.amd)
		define(factory);
	else if(typeof exports === 'object')
		exports["eventric-remote-socketio-client"] = factory();
	else
		root["eventric-remote-socketio-client"] = factory();
})(this, function() {
return /******/ (function(modules) { // webpackBootstrap
/******/ 	// The module cache
/******/ 	var installedModules = {};

/******/ 	// The require function
/******/ 	function __webpack_require__(moduleId) {

/******/ 		// Check if module is in cache
/******/ 		if(installedModules[moduleId])
/******/ 			return installedModules[moduleId].exports;

/******/ 		// Create a new module (and put it into the cache)
/******/ 		var module = installedModules[moduleId] = {
/******/ 			exports: {},
/******/ 			id: moduleId,
/******/ 			loaded: false
/******/ 		};

/******/ 		// Execute the module function
/******/ 		modules[moduleId].call(module.exports, module, module.exports, __webpack_require__);

/******/ 		// Flag the module as loaded
/******/ 		module.loaded = true;

/******/ 		// Return the exports of the module
/******/ 		return module.exports;
/******/ 	}


/******/ 	// expose the modules object (__webpack_modules__)
/******/ 	__webpack_require__.m = modules;

/******/ 	// expose the module cache
/******/ 	__webpack_require__.c = installedModules;

/******/ 	// __webpack_public_path__
/******/ 	__webpack_require__.p = "";

/******/ 	// Load entry module and return exports
/******/ 	return __webpack_require__(0);
/******/ })
/************************************************************************/
/******/ ([
/* 0 */
/***/ function(module, exports) {

	var SocketIORemoteServiceClient,
	  slice = [].slice;

	SocketIORemoteServiceClient = (function() {
	  function SocketIORemoteServiceClient() {}

	  SocketIORemoteServiceClient.prototype.initialize = function(options) {
	    if (options == null) {
	      options = {};
	    }
	    this._subscriberId = 0;
	    this._rpcId = 0;
	    this._subscribers = [];
	    this._promises = {};
	    return this._initializeSocketIo(options);
	  };

	  SocketIORemoteServiceClient.prototype._initializeSocketIo = function(arg) {
	    var ioClientInstance;
	    ioClientInstance = arg.ioClientInstance;
	    return new Promise((function(_this) {
	      return function(resolve) {
	        _this._io_socket = ioClientInstance;
	        _this._initializeRPCResponseListener();
	        return resolve();
	      };
	    })(this));
	  };

	  SocketIORemoteServiceClient.prototype._initializeRPCResponseListener = function() {
	    return this._io_socket.on('eventric:rpcResponse', (function(_this) {
	      return function(response) {
	        return setTimeout(function() {
	          return _this._handleRpcResponse(response);
	        });
	      };
	    })(this));
	  };

	  SocketIORemoteServiceClient.prototype.rpc = function(payload) {
	    return new Promise((function(_this) {
	      return function(resolve, reject) {
	        var rpcId;
	        rpcId = _this._getNextRpcId();
	        payload.rpcId = rpcId;
	        _this._promises[rpcId] = {
	          resolve: resolve,
	          reject: reject
	        };
	        return _this._io_socket.emit('eventric:rpcRequest', payload);
	      };
	    })(this));
	  };

	  SocketIORemoteServiceClient.prototype._getNextRpcId = function() {
	    return this._rpcId++;
	  };

	  SocketIORemoteServiceClient.prototype._handleRpcResponse = function(response) {
	    if (response.rpcId == null) {
	      throw new Error('Missing rpcId in RPC Response');
	    }
	    if (!(response.rpcId in this._promises)) {
	      throw new Error("No promise registered for id " + response.rpcId);
	    }
	    if (response.error) {
	      if (response.error.constructor !== Error) {
	        response.error = this._convertObjectToError(response.error);
	      }
	      this._promises[response.rpcId].reject(response.error);
	    } else {
	      this._promises[response.rpcId].resolve(response.data);
	    }
	    return delete this._promises[response.rpcId];
	  };

	  SocketIORemoteServiceClient.prototype._convertObjectToError = function(object) {
	    var error;
	    error = new Error(object.message);
	    Object.keys(object).forEach(function(key) {
	      return error[key] = object[key];
	    });
	    return error;
	  };

	  SocketIORemoteServiceClient.prototype.subscribe = function() {
	    var aggregateId, arg, context, domainEventName, i, subscriberFn;
	    context = arguments[0], arg = 3 <= arguments.length ? slice.call(arguments, 1, i = arguments.length - 1) : (i = 1, []), subscriberFn = arguments[i++];
	    domainEventName = arg[0], aggregateId = arg[1];
	    return new Promise((function(_this) {
	      return function(resolve, reject) {
	        var fullEventName, subscriber;
	        fullEventName = _this._getFullEventName(context, domainEventName, aggregateId);
	        subscriber = {
	          eventName: fullEventName,
	          subscriberFn: subscriberFn,
	          subscriberId: _this._getNextSubscriberId()
	        };
	        _this._io_socket.emit('eventric:joinRoom', fullEventName);
	        _this._io_socket.on(fullEventName, subscriberFn);
	        _this._subscribers.push(subscriber);
	        return resolve(subscriber.subscriberId);
	      };
	    })(this));
	  };

	  SocketIORemoteServiceClient.prototype.unsubscribe = function(subscriberId) {
	    return new Promise((function(_this) {
	      return function(resolve, reject) {
	        var matchingSubscriber, othersHaveSubscribedToThisEvent;
	        matchingSubscriber = _this._subscribers.filter(function(subscriber) {
	          return subscriber.subscriberId === subscriberId;
	        })[0];
	        _this._subscribers = _this._subscribers.filter(function(subscriber) {
	          return subscriber !== matchingSubscriber;
	        });
	        _this._io_socket.removeListener(matchingSubscriber.eventName, matchingSubscriber.subscriberFn);
	        othersHaveSubscribedToThisEvent = _this._subscribers.some(function(subscriber) {
	          return subscriber.eventName === matchingSubscriber.eventName;
	        });
	        if (!othersHaveSubscribedToThisEvent) {
	          _this._io_socket.emit('eventric:leaveRoom', matchingSubscriber.eventName);
	        }
	        return resolve();
	      };
	    })(this));
	  };

	  SocketIORemoteServiceClient.prototype._getNextSubscriberId = function() {
	    return this._subscriberId++;
	  };

	  SocketIORemoteServiceClient.prototype._getFullEventName = function(context, domainEventName, aggregateId) {
	    var fullEventName;
	    fullEventName = context;
	    if (domainEventName) {
	      fullEventName += "/" + domainEventName;
	    }
	    if (aggregateId) {
	      fullEventName += "/" + aggregateId;
	    }
	    return fullEventName;
	  };

	  SocketIORemoteServiceClient.prototype.disconnect = function() {
	    return this._io_socket.disconnect();
	  };

	  return SocketIORemoteServiceClient;

	})();

	module.exports = new SocketIORemoteServiceClient;


/***/ }
/******/ ])
});
;